<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Chapter 8: Modules and Packages for Code Reuse &mdash; Jython Book v1.0 documentation</title>
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '#',
        VERSION:     '1.0',
        COLLAPSE_MODINDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="Jython Book v1.0 documentation" href="index.html" />
    <link rel="next" title="Chapter 9: Scripting With Jython" href="Scripting.html" />
    <link rel="prev" title="Chapter 7:  Exception Handling and Debugging" href="ExceptionHandlingDebug.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="Scripting.html" title="Chapter 9: Scripting With Jython"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="ExceptionHandlingDebug.html" title="Chapter 7:  Exception Handling and Debugging"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Jython Book v1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="chapter-8-modules-and-packages-for-code-reuse">
<h1>Chapter 8:  Modules and Packages for Code Reuse<a class="headerlink" href="#chapter-8-modules-and-packages-for-code-reuse" title="Permalink to this headline">¶</a></h1>
<p>Up until this chapter, we have been looking at code at the level of
the interactive console and simple scripts. This works well for
small examples, but when your program gets larger, it becomes
necessary to break programs up into smaller units. In Jython, the
basic building block for these units in larger programs is the
module.</p>
<div class="section" id="imports-for-reuse">
<h2>Imports for Reuse<a class="headerlink" href="#imports-for-reuse" title="Permalink to this headline">¶</a></h2>
<p>Breaking code up into modules helps to organize large code bases.
Modules can be used to logically separate code that belongs
together, making programs easier to understand. Modules are helpful
for creating libraries that can be imported and used in different
applications that share some functionality. Jython&#8217;s standard
library comes with a large number of modules that can be used in
your programs right away.</p>
<div class="section" id="import-basics">
<h3>Import Basics<a class="headerlink" href="#import-basics" title="Permalink to this headline">¶</a></h3>
<p>The following is a very simple program that we can use to discuss
imports.</p>
<div class="section" id="breakfast-py">
<h4>breakfast.py<a class="headerlink" href="#breakfast-py" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">search.scanner</span> <span class="kn">as</span> <span class="nn">scanner</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="k">class</span> <span class="nc">Spam</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">order</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&quot;spam &quot;</span> <span class="o">*</span> <span class="n">number</span>

    <span class="k">def</span> <span class="nf">order_eggs</span><span class="p">():</span>
        <span class="k">print</span> <span class="s">&quot; and eggs!&quot;</span>

    <span class="n">s</span> <span class="o">=</span> <span class="n">Spam</span><span class="p">()</span>
    <span class="n">s</span><span class="o">.</span><span class="n">order</span><span class="p">(</span><span class="mf">3</span><span class="p">)</span>
    <span class="n">order_eggs</span><span class="p">()</span>
</pre></div>
</div>
<p>We&#8217;ll start with a couple of definitions. A <strong>namespace</strong> is a
logical grouping of unique identifiers. In other words, a namespace
is that set of names that can be accessed from a given bit of code
in your program. For example, if you open up a Jython prompt and
type dir(), the names in the interpreter&#8217;s namespace will be
displayed.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">()</span>

<span class="go">[&#39;__doc__&#39;, &#39;__name__&#39;]</span>
</pre></div>
</div>
<p>The interpreter namespace contains __doc__ and __name__.
The __doc__ property contains the top level docstring, which is
empty in this case. We&#8217;ll get to the __name__ property in a
moment. First we need to talk about Jython <strong>modules</strong>. A
<strong>module</strong> in Jython is a file containing Python definitions and
statements which in turn define a namespace. The module name is the
same as the file name with the suffix .py removed, so in our
current example the Python file &#8216;breakfast.py&#8217; defines the module
&#8216;breakfast.&#8217;</p>
<p>Now we can talk about the __name__ property. When a module is
run directly, as in jython breakfast.py, __name__ will contain
&#8216;__main__&#8217;. If a module is imported, __name__ will contain
the name of the module, so &#8216;import breakfast&#8217; results in the
breakfast module containing a __name__ of &#8216;breakfast&#8217;. Again
from a basic Jython prompt:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">()</span>
<span class="go">[&#39;__doc__&#39;, &#39;__name__&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__name__</span>
<span class="go">&#39;__main__&#39;</span>
</pre></div>
</div>
<p>Let&#8217;s see what happens when we import breakfast:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">breakfast</span>
<span class="go">spam spam spam</span>
<span class="go">and eggs!</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">()</span>
<span class="go">[&#39;__doc__&#39;, &#39;__name__&#39;, &#39;breakfast&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">breakfast</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Checking the dir() after the import shows that breakfast has been
added to the top level namespace. Notice that the act of importing
actually executed the code in breakfast.py. This is the expected
behavior in Jython. When a module is imported, the statements in
that module are actually executed. This includes class and function
definitions. It is important to note that this only happens the
first time you import a module. Note the last statement where we
issue &#8216;import breakfast&#8217; again, resulting in no output. Most of the
time, we wouldn&#8217;t want a module to execute print statements when
imported. To avoid this, but allow the code to execute when it is
called directly, we typically check the __name__ property. If
the __name__ property is &#8216;__main__&#8217;, we know that the
module was called directly instead of being imported from another
module.</p>
<div class="highlight-python"><pre>class Spam(object):

    def order(self, number):
        print "spam " * number

    def order_eggs():
        print " and eggs!"

if __name__ == '__main__':
s = Spam()
s.order(3)
order_eggs()</pre>
</div>
<p>Now if we import breakfast (remember to close and reopen the
interpreter so that the module is actually reimported!), we will
not get the output:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">breakfast</span>
</pre></div>
</div>
<p>This is because in this case the __name__ property will contain
&#8216;breakfast,&#8217; the name of the module. If we call breakfast.py from
the commandline like &#8216;jython breakfast.py&#8217; we would then get the
output again, because breakfast would be executing as
__main__:</p>
<div class="highlight-python"><pre>$ jython breakfast.py
spam spam spam
and eggs!</pre>
</div>
</div>
</div>
<div class="section" id="the-import-statement">
<h3>The Import Statement<a class="headerlink" href="#the-import-statement" title="Permalink to this headline">¶</a></h3>
<p>In Java, the Import statement is strictly a compiler directive that
must occur at the top of the source file. In Jython, the import
statement is an expression that can occur anywhere in the source
file, and can even be conditionally executed.</p>
<p>As an example, a common idiom is to attempt to import something
that may not be there in a try block, and in the except block
define the thing in some other way, or import it from a module that
is known to be there.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>    <span class="kn">from</span> <span class="nn">blah</span> <span class="kn">import</span> <span class="n">foo</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="s">&quot;imported normally&quot;</span>
<span class="gp">... </span><span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="s">&quot;defining foo in except block&quot;</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="s">&quot;hello from backup foo&quot;</span>
<span class="gp">...</span>
<span class="go">defining foo in except block</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">foo</span><span class="p">()</span>
<span class="go">&#39;hello from backup foo&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>If a module named &#8216;blah&#8217; had existed, the definition of foo would
have been taken from there and we would have seen &#8216;imported
normally&#8217; printed out. Because no such module existed, foo was
defined in the except block, &#8216;defining foo in except block&#8217; was
printed, and when we called foo, the &#8216;hello from backup foo&#8217; string
was returned.</p>
</div>
</div>
<div class="section" id="an-example-program">
<h2>An Example Program<a class="headerlink" href="#an-example-program" title="Permalink to this headline">¶</a></h2>
<p>Here is the layout of a contrived but simple program that we will
use to describe some aspects of importing in Jython.</p>
<div class="highlight-python"><pre>chapter8/
        greetings.py
        greet/
                __init__.py
                hello.py
                people.py</pre>
</div>
<p>This example contains one package: greet, which is a package
because it is a directory containing the special __init__.py
file. Note that the directory chapter8 itself is not a package
because it does not contain an __init__.py. There are three
modules in the example program: greetings, greet.hello, and
greet.people. The code for this program can be downloaded at
<a class="reference external" href="http://kenai.com/projects/jythonbook/sources/jython-book/show/src/chapter8">http://kenai.com/projects/jythonbook/sources/jython-book/show/src/chapter8</a>.</p>
<div class="section" id="greetings-py">
<h3>greetings.py<a class="headerlink" href="#greetings-py" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre><span class="k">print</span> <span class="s">&quot;in greetings.py&quot;</span>
<span class="kn">import</span> <span class="nn">greet.hello</span>

<span class="n">g</span> <span class="o">=</span> <span class="n">greet</span><span class="o">.</span><span class="n">hello</span><span class="o">.</span><span class="n">Greeter</span><span class="p">()</span>
<span class="n">g</span><span class="o">.</span><span class="n">hello_all</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="greet-init-py">
<h3>greet/__init__.py<a class="headerlink" href="#greet-init-py" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre><span class="k">print</span> <span class="s">&quot;in greet/__init__.py&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="greet-hello-py">
<h3>greet/hello.py<a class="headerlink" href="#greet-hello-py" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre><span class="k">print</span> <span class="s">&quot;in greet/hello.py&quot;</span>
<span class="kn">import</span> <span class="nn">greet.people</span> <span class="kn">as</span> <span class="nn">people</span>

<span class="k">class</span> <span class="nc">Greeter</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">hello_all</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">people</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;hello </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">name</span>
</pre></div>
</div>
</div>
<div class="section" id="greet-people-py">
<h3>greet/people.py<a class="headerlink" href="#greet-people-py" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre><span class="k">print</span> <span class="s">&quot;in greet/people.py&quot;</span>

<span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;Josh&quot;</span><span class="p">,</span> <span class="s">&quot;Jim&quot;</span><span class="p">,</span> <span class="s">&quot;Victor&quot;</span><span class="p">,</span> <span class="s">&quot;Leo&quot;</span><span class="p">,</span> <span class="s">&quot;Frank&quot;</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="trying-out-the-example-code">
<h3>Trying Out the Example Code<a class="headerlink" href="#trying-out-the-example-code" title="Permalink to this headline">¶</a></h3>
<p>If you run greetings.py in its own directory you get the following
output:</p>
<div class="highlight-python"><pre>$ jython greetings.py
in greetings.py
in greet/__init__.py
in greet/hello.py
in greet/people.py
hello Josh
hello Jim
hello Victor
hello Leo
hello Frank</pre>
</div>
<p>There is a print statement at the top of each of the .py files to
show the order of execution for the modules. When run, the module
greetings is loaded, printing out &#8216;in greetings.py.&#8217; Next it
imports greet.hello:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">greet.hello</span>
</pre></div>
</div>
<p>Because this is the first time that the greet package has been
imported, the code in __init__.py is executed, printing &#8216;in
greet/__init__.py&#8217;. Then the greet.hello module is executed,
printing out &#8216;in greet/hello.py.&#8217; The greet.hello module then
imports the greet.people module, printing out &#8216;in greet/people.py.&#8217;
Now all of the imports are done, and greetings.py can create a
greet.hello.Greeter class and call its hello_all method.</p>
</div>
</div>
<div class="section" id="types-of-import-statements">
<h2>Types of Import Statements<a class="headerlink" href="#types-of-import-statements" title="Permalink to this headline">¶</a></h2>
<p>The import statement comes in a variety of forms that allow much
finer control over how importing brings named values into your
current module.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">module</span>
<span class="kn">from</span> <span class="nn">module</span> <span class="kn">import</span> <span class="n">submodule</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">submodule</span>
</pre></div>
</div>
<p>We will discuss each of the import statement forms in turn starting
with:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">module</span>
</pre></div>
</div>
<p>This most basic type of import imports a module directly. Unlike
Java, this form of import binds the left-most module name, so if
you import a nested module like:</p>
<p><strong>import greet.hello</strong></p>
<p>you need to refer to it as &#8216;greet.hello&#8217; and not just &#8216;hello&#8217; in
your code.</p>
<p><strong>import greet.hello as foo</strong></p>
<p>The &#8216;as foo&#8217; part of the import allows you to relabel the
&#8216;greet.hello&#8217; module as &#8216;foo&#8217; to make it more convenient to call.
The example program uses this method to relabel &#8216;greet.hello&#8217; as
&#8216;hello.&#8217; Note that it is not important that &#8216;hello&#8217; was the name of
the subpackage except that it might aid in reading the code. You
would also use this technique if the identifier of the thing you
wanted to import was already in use in this namespace: if you
already had a variable called foo, and you wanted to import
something else called foo, you could do import foo as bar.</p>
<div class="section" id="from-import-statements">
<h3>From Import Statements<a class="headerlink" href="#from-import-statements" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">module</span> <span class="kn">import</span> <span class="n">name</span>
</pre></div>
</div>
<p>This form of import allows you to import modules, classes or
functions nested in other modules. This allows you to import code
like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">greet</span> <span class="kn">import</span> <span class="n">hello</span>
</pre></div>
</div>
<p>In this case, it <em>is</em> important that &#8216;hello&#8217; is actually a
submodule of greet. This is not a relabeling but actually gets the
submodule named &#8216;hello&#8217; from the greet namespace. You can also use
the from style of import to import all of the names in a module
(except for those that start with an underscore) into your current
module using a <a href="#id1"><span class="problematic" id="id2">*</span></a>. This form of import is discouraged in the Python
community, and is particularly troublesome when importing from Java
packages (in some cases it does not work) so you should avoid its
use. It looks like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">module</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>
</div>
<p>If you are not importing from a Java package, it is sometimes
convenient to use this form to pull in everything from another
module.</p>
</div>
<div class="section" id="relative-import-statements">
<h3>Relative Import Statements<a class="headerlink" href="#relative-import-statements" title="Permalink to this headline">¶</a></h3>
<p>A new kind of import introduced in Python 2.5 is the explicit
relative import. These import statements use dots to indicate how
far back you will walk from the current nesting of modules, with
one dot meaning the current module.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">module</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">module</span>
<span class="kn">from</span> <span class="nn">.module</span> <span class="kn">import</span> <span class="n">submodule</span>
<span class="kn">from</span> <span class="nn">..module</span> <span class="kn">import</span> <span class="n">submodule</span>
</pre></div>
</div>
<p>Even though this style of importing has just been introduced, its
use is discouraged. Explicit relative imports are a reaction to the
demand for implicit relative imports. If we had wanted to import
the Greeter class out of greet.hello so that it could be
instantiated with just Greeter() instead of greet.hello.Greeter we
could have imported it like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">greet.hello</span> <span class="kn">import</span> <span class="n">Greeter</span>
</pre></div>
</div>
<p>If you wanted to import Greeter into the greet.people module, you
could get away with:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">hello</span> <span class="kn">import</span> <span class="n">Greeter</span>
</pre></div>
</div>
<p>This is a relative import. Because greet.people is a sibling module
of greet.hello, the &#8216;greet&#8217; can be left out. This relative import
style is deprecated and should not be used. Some developers like
this style so that imports will survive module restructuring, but
these relative imports can be error prone because of the
possibility of name clashes. There is a new syntax that provides an
explicit way to use relative imports, though they too are still
discouraged. The previous import statement would look like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">.hello</span> <span class="kn">import</span> <span class="n">Greeter</span>
</pre></div>
</div>
</div>
<div class="section" id="aliasing-import-statements">
<h3>Aliasing Import Statements<a class="headerlink" href="#aliasing-import-statements" title="Permalink to this headline">¶</a></h3>
<p>Any of the above imports can add an &#8216;as&#8217; clause to import a module
but give it a new name.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">module</span> <span class="kn">as</span> <span class="nn">alias</span>
<span class="kn">from</span> <span class="nn">module</span> <span class="kn">import</span> <span class="n">submodule</span> <span class="k">as</span> <span class="n">alias</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">submodule</span> <span class="k">as</span> <span class="n">alias</span>
</pre></div>
</div>
<p>This gives you enormous flexibility in your imports, so to go back
to the greet.hello example, you could issue:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">greet.hello</span> <span class="kn">as</span> <span class="nn">foo</span>
</pre></div>
</div>
<p>And use foo in place of greet.hello.</p>
</div>
<div class="section" id="hiding-module-names">
<h3>Hiding Module Names<a class="headerlink" href="#hiding-module-names" title="Permalink to this headline">¶</a></h3>
<p>Typically when a module is imported, all of the names in the module
are available to the importing module. There are a couple of ways
to hide these names from importing modules. Starting any name with
an underscore (_) will document these names as private. The names
are still accessible, they are just not imported when you import
the names of a module with &#8216;from module import <a href="#id3"><span class="problematic" id="id4">*</span></a>&#8216;. The second way
to hide module names is to define a list named __all__, which
should contain only those names that you wish to have your module
to expose. As an example here is the value of __all__ at the
top of Jython&#8217;s OS module:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;altsep&quot;</span><span class="p">,</span> <span class="s">&quot;curdir&quot;</span><span class="p">,</span> <span class="s">&quot;pardir&quot;</span><span class="p">,</span> <span class="s">&quot;sep&quot;</span><span class="p">,</span> <span class="s">&quot;pathsep&quot;</span><span class="p">,</span>
               <span class="s">&quot;linesep&quot;</span><span class="p">,</span> <span class="s">&quot;defpath&quot;</span><span class="p">,</span> <span class="s">&quot;name&quot;</span><span class="p">,</span> <span class="s">&quot;path&quot;</span><span class="p">,</span>
               <span class="s">&quot;SEEK_SET&quot;</span><span class="p">,</span> <span class="s">&quot;SEEK_CUR&quot;</span><span class="p">,</span> <span class="s">&quot;SEEK_END&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>Note that you can add to __all__ inside of a module to expand
the exposed names of that module. In fact, the os module in Jython
does just this to conditionally expose names based on the operating
system that Jython is running on.</p>
</div>
</div>
<div class="section" id="module-search-path-compilation-and-loading">
<h2>Module Search Path, Compilation, and Loading<a class="headerlink" href="#module-search-path-compilation-and-loading" title="Permalink to this headline">¶</a></h2>
<p>Understanding Jython&#8217;s process of locating, compiling, and loading
packages and modules is very helpful in getting a deeper
understanding of how things really work in Jython.</p>
<div class="section" id="java-import-example">
<h3>Java Import Example<a class="headerlink" href="#java-import-example" title="Permalink to this headline">¶</a></h3>
<p>We&#8217;ll start with a Java class which is on the CLASSPATH when Jython
is started:</p>
<div class="highlight-python"><pre>package com.foo;
public class HelloWorld {
    public void hello() {
        System.out.println("Hello World!");
    }
    public void hello(String name) {
        System.out.printf("Hello %s!", name);
    }
}</pre>
</div>
<p>Here we manipulate that class from the Jython interactive
interpreter:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">com.foo</span> <span class="kn">import</span> <span class="n">HelloWorld</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="n">HelloWorld</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span><span class="o">.</span><span class="n">hello</span><span class="p">()</span>
<span class="go">Hello World!</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span><span class="o">.</span><span class="n">hello</span><span class="p">(</span><span class="s">&quot;frank&quot;</span><span class="p">)</span>
<span class="go">Hello frank!</span>
</pre></div>
</div>
<p>It&#8217;s important to note that, because the HelloWorld program is
located on the Java CLASSPATH, it did not go through the sys.path
process we talked about before. In this case the Java class gets
loaded directly by the ClassLoader. Discussions of Java
ClassLoaders are beyond the scope of this book. To read more about
ClassLoader see execution section of the Java language
specification:</p>
<p><a class="reference external" href="http://java.sun.com/docs/books/jls/second_edition/html/execution.doc.html">http://java.sun.com/docs/books/jls/second_edition/html/execution.doc.html</a>.</p>
</div>
<div class="section" id="module-search-path-and-loading">
<h3>Module Search Path and Loading<a class="headerlink" href="#module-search-path-and-loading" title="Permalink to this headline">¶</a></h3>
<p>Understanding the process of module search and loading is more
complicated in Jython than in either CPython or Java, because
Jython can search both Java&#8217;s CLASSPATH and Python&#8217;s path. We&#8217;ll
start by looking at Python&#8217;s path and sys.path. When you issue an
import, sys.path defines the path that Jython will use to search
for the name you are trying to import. The objects within the
sys.path list tell Jython where to search for modules. Most of
these objects point to directories, but there are a few special
items that can be in sys.path for Jython that are not just pointers
to directories. Trying to import a file that does not reside
anywhere in the sys.path (and also cannot be found in the
CLASSPATH) raises an ImportError exception. Let&#8217;s fire up a command
line and look at sys.path.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">path</span>
<span class="go">[&#39;&#39;, &#39;/Users/frank/jython/Lib&#39;, &#39;__classpath__&#39;, &#39;__pyclasspath__/&#39;,</span>
<span class="go">&#39;/Users/frank/jython/Lib/site-packages&#39;]</span>
</pre></div>
</div>
<p>The first blank entry (&#8216;&#8217;) tells Jython to look in the current
directory for modules. The second entry points to Jython&#8217;s Lib
directory that contains the core Jython modules. The third and
fourth entries are special markers that we will discuss later, and
the last points to the site-packages directory where new libraries
can be installed when you issue setuptools directives from Jython
(see Appendix A for more about setuptools). The module that gets
imported is the first one that is found along this path. Once a
module is found, no more searching is done.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;/Users/frank/lib/mysql-connector-java-5.1.6.jar&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">com.mysql</span>
<span class="go">*sys-package-mgr*: processing new jar,</span>
<span class="go">&#39;/Users/frank/lib/mysql-connector-java-5.1.6.jar&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">(</span><span class="n">com</span><span class="o">.</span><span class="n">mysql</span><span class="p">)</span>
<span class="go">[&#39;__name__&#39;, &#39;jdbc&#39;]</span>
</pre></div>
</div>
<p>In this example, we added the mysql jar to the sys path, then when
we tried to find com.mysql, the jar was scanned. Note that
&#8216;com.mysql&#8217; is a Java package that is found in
mysql-connector-java-5.1.6.jar.</p>
</div>
</div>
<div class="section" id="java-package-scanning">
<h2>Java Package Scanning<a class="headerlink" href="#java-package-scanning" title="Permalink to this headline">¶</a></h2>
<p>Although you can ask the Java SDK to give you a list of all of the
packages known to a ClassLoader using:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="n">ClassLoader</span><span class="c">#getPackages()</span>
</pre></div>
</div>
<p>there is no corresponding</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="n">Package</span><span class="c">#getClasses()</span>
</pre></div>
</div>
<p>This is unfortunate for Jython, because Jython users expect to be
able to introspect the code they use in powerful ways. For example,
users expect to be able to call dir() on Java packages to see what
they contain:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">java.util.zip</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">(</span><span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">zip</span><span class="p">)</span>
<span class="go">[&#39;Adler32&#39;, &#39;CRC32&#39;, &#39;CheckedInputStream&#39;, &#39;CheckedOutputStream&#39;,</span>
<span class="go">&#39;Checksum&#39;, &#39;DataFormatException&#39;, &#39;Deflater&#39;,</span>
<span class="go">&#39;DeflaterOutputStream&#39;, &#39;GZIPInputStream&#39;, &#39;GZIPOutputStream&#39;,</span>
<span class="go">&#39;Inflater&#39;, &#39;InflaterInputStream&#39;, &#39;ZipEntry&#39;, &#39;ZipException&#39;,</span>
<span class="go">&#39;ZipFile&#39;, &#39;ZipInputStream&#39;, &#39;ZipOutputStream&#39;, &#39;__name__&#39;]</span>
</pre></div>
</div>
<p>And the same can be done on Java classes to see what they contain:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">java.util.zip</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">(</span><span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">zip</span><span class="o">.</span><span class="n">ZipInputStream</span><span class="p">)</span>
<span class="go">[&#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;,</span>
<span class="go">&#39;__getattribute__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;,</span>
<span class="go">&#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;,</span>
<span class="go">&#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;,</span>
<span class="go">&#39;__str__&#39;, &#39;available&#39;, &#39;class&#39;, &#39;close&#39;, &#39;closeEntry&#39;,</span>
<span class="go">&#39;equals&#39;, &#39;getClass&#39;, &#39;getNextEntry&#39;, &#39;hashCode&#39;, &#39;mark&#39;,</span>
<span class="go">&#39;markSupported&#39;, &#39;nextEntry&#39;, &#39;notify&#39;, &#39;notifyAll&#39;, &#39;read&#39;,</span>
<span class="go">&#39;reset&#39;, &#39;skip&#39;, &#39;toString&#39;, &#39;wait&#39;]</span>
</pre></div>
</div>
<p>Making this sort of introspection possible in the face of merged
namespaces requires some major effort the first time that Jython is
started (and when jars or classes are added to Jython&#8217;s path at
runtime). If you have ever run a new install of Jython before, you
will recognize the evidence of this system at work:</p>
<div class="highlight-python"><pre>*sys-package-mgr*: processing new jar, '/Users/frank/jython/jython.jar'
*sys-package-mgr*: processing new jar, '/System/Library/Frameworks/JavaVM.framework/Versions/1.5.0/Classes/classes.jar'
*sys-package-mgr*: processing new jar, '/System/Library/Frameworks/JavaVM.framework/Versions/1.5.0/Classes/ui.jar'
*sys-package-mgr*: processing new jar,  '/System/Library/Frameworks/JavaVM.framework/Versions/1.5.0/Classes/laf.jar'
...
*sys-package-mgr*: processing new jar, '/System/Library/Frameworks/JavaVM.framework/Versions/1.5.0/Home/lib/ext/sunjce_provider.jar'
*sys-package-mgr*: processing new jar, '/System/Library/Frameworks/JavaVM.framework/Versions/1.5.0/Home/lib/ext/sunpkcs11.jar'</pre>
</div>
<p>This is Jython scanning all of the jar files that it can find to
build an internal representation of the package and classes
available on your JVM. This has the unfortunate side effect of
making the first startup on a new Jython installation painfully
slow.</p>
<div class="section" id="how-jython-finds-the-jars-and-classes-to-scan">
<h3>How Jython Finds the Jars and Classes to Scan<a class="headerlink" href="#how-jython-finds-the-jars-and-classes-to-scan" title="Permalink to this headline">¶</a></h3>
<p>There are two properties that Jython uses to find jars and classes.
These settings can be given to Jython using commandline settings or
the registry (see Appendix A). The two properties are:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">python</span><span class="o">.</span><span class="n">packages</span><span class="o">.</span><span class="n">paths</span>
<span class="n">python</span><span class="o">.</span><span class="n">packages</span><span class="o">.</span><span class="n">directories</span>
</pre></div>
</div>
<p>These properties are comma separated lists of further registry
entries that actually contain the values the scanner will use to
build its listing. You probably should not change these properties.
The properties that get pointed to by these properties are more
interesting. The two that potentially make sense to manipulate
are:</p>
<div class="highlight-python"><pre>java.class.path
java.ext.dirs</pre>
</div>
<p>For the java.class.path property, entries are separated as the
classpath is separated on the operating system you are on (that is,
&#8216;;&#8217; on Windows and &#8216;:&#8217; on most other systems). Each of these paths
are checked for a .jar or .zip and if they have these suffixes they
will be scanned.</p>
<p>For the java.ext.dirs property, entries are separated in the same
manner as java.class.path, but these entries represent directories.
These directories are searched for any files that end with .jar or
.zip, and if any are found they are scanned.</p>
<p>To control the jars that are scanned, you need to set the values
for these properties. There are a number of ways to set these
property values, see Appendix A for more.</p>
<p>If you only use full class imports, you can skip the package
scanning altogether. Set the system property python.cachedir.skip
to true or (again) pass in your own postProperties to turn it off.</p>
</div>
<div class="section" id="compilation">
<h3>Compilation<a class="headerlink" href="#compilation" title="Permalink to this headline">¶</a></h3>
<p>Despite the popular belief that Jython is &#8216;interpreted, not
compiled,&#8217; in reality all Jython code is turned into Java bytecode
before execution. This Java bytecode is not always saved to disk,
but when you see Jython execute any code, even in an eval or an
exec, you can be sure that bytecode is getting fed to the JVM. The
sole exception to this that we know of is the experimental
pycimport module that we will describe in the section on
sys.meta_path below, which interprets CPython bytecodes instead of
producing Java bytecodes.</p>
</div>
</div>
<div class="section" id="python-modules-and-packages-versus-java-packages">
<h2>Python Modules and Packages versus Java Packages<a class="headerlink" href="#python-modules-and-packages-versus-java-packages" title="Permalink to this headline">¶</a></h2>
<p>The basic semantics of importing Python modules and packages versus
the semantics of importing Java packages into Jython differ in some
important respects that need to be kept carefully in mind.</p>
<div class="section" id="sys-path">
<h3>sys.path<a class="headerlink" href="#sys-path" title="Permalink to this headline">¶</a></h3>
<p>When Jython tries to import a module, it will look in its sys.path
in the manner described in the previous section until it finds one.
If the module it finds represents a Python module or package, this
import will display a &#8216;winner take all&#8217; semantic. That is, the
first Python module or package that gets imported blocks any other
module or package that might subsequently get found on any lookups.
This means that if you have a module foo that contains only a name
bar early in the sys.path, and then another module also called foo
that only contains a name baz, then executing &#8216;import foo&#8217; will
<strong>only</strong> give you foo.bar and not foo.baz.</p>
<p>This differs from the case when Jython is importing Java packages.
If you have a Java package org.foo containing bar, and a Java
package org.foo containing baz later in the path, executing &#8216;import
org.foo&#8217; will <strong>merge</strong> the two namespaces so that you will get
both org.foo.bar and org.foo.baz.</p>
<p>Just as important to keep in mind, if there is a Python module or
package of a particular name in your path that conflicts with a
Java package in your path this will also have a winner-take-all
effect. If the Java package is first in the path, then that name
will be bound to the merged Java packages. If the Python module or
package wins, no further searching will take place, so the Java
packages with the clashing names will never be found.</p>
</div>
<div class="section" id="naming-python-modules-and-packages">
<h3>Naming Python Modules and Packages<a class="headerlink" href="#naming-python-modules-and-packages" title="Permalink to this headline">¶</a></h3>
<p>Developers coming from Java will often make the mistake of modeling
their Jython package structure the same way that they model Java
packages. <strong>Do not do this</strong>. The reverse url convention of Java is
a great, we would even say a brilliant convention for Java. It
works very well indeed in the world of Java where these namespaces
are merged. In the Python world however, where modules and packages
display the winner-take-all semantic, this is a disastrous way to
organize your code.</p>
<p>If you adopt this style for Python, say you are coming from
&#8216;acme.com,&#8217; you would set up a package structure like &#8216;com.acme.&#8217;
If you try to use a library from your vendor xyz that is set up as
&#8216;com.xyz,&#8217; then the first of these on your path will take the &#8216;com&#8217;
namespace, and you will not be able to see the other set of
packages.</p>
</div>
<div class="section" id="proper-python-naming">
<h3>Proper Python Naming<a class="headerlink" href="#proper-python-naming" title="Permalink to this headline">¶</a></h3>
<p>The Python convention is to keep namespaces as shallow as you can,
and make your top level namespace reasonably unique, whether it is
a module or a package. In the case of acme and company xyz, you
might start your package structures with &#8216;acme&#8217; and &#8216;xyz&#8217; if you
wanted to have these entire codebases under one namespace (not
necessarily the right way to go — better to organize by product
instead of by organization, as a general rule).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">There are at least two sets of names that are
particularly bad choices for naming modules or packages in Jython.
The first is any top level domain like org, com, net, us, name. The
second is any of the domains that Java the language has reserved
for its top level namespaces: java, javax.</p>
</div>
</div>
</div>
<div class="section" id="advanced-import-manipulation">
<h2>Advanced Import Manipulation<a class="headerlink" href="#advanced-import-manipulation" title="Permalink to this headline">¶</a></h2>
<p>This section describes some advanced tools for dealing with the
internal machinery of imports. It is pretty advanced stuff that is
rarely needed, but when you need it, you <strong>really</strong> need it.</p>
<div class="section" id="import-hooks">
<h3>Import Hooks<a class="headerlink" href="#import-hooks" title="Permalink to this headline">¶</a></h3>
<p>To understand the way that Jython imports Java classes you have to
understand a bit about the Python import protocol. We won&#8217;t get
into every detail, for that you would want to look at PEP 302
<a class="reference external" href="http://www.python.org/dev/peps/pep-0302/">http://www.python.org/dev/peps/pep-0302/</a>.</p>
<p>Briefly, we first try any custom importers registered on
sys.meta_path. If one of them is capable of importing the
requested module, allow that importer to handle it. Next, we try
each of the entries on sys.path. For each of these, we find the
first hook registered on sys.path_hooks that can handle the path
entry. If we find an import hook and it successfully imports the
module, we stop. If this did not work, we try the builtin import
logic. If that also fails, an ImportError is thrown. So let&#8217;s look
at Jython&#8217;s path_hooks.</p>
</div>
<div class="section" id="sys-path-hooks">
<h3>sys.path_hooks<a class="headerlink" href="#sys-path-hooks" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">path_hooks</span>
<span class="go">[&lt;type &#39;org.python.core.JavaImporter&#39;&gt;, &lt;type &#39;zipimport.zipimporter&#39;&gt;,</span>
<span class="go">&lt;type &#39;ClasspathPyImporter&#39;&gt;]</span>
</pre></div>
</div>
<p>Each of these path_hooks entries specifies a path_hook that will
attempt to import special files. JavaImporter, as its name implies,
allows the dynamic loading of Java packages and classes that are
specified at runtime. For example, if you want to include a jar at
runtime you can execute the following code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;mysql-connector-java-5.1.6.jar&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">com.mysql</span>
<span class="go">*sys-package-mgr*: processing new jar, &#39;mysqlconnector-java-5.1.6.jar&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">(</span><span class="n">com</span><span class="o">.</span><span class="n">mysql</span><span class="p">)</span>
<span class="go">[&#39;__name__&#39;, &#39;jdbc&#39;]</span>
</pre></div>
</div>
<p>Note how the package scanning gets kicked off when &#8216;com.mysql&#8217; is
imported, as evidenced by the line starting with
<em>sys-package-mgr</em>. Upon import, the JavaImporter scanned the new
jar and allowed the import to succeed.</p>
</div>
<div class="section" id="sys-meta-path">
<h3>sys.meta_path<a class="headerlink" href="#sys-meta-path" title="Permalink to this headline">¶</a></h3>
<p>Adding entries to sys.meta_path allows you to add import behaviors
that will occur before any other import is attempted, even the
default builtin importing behavior. This can be a very powerful
tool, allowing you to do all sorts of interesting things. As an
example, we will talk about an experimental module that ships with
Jython 2.5. That module is pycimport. If you start up Jython and
issue</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pycimport</span>
</pre></div>
</div>
<p>Jython will start scanning for .pyc files in your path and, if it
finds one, it will use the .pyc file to load your module.pyc files.
These are the files that CPython produces when it compiles Python
source code. So, after you have imported pycimport (which adds a
hook to sys.meta_path) then issue:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">foo</span>
</pre></div>
</div>
<p>Jython will scan your path for a file named foo.pyc, and if it
finds one it will import the foo module using the CPython
bytecodes. It does this by creating a special class that defines a
find_module method that specifies how to load in a pyc file. This
class is then added to the meta search path with the
sys.meta_path.insert method. The find_module method calls into
other parts of pycimport and looks for .pyc files. If it finds one,
it knows how to parse and execute those files and adds the
corresponding module to the runtime. Pretty cool, eh?</p>
</div>
</div>
<div class="section" id="summary">
<h2>Summary<a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h2>
<p>In this chapter, you have learned how to divide code up into
modules to for the purpose of organization and reuse. We have
learned how to write modules and packages, and how the Jython
system interacts with Java classes and packages. This ends Part I.
We have now covered the basics of the Jython language and are now
ready to learn how to use Jython.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h3><a href="index.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference external" href="#">Chapter 8:  Modules and Packages for Code Reuse</a><ul>
<li><a class="reference external" href="#imports-for-reuse">Imports for Reuse</a><ul>
<li><a class="reference external" href="#import-basics">Import Basics</a><ul>
<li><a class="reference external" href="#breakfast-py">breakfast.py</a></li>
</ul>
</li>
<li><a class="reference external" href="#the-import-statement">The Import Statement</a></li>
</ul>
</li>
<li><a class="reference external" href="#an-example-program">An Example Program</a><ul>
<li><a class="reference external" href="#greetings-py">greetings.py</a></li>
<li><a class="reference external" href="#greet-init-py">greet/__init__.py</a></li>
<li><a class="reference external" href="#greet-hello-py">greet/hello.py</a></li>
<li><a class="reference external" href="#greet-people-py">greet/people.py</a></li>
<li><a class="reference external" href="#trying-out-the-example-code">Trying Out the Example Code</a></li>
</ul>
</li>
<li><a class="reference external" href="#types-of-import-statements">Types of Import Statements</a><ul>
<li><a class="reference external" href="#from-import-statements">From Import Statements</a></li>
<li><a class="reference external" href="#relative-import-statements">Relative Import Statements</a></li>
<li><a class="reference external" href="#aliasing-import-statements">Aliasing Import Statements</a></li>
<li><a class="reference external" href="#hiding-module-names">Hiding Module Names</a></li>
</ul>
</li>
<li><a class="reference external" href="#module-search-path-compilation-and-loading">Module Search Path, Compilation, and Loading</a><ul>
<li><a class="reference external" href="#java-import-example">Java Import Example</a></li>
<li><a class="reference external" href="#module-search-path-and-loading">Module Search Path and Loading</a></li>
</ul>
</li>
<li><a class="reference external" href="#java-package-scanning">Java Package Scanning</a><ul>
<li><a class="reference external" href="#how-jython-finds-the-jars-and-classes-to-scan">How Jython Finds the Jars and Classes to Scan</a></li>
<li><a class="reference external" href="#compilation">Compilation</a></li>
</ul>
</li>
<li><a class="reference external" href="#python-modules-and-packages-versus-java-packages">Python Modules and Packages versus Java Packages</a><ul>
<li><a class="reference external" href="#sys-path">sys.path</a></li>
<li><a class="reference external" href="#naming-python-modules-and-packages">Naming Python Modules and Packages</a></li>
<li><a class="reference external" href="#proper-python-naming">Proper Python Naming</a></li>
</ul>
</li>
<li><a class="reference external" href="#advanced-import-manipulation">Advanced Import Manipulation</a><ul>
<li><a class="reference external" href="#import-hooks">Import Hooks</a></li>
<li><a class="reference external" href="#sys-path-hooks">sys.path_hooks</a></li>
<li><a class="reference external" href="#sys-meta-path">sys.meta_path</a></li>
</ul>
</li>
<li><a class="reference external" href="#summary">Summary</a></li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="ExceptionHandlingDebug.html"
                                  title="previous chapter">Chapter 7: &nbsp;Exception Handling and Debugging</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="Scripting.html"
                                  title="next chapter">Chapter 9:  Scripting With Jython</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="_sources/ModulesPackages.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="search.html" method="get">
                <input type="text" name="q" size="18" />
                <input type="submit" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="Scripting.html" title="Chapter 9: Scripting With Jython"
             >next</a> |</li>
        <li class="right" >
          <a href="ExceptionHandlingDebug.html" title="Chapter 7:  Exception Handling and Debugging"
             >previous</a> |</li>
        <li><a href="index.html">Jython Book v1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
  
    <div class="footer">
      &copy; Copyright 2009,2010, Josh Juneau, Frank Wierzbicki, Jim Baker, Leo Soto, Victor Ng.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 0.6.5.
    </div>
    <script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-13131153-1");
pageTracker._trackPageview();
} catch(err) {}</script>
  </body>
</html>