<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>7.4. difflib — Helpers for computing deltas &mdash; Jython v2.5.2 documentation</title>
    <link rel="stylesheet" href="../_static/green-theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.5.2',
        COLLAPSE_MODINDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Jython v2.5.2 documentation" href="../index.html" />
    <link rel="up" title="7. String Services" href="strings.html" />
    <link rel="next" title="7.5. StringIO — Read and write strings as files" href="stringio.html" />
    <link rel="prev" title="7.3. struct — Interpret strings as packed binary data" href="struct.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../modindex.html" title="Global Module Index"
             accesskey="M">modules</a> |</li>
        <li class="right" >
          <a href="stringio.html" title="7.5. StringIO — Read and write strings as files"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="struct.html" title="7.3. struct — Interpret strings as packed binary data"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Jython v2.5.2 documentation</a> &raquo;</li>
          <li><a href="indexprogress.html" >The Python Standard Library and What Comes with Jython</a> &raquo;</li>
          <li><a href="strings.html" accesskey="U">7. String Services</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/jython.png" alt="Logo"/>
            </a></p>
            <h3><a href="../index.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference external" href="#">7.4. <tt class="docutils literal"><span class="pre">difflib</span></tt> &#8212; Helpers for computing deltas</a><ul>
<li><a class="reference external" href="#sequencematcher-objects">7.4.1. SequenceMatcher Objects</a></li>
<li><a class="reference external" href="#sequencematcher-examples">7.4.2. SequenceMatcher Examples</a></li>
<li><a class="reference external" href="#differ-objects">7.4.3. Differ Objects</a></li>
<li><a class="reference external" href="#differ-example">7.4.4. Differ Example</a></li>
<li><a class="reference external" href="#a-command-line-interface-to-difflib">7.4.5. A command-line interface to difflib</a></li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="struct.html"
                                  title="previous chapter">7.3. <tt class="docutils literal"><span class="pre">struct</span></tt> &#8212; Interpret strings as packed binary data</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="stringio.html"
                                  title="next chapter">7.5. <tt class="docutils literal"><span class="pre">StringIO</span></tt> &#8212; Read and write strings as files</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../_sources/library/difflib.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="../search.html" method="get">
                <input type="text" name="q" size="18" />
                <input type="submit" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="difflib-helpers-for-computing-deltas">
<h1>7.4. <tt class="docutils literal"><span class="pre">difflib</span></tt> &#8212; Helpers for computing deltas<a class="headerlink" href="#difflib-helpers-for-computing-deltas" title="Permalink to this headline">¶</a></h1>
<p>New in version 2.1.</p>
<p>This module provides classes and functions for comparing sequences. It
can be used for example, for comparing files, and can produce
difference information in various formats, including HTML and context
and unified diffs. For comparing directories and files, see also, the
<tt class="docutils literal"><span class="pre">filecmp</span></tt> module.</p>
<p>class class difflib.SequenceMatcher</p>
<blockquote>
<p>This is a flexible class for comparing pairs of sequences of any
type, so long as the sequence elements are <em>hashable</em>.  The basic
algorithm predates, and is a little fancier than, an algorithm
published in the late 1980&#8217;s by Ratcliff and Obershelp under the
hyperbolic name &#8220;gestalt pattern matching.&#8221;  The idea is to find
the longest contiguous matching subsequence that contains no &#8220;junk&#8221;
elements (the Ratcliff and Obershelp algorithm doesn&#8217;t address
junk).  The same idea is then applied recursively to the pieces of
the sequences to the left and to the right of the matching
subsequence.  This does not yield minimal edit sequences, but does
tend to yield matches that &#8220;look right&#8221; to people.</p>
<p><strong>Timing:</strong> The basic Ratcliff-Obershelp algorithm is cubic time in
the worst case and quadratic time in the expected case.
<tt class="docutils literal"><span class="pre">SequenceMatcher</span></tt> is quadratic time for the worst case and has
expected-case behavior dependent in a complicated way on how many
elements the sequences have in common; best case time is linear.</p>
</blockquote>
<p>class class difflib.Differ</p>
<blockquote>
<p>This is a class for comparing sequences of lines of text, and
producing human-readable differences or deltas.  Differ uses
<tt class="docutils literal"><span class="pre">SequenceMatcher</span></tt> both to compare sequences of lines, and to
compare sequences of characters within similar (near-matching)
lines.</p>
<p>Each line of a <tt class="docutils literal"><span class="pre">Differ</span></tt> delta begins with a two-letter code:</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Code</th>
<th class="head">Meaning</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal"><span class="pre">'-</span> <span class="pre">'</span></tt></td>
<td>line unique to sequence 1</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">'+</span> <span class="pre">'</span></tt></td>
<td>line unique to sequence 2</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">'</span>&nbsp; <span class="pre">'</span></tt></td>
<td>line common to both sequences</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">'?</span> <span class="pre">'</span></tt></td>
<td>line not present in either input sequence</td>
</tr>
</tbody>
</table>
<p>Lines beginning with &#8216;<tt class="docutils literal"><span class="pre">?</span></tt>&#8216; attempt to guide the eye to intraline
differences, and were not present in either input sequence. These
lines can be confusing if the sequences contain tab characters.</p>
</blockquote>
<p>class class difflib.HtmlDiff</p>
<blockquote>
<p>This class can be used to create an HTML table (or a complete HTML
file containing the table) showing a side by side, line by line
comparison of text with inter-line and intra-line change
highlights.  The table can be generated in either full or
contextual difference mode.</p>
<p>The constructor for this class is:</p>
<p>__init__([tabsize][, wrapcolumn][, linejunk][, charjunk])</p>
<blockquote>
<p>Initializes instance of <tt class="docutils literal"><span class="pre">HtmlDiff</span></tt>.</p>
<p><em>tabsize</em> is an optional keyword argument to specify tab stop
spacing and defaults to <tt class="docutils literal"><span class="pre">8</span></tt>.</p>
<p><em>wrapcolumn</em> is an optional keyword to specify column number
where lines are broken and wrapped, defaults to <tt class="xref docutils literal"><span class="pre">None</span></tt> where
lines are not wrapped.</p>
<p><em>linejunk</em> and <em>charjunk</em> are optional keyword arguments passed
into <tt class="docutils literal"><span class="pre">ndiff()</span></tt> (used by <tt class="docutils literal"><span class="pre">HtmlDiff</span></tt> to generate the side by
side HTML differences).  See <tt class="docutils literal"><span class="pre">ndiff()</span></tt> documentation for
argument default values and descriptions.</p>
</blockquote>
<p>The following methods are public:</p>
<p>make_file(fromlines, tolines[, fromdesc][, todesc][, context][, numlines])</p>
<blockquote>
<p>Compares <em>fromlines</em> and <em>tolines</em> (lists of strings) and
returns a string which is a complete HTML file containing a
table showing line by line differences with inter-line and
intra-line changes highlighted.</p>
<p><em>fromdesc</em> and <em>todesc</em> are optional keyword arguments to
specify from/to file column header strings (both default to an
empty string).</p>
<p><em>context</em> and <em>numlines</em> are both optional keyword arguments.
Set <em>context</em> to <tt class="xref docutils literal"><span class="pre">True</span></tt> when contextual differences are to be
shown, else the default is <tt class="xref docutils literal"><span class="pre">False</span></tt> to show the full files.
<em>numlines</em> defaults to <tt class="docutils literal"><span class="pre">5</span></tt>.  When <em>context</em> is <tt class="xref docutils literal"><span class="pre">True</span></tt>
<em>numlines</em> controls the number of context lines which surround
the difference highlights.  When <em>context</em> is <tt class="xref docutils literal"><span class="pre">False</span></tt>
<em>numlines</em> controls the number of lines which are shown before a
difference highlight when using the &#8220;next&#8221; hyperlinks (setting
to zero would cause the &#8220;next&#8221; hyperlinks to place the next
difference highlight at the top of the browser without any
leading context).</p>
</blockquote>
<p>make_table(fromlines, tolines[, fromdesc][, todesc][, context][, numlines])</p>
<blockquote>
<p>Compares <em>fromlines</em> and <em>tolines</em> (lists of strings) and
returns a string which is a complete HTML table showing line by
line differences with inter-line and intra-line changes
highlighted.</p>
<p>The arguments for this method are the same as those for the
<tt class="docutils literal"><span class="pre">make_file()</span></tt> method.</p>
</blockquote>
<p><tt class="docutils literal"><span class="pre">Tools/scripts/diff.py</span></tt> is a command-line front-end to this class
and contains a good example of its use.</p>
<p>New in version 2.4.</p>
</blockquote>
<p>difflib.context_diff(a, b[, fromfile][, tofile][, fromfiledate][, tofiledate][, n][, lineterm])</p>
<blockquote>
<p>Compare <em>a</em> and <em>b</em> (lists of strings); return a delta (a
<em>generator</em> generating the delta lines) in context diff format.</p>
<p>Context diffs are a compact way of showing just the lines that have
changed plus a few lines of context.  The changes are shown in a
before/after style.  The number of context lines is set by <em>n</em>
which defaults to three.</p>
<p>By default, the diff control lines (those with <tt class="docutils literal"><span class="pre">***</span></tt> or <tt class="docutils literal"><span class="pre">---</span></tt>)
are created with a trailing newline.  This is helpful so that
inputs created from <tt class="docutils literal"><span class="pre">file.readlines()</span></tt> result in diffs that are
suitable for use with <tt class="docutils literal"><span class="pre">file.writelines()</span></tt> since both the inputs
and outputs have trailing newlines.</p>
<p>For inputs that do not have trailing newlines, set the <em>lineterm</em>
argument to <tt class="docutils literal"><span class="pre">&quot;&quot;</span></tt> so that the output will be uniformly newline
free.</p>
<p>The context diff format normally has a header for filenames and
modification times.  Any or all of these may be specified using
strings for <em>fromfile</em>, <em>tofile</em>, <em>fromfiledate</em>, and <em>tofiledate</em>.
The modification times are normally expressed in the format
returned by <tt class="docutils literal"><span class="pre">time.ctime()</span></tt>.  If not specified, the strings
default to blanks.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;bacon</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">,</span> <span class="s">&#39;eggs</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">,</span> <span class="s">&#39;ham</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">,</span> <span class="s">&#39;guido</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;python</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">,</span> <span class="s">&#39;eggy</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">,</span> <span class="s">&#39;hamster</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">,</span> <span class="s">&#39;guido</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">context_diff</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">fromfile</span><span class="o">=</span><span class="s">&#39;before.py&#39;</span><span class="p">,</span> <span class="n">tofile</span><span class="o">=</span><span class="s">&#39;after.py&#39;</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>  <span class="c"># doctest: +NORMALIZE_WHITESPACE</span>
<span class="go">*** before.py</span>
<span class="go">--- after.py</span>
<span class="go">***************</span>
<span class="go">*** 1,4 ****</span>
<span class="go">! bacon</span>
<span class="go">! eggs</span>
<span class="go">! ham</span>
<span class="go">  guido</span>
<span class="go">--- 1,4 ----</span>
<span class="go">! python</span>
<span class="go">! eggy</span>
<span class="go">! hamster</span>
<span class="go">  guido</span>
</pre></div>
</div>
<p>See <em>A command-line interface to difflib</em> for a more detailed
example.</p>
<p>New in version 2.3.</p>
</blockquote>
<p>difflib.get_close_matches(word, possibilities[, n][, cutoff])</p>
<blockquote>
<p>Return a list of the best &#8220;good enough&#8221; matches.  <em>word</em> is a
sequence for which close matches are desired (typically a string),
and <em>possibilities</em> is a list of sequences against which to match
<em>word</em> (typically a list of strings).</p>
<p>Optional argument <em>n</em> (default <tt class="docutils literal"><span class="pre">3</span></tt>) is the maximum number of
close matches to return; <em>n</em> must be greater than <tt class="docutils literal"><span class="pre">0</span></tt>.</p>
<p>Optional argument <em>cutoff</em> (default <tt class="docutils literal"><span class="pre">0.6</span></tt>) is a float in the
range [0, 1]. Possibilities that don&#8217;t score at least that similar
to <em>word</em> are ignored.</p>
<p>The best (no more than <em>n</em>) matches among the possibilities are
returned in a list, sorted by similarity score, most similar first.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">get_close_matches</span><span class="p">(</span><span class="s">&#39;appel&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;ape&#39;</span><span class="p">,</span> <span class="s">&#39;apple&#39;</span><span class="p">,</span> <span class="s">&#39;peach&#39;</span><span class="p">,</span> <span class="s">&#39;puppy&#39;</span><span class="p">])</span>
<span class="go">[&#39;apple&#39;, &#39;ape&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">keyword</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_close_matches</span><span class="p">(</span><span class="s">&#39;wheel&#39;</span><span class="p">,</span> <span class="n">keyword</span><span class="o">.</span><span class="n">kwlist</span><span class="p">)</span>
<span class="go">[&#39;while&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_close_matches</span><span class="p">(</span><span class="s">&#39;apple&#39;</span><span class="p">,</span> <span class="n">keyword</span><span class="o">.</span><span class="n">kwlist</span><span class="p">)</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_close_matches</span><span class="p">(</span><span class="s">&#39;accept&#39;</span><span class="p">,</span> <span class="n">keyword</span><span class="o">.</span><span class="n">kwlist</span><span class="p">)</span>
<span class="go">[&#39;except&#39;]</span>
</pre></div>
</div>
</blockquote>
<p>difflib.ndiff(a, b[, linejunk][, charjunk])</p>
<blockquote>
<p>Compare <em>a</em> and <em>b</em> (lists of strings); return a <tt class="docutils literal"><span class="pre">Differ</span></tt>-style
delta (a <em>generator</em> generating the delta lines).</p>
<p>Optional keyword parameters <em>linejunk</em> and <em>charjunk</em> are for
filter functions (or <tt class="xref docutils literal"><span class="pre">None</span></tt>):</p>
<p><em>linejunk</em>: A function that accepts a single string argument, and
returns true if the string is junk, or false if not. The default is
(<tt class="xref docutils literal"><span class="pre">None</span></tt>), starting with Python 2.3.  Before then, the default was
the module-level function <tt class="docutils literal"><span class="pre">IS_LINE_JUNK()</span></tt>, which filters out
lines without visible characters, except for at most one pound
character (<tt class="docutils literal"><span class="pre">'#'</span></tt>). As of Python 2.3, the underlying
<tt class="docutils literal"><span class="pre">SequenceMatcher</span></tt> class does a dynamic analysis of which lines
are so frequent as to constitute noise, and this usually works
better than the pre-2.3 default.</p>
<p><em>charjunk</em>: A function that accepts a character (a string of length
1), and returns if the character is junk, or false if not. The
default is module-level function <tt class="docutils literal"><span class="pre">IS_CHARACTER_JUNK()</span></tt>, which
filters out whitespace characters (a blank or tab; note: bad idea
to include newline in this!).</p>
<p><tt class="docutils literal"><span class="pre">Tools/scripts/ndiff.py</span></tt> is a command-line front-end to this
function.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">diff</span> <span class="o">=</span> <span class="n">ndiff</span><span class="p">(</span><span class="s">&#39;one</span><span class="se">\n</span><span class="s">two</span><span class="se">\n</span><span class="s">three</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">splitlines</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
<span class="gp">... </span>             <span class="s">&#39;ore</span><span class="se">\n</span><span class="s">tree</span><span class="se">\n</span><span class="s">emu</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">splitlines</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">diff</span><span class="p">),</span>
<span class="go">- one</span>
<span class="go">?  ^</span>
<span class="go">+ ore</span>
<span class="go">?  ^</span>
<span class="go">- two</span>
<span class="go">- three</span>
<span class="go">?  -</span>
<span class="go">+ tree</span>
<span class="go">+ emu</span>
</pre></div>
</div>
</blockquote>
<p>difflib.restore(sequence, which)</p>
<blockquote>
<p>Return one of the two sequences that generated a delta.</p>
<p>Given a <em>sequence</em> produced by <tt class="docutils literal"><span class="pre">Differ.compare()</span></tt> or <tt class="docutils literal"><span class="pre">ndiff()</span></tt>,
extract lines originating from file 1 or 2 (parameter <em>which</em>),
stripping off line prefixes.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">diff</span> <span class="o">=</span> <span class="n">ndiff</span><span class="p">(</span><span class="s">&#39;one</span><span class="se">\n</span><span class="s">two</span><span class="se">\n</span><span class="s">three</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">splitlines</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
<span class="gp">... </span>             <span class="s">&#39;ore</span><span class="se">\n</span><span class="s">tree</span><span class="se">\n</span><span class="s">emu</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">splitlines</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">diff</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span> <span class="c"># materialize the generated delta into a list</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">restore</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
<span class="go">one</span>
<span class="go">two</span>
<span class="go">three</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">restore</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="mi">2</span><span class="p">)),</span>
<span class="go">ore</span>
<span class="go">tree</span>
<span class="go">emu</span>
</pre></div>
</div>
</blockquote>
<p>difflib.unified_diff(a, b[, fromfile][, tofile][, fromfiledate][, tofiledate][, n][, lineterm])</p>
<blockquote>
<p>Compare <em>a</em> and <em>b</em> (lists of strings); return a delta (a
<em>generator</em> generating the delta lines) in unified diff format.</p>
<p>Unified diffs are a compact way of showing just the lines that have
changed plus a few lines of context.  The changes are shown in a
inline style (instead of separate before/after blocks).  The number
of context lines is set by <em>n</em> which defaults to three.</p>
<p>By default, the diff control lines (those with <tt class="docutils literal"><span class="pre">---</span></tt>, <tt class="docutils literal"><span class="pre">+++</span></tt>, or
<tt class="docutils literal"><span class="pre">&#64;&#64;</span></tt>) are created with a trailing newline.  This is helpful so
that inputs created from <tt class="docutils literal"><span class="pre">file.readlines()</span></tt> result in diffs that
are suitable for use with <tt class="docutils literal"><span class="pre">file.writelines()</span></tt> since both the
inputs and outputs have trailing newlines.</p>
<p>For inputs that do not have trailing newlines, set the <em>lineterm</em>
argument to <tt class="docutils literal"><span class="pre">&quot;&quot;</span></tt> so that the output will be uniformly newline
free.</p>
<p>The context diff format normally has a header for filenames and
modification times.  Any or all of these may be specified using
strings for <em>fromfile</em>, <em>tofile</em>, <em>fromfiledate</em>, and <em>tofiledate</em>.
The modification times are normally expressed in the format
returned by <tt class="docutils literal"><span class="pre">time.ctime()</span></tt>.  If not specified, the strings
default to blanks.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;bacon</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">,</span> <span class="s">&#39;eggs</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">,</span> <span class="s">&#39;ham</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">,</span> <span class="s">&#39;guido</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;python</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">,</span> <span class="s">&#39;eggy</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">,</span> <span class="s">&#39;hamster</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">,</span> <span class="s">&#39;guido</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">unified_diff</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">fromfile</span><span class="o">=</span><span class="s">&#39;before.py&#39;</span><span class="p">,</span> <span class="n">tofile</span><span class="o">=</span><span class="s">&#39;after.py&#39;</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>   <span class="c"># doctest: +NORMALIZE_WHITESPACE</span>
<span class="go">--- before.py</span>
<span class="go">+++ after.py</span>
<span class="go">@@ -1,4 +1,4 @@</span>
<span class="go">-bacon</span>
<span class="go">-eggs</span>
<span class="go">-ham</span>
<span class="go">+python</span>
<span class="go">+eggy</span>
<span class="go">+hamster</span>
<span class="go"> guido</span>
</pre></div>
</div>
<p>See <em>A command-line interface to difflib</em> for a more detailed
example.</p>
<p>New in version 2.3.</p>
</blockquote>
<p>difflib.IS_LINE_JUNK(line)</p>
<blockquote>
Return true for ignorable lines.  The line <em>line</em> is ignorable if
<em>line</em> is blank or contains a single <tt class="docutils literal"><span class="pre">'#'</span></tt>, otherwise it is not
ignorable.  Used as a default for parameter <em>linejunk</em> in
<tt class="docutils literal"><span class="pre">ndiff()</span></tt> before Python 2.3.</blockquote>
<p>difflib.IS_CHARACTER_JUNK(ch)</p>
<blockquote>
Return true for ignorable characters.  The character <em>ch</em> is
ignorable if <em>ch</em> is a space or tab, otherwise it is not ignorable.
Used as a default for parameter <em>charjunk</em> in <tt class="docutils literal"><span class="pre">ndiff()</span></tt>.</blockquote>
<p>See also:</p>
<blockquote>
<dl class="docutils">
<dt>Pattern Matching: The Gestalt Approach</dt>
<dd>Discussion of a similar algorithm by John W. Ratcliff and D. E.
Metzener. This was published in Dr. Dobb&#8217;s Journal in July,
1988.</dd>
</dl>
</blockquote>
<div class="section" id="sequencematcher-objects">
<h2>7.4.1. SequenceMatcher Objects<a class="headerlink" href="#sequencematcher-objects" title="Permalink to this headline">¶</a></h2>
<p>The <tt class="docutils literal"><span class="pre">SequenceMatcher</span></tt> class has this constructor:</p>
<p>class class difflib.SequenceMatcher([isjunk[, a[, b]]])</p>
<blockquote>
<p>Optional argument <em>isjunk</em> must be <tt class="xref docutils literal"><span class="pre">None</span></tt> (the default) or a one-
argument function that takes a sequence element and returns true if
and only if the element is &#8220;junk&#8221; and should be ignored. Passing
<tt class="xref docutils literal"><span class="pre">None</span></tt> for <em>isjunk</em> is equivalent to passing <tt class="docutils literal"><span class="pre">lambda</span> <span class="pre">x:</span> <span class="pre">0</span></tt>; in
other words, no elements are ignored. For example, pass:</p>
<blockquote>
lambda x: x in &#8221; t&#8221;</blockquote>
<p>if you&#8217;re comparing lines as sequences of characters, and don&#8217;t
want to synch up on blanks or hard tabs.</p>
<p>The optional arguments <em>a</em> and <em>b</em> are sequences to be compared;
both default to empty strings.  The elements of both sequences must
be <em>hashable</em>.</p>
<p><tt class="docutils literal"><span class="pre">SequenceMatcher</span></tt> objects have the following methods:</p>
<p>set_seqs(a, b)</p>
<blockquote>
Set the two sequences to be compared.</blockquote>
<p><tt class="docutils literal"><span class="pre">SequenceMatcher</span></tt> computes and caches detailed information about
the second sequence, so if you want to compare one sequence against
many sequences, use <tt class="docutils literal"><span class="pre">set_seq2()</span></tt> to set the commonly used
sequence once and call <tt class="docutils literal"><span class="pre">set_seq1()</span></tt> repeatedly, once for each of
the other sequences.</p>
<p>set_seq1(a)</p>
<blockquote>
Set the first sequence to be compared.  The second sequence to
be compared is not changed.</blockquote>
<p>set_seq2(b)</p>
<blockquote>
Set the second sequence to be compared.  The first sequence to
be compared is not changed.</blockquote>
<p>find_longest_match(alo, ahi, blo, bhi)</p>
<blockquote>
<p>Find longest matching block in <tt class="docutils literal"><span class="pre">a[alo:ahi]</span></tt> and
<tt class="docutils literal"><span class="pre">b[blo:bhi]</span></tt>.</p>
<p>If <em>isjunk</em> was omitted or <tt class="xref docutils literal"><span class="pre">None</span></tt>, <tt class="docutils literal"><span class="pre">find_longest_match()</span></tt>
returns <tt class="docutils literal"><span class="pre">(i,</span> <span class="pre">j,</span> <span class="pre">k)</span></tt> such that <tt class="docutils literal"><span class="pre">a[i:i+k]</span></tt> is equal to
<tt class="docutils literal"><span class="pre">b[j:j+k]</span></tt>, where <tt class="docutils literal"><span class="pre">alo</span> <span class="pre">&lt;=</span> <span class="pre">i</span> <span class="pre">&lt;=</span> <span class="pre">i+k</span> <span class="pre">&lt;=</span> <span class="pre">ahi</span></tt> and <tt class="docutils literal"><span class="pre">blo</span> <span class="pre">&lt;=</span> <span class="pre">j</span> <span class="pre">&lt;=</span>
<span class="pre">j+k</span> <span class="pre">&lt;=</span> <span class="pre">bhi</span></tt>. For all <tt class="docutils literal"><span class="pre">(i',</span> <span class="pre">j',</span> <span class="pre">k')</span></tt> meeting those conditions,
the additional conditions <tt class="docutils literal"><span class="pre">k</span> <span class="pre">&gt;=</span> <span class="pre">k'</span></tt>, <tt class="docutils literal"><span class="pre">i</span> <span class="pre">&lt;=</span> <span class="pre">i'</span></tt>, and if <tt class="docutils literal"><span class="pre">i</span>
<span class="pre">==</span> <span class="pre">i'</span></tt>, <tt class="docutils literal"><span class="pre">j</span> <span class="pre">&lt;=</span> <span class="pre">j'</span></tt> are also met. In other words, of all
maximal matching blocks, return one that starts earliest in <em>a</em>,
and of all those maximal matching blocks that start earliest in
<em>a</em>, return the one that starts earliest in <em>b</em>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">SequenceMatcher</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="s">&quot; abcd&quot;</span><span class="p">,</span> <span class="s">&quot;abcd abcd&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">find_longest_match</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
<span class="go">Match(a=0, b=4, size=5)</span>
</pre></div>
</div>
<p>If <em>isjunk</em> was provided, first the longest matching block is
determined as above, but with the additional restriction that no
junk element appears in the block.  Then that block is extended
as far as possible by matching (only) junk elements on both
sides. So the resulting block never matches on junk except as
identical junk happens to be adjacent to an interesting match.</p>
<p>Here&#8217;s the same example as before, but considering blanks to be
junk. That prevents <tt class="docutils literal"><span class="pre">'</span> <span class="pre">abcd'</span></tt> from matching the <tt class="docutils literal"><span class="pre">'</span> <span class="pre">abcd'</span></tt> at
the tail end of the second sequence directly.  Instead only the
<tt class="docutils literal"><span class="pre">'abcd'</span></tt> can match, and matches the leftmost <tt class="docutils literal"><span class="pre">'abcd'</span></tt> in the
second sequence:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">SequenceMatcher</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">==</span><span class="s">&quot; &quot;</span><span class="p">,</span> <span class="s">&quot; abcd&quot;</span><span class="p">,</span> <span class="s">&quot;abcd abcd&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">find_longest_match</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
<span class="go">Match(a=1, b=0, size=4)</span>
</pre></div>
</div>
<p>If no blocks match, this returns <tt class="docutils literal"><span class="pre">(alo,</span> <span class="pre">blo,</span> <span class="pre">0)</span></tt>.</p>
<p>Changed in version 2.6: This method returns a <em>named tuple</em>
<tt class="docutils literal"><span class="pre">Match(a,</span> <span class="pre">b,</span> <span class="pre">size)</span></tt>.</p>
</blockquote>
<p>get_matching_blocks()</p>
<blockquote>
<p>Return list of triples describing matching subsequences. Each
triple is of the form <tt class="docutils literal"><span class="pre">(i,</span> <span class="pre">j,</span> <span class="pre">n)</span></tt>, and means that <tt class="docutils literal"><span class="pre">a[i:i+n]</span>
<span class="pre">==</span> <span class="pre">b[j:j+n]</span></tt>.  The triples are monotonically increasing in <em>i</em>
and <em>j</em>.</p>
<p>The last triple is a dummy, and has the value <tt class="docutils literal"><span class="pre">(len(a),</span> <span class="pre">len(b),</span>
<span class="pre">0)</span></tt>.  It is the only triple with <tt class="docutils literal"><span class="pre">n</span> <span class="pre">==</span> <span class="pre">0</span></tt>.  If <tt class="docutils literal"><span class="pre">(i,</span> <span class="pre">j,</span> <span class="pre">n)</span></tt>
and <tt class="docutils literal"><span class="pre">(i',</span> <span class="pre">j',</span> <span class="pre">n')</span></tt> are adjacent triples in the list, and the
second is not the last triple in the list, then <tt class="docutils literal"><span class="pre">i+n</span> <span class="pre">!=</span> <span class="pre">i'</span></tt> or
<tt class="docutils literal"><span class="pre">j+n</span> <span class="pre">!=</span> <span class="pre">j'</span></tt>; in other words, adjacent triples always describe
non-adjacent equal blocks.</p>
<p>Changed in version 2.5: The guarantee that adjacent triples
always describe non-adjacent blocks was implemented.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">SequenceMatcher</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="s">&quot;abxcd&quot;</span><span class="p">,</span> <span class="s">&quot;abcd&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">get_matching_blocks</span><span class="p">()</span>
<span class="go">[Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)]</span>
</pre></div>
</div>
</blockquote>
<p>get_opcodes()</p>
<blockquote>
<p>Return list of 5-tuples describing how to turn <em>a</em> into <em>b</em>.
Each tuple is of the form <tt class="docutils literal"><span class="pre">(tag,</span> <span class="pre">i1,</span> <span class="pre">i2,</span> <span class="pre">j1,</span> <span class="pre">j2)</span></tt>.  The first
tuple has <tt class="docutils literal"><span class="pre">i1</span> <span class="pre">==</span> <span class="pre">j1</span> <span class="pre">==</span> <span class="pre">0</span></tt>, and remaining tuples have <em>i1</em>
equal to the <em>i2</em> from the preceding tuple, and, likewise, <em>j1</em>
equal to the previous <em>j2</em>.</p>
<p>The <em>tag</em> values are strings, with these meanings:</p>
<table border="1" class="docutils">
<colgroup>
<col width="27%" />
<col width="73%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Value</th>
<th class="head">Meaning</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal"><span class="pre">'replace'</span></tt></td>
<td><tt class="docutils literal"><span class="pre">a[i1:i2]</span></tt> should be replaced by
<tt class="docutils literal"><span class="pre">b[j1:j2]</span></tt>.</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">'delete'</span></tt></td>
<td><tt class="docutils literal"><span class="pre">a[i1:i2]</span></tt> should be deleted.  Note that
<tt class="docutils literal"><span class="pre">j1</span> <span class="pre">==</span> <span class="pre">j2</span></tt> in this case.</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">'insert'</span></tt></td>
<td><tt class="docutils literal"><span class="pre">b[j1:j2]</span></tt> should be inserted at
<tt class="docutils literal"><span class="pre">a[i1:i1]</span></tt>. Note that <tt class="docutils literal"><span class="pre">i1</span> <span class="pre">==</span> <span class="pre">i2</span></tt> in this
case.</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">'equal'</span></tt></td>
<td><tt class="docutils literal"><span class="pre">a[i1:i2]</span> <span class="pre">==</span> <span class="pre">b[j1:j2]</span></tt> (the sub-sequences
are equal).</td>
</tr>
</tbody>
</table>
<p>For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="s">&quot;qabxcd&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="s">&quot;abycdf&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">SequenceMatcher</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">tag</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">,</span> <span class="n">j1</span><span class="p">,</span> <span class="n">j2</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">get_opcodes</span><span class="p">():</span>
<span class="gp">... </span>   <span class="k">print</span> <span class="p">(</span><span class="s">&quot;</span><span class="si">%7s</span><span class="s"> a[</span><span class="si">%d</span><span class="s">:</span><span class="si">%d</span><span class="s">] (</span><span class="si">%s</span><span class="s">) b[</span><span class="si">%d</span><span class="s">:</span><span class="si">%d</span><span class="s">] (</span><span class="si">%s</span><span class="s">)&quot;</span> <span class="o">%</span>
<span class="gp">... </span>          <span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="n">i1</span><span class="p">:</span><span class="n">i2</span><span class="p">],</span> <span class="n">j1</span><span class="p">,</span> <span class="n">j2</span><span class="p">,</span> <span class="n">b</span><span class="p">[</span><span class="n">j1</span><span class="p">:</span><span class="n">j2</span><span class="p">]))</span>
<span class="go"> delete a[0:1] (q) b[0:0] ()</span>
<span class="go">  equal a[1:3] (ab) b[0:2] (ab)</span>
<span class="go">replace a[3:4] (x) b[2:3] (y)</span>
<span class="go">  equal a[4:6] (cd) b[3:5] (cd)</span>
<span class="go"> insert a[6:6] () b[5:6] (f)</span>
</pre></div>
</div>
</blockquote>
<p>get_grouped_opcodes([n])</p>
<blockquote>
<p>Return a <em>generator</em> of groups with up to <em>n</em> lines of context.</p>
<p>Starting with the groups returned by <tt class="docutils literal"><span class="pre">get_opcodes()</span></tt>, this
method splits out smaller change clusters and eliminates
intervening ranges which have no changes.</p>
<p>The groups are returned in the same format as <tt class="docutils literal"><span class="pre">get_opcodes()</span></tt>.</p>
<p>New in version 2.3.</p>
</blockquote>
<p>ratio()</p>
<blockquote>
<p>Return a measure of the sequences&#8217; similarity as a float in the
range [0, 1].</p>
<p>Where T is the total number of elements in both sequences, and M
is the number of matches, this is 2.0*M / T. Note that this is
<tt class="docutils literal"><span class="pre">1.0</span></tt> if the sequences are identical, and <tt class="docutils literal"><span class="pre">0.0</span></tt> if they have
nothing in common.</p>
<p>This is expensive to compute if <tt class="docutils literal"><span class="pre">get_matching_blocks()</span></tt> or
<tt class="docutils literal"><span class="pre">get_opcodes()</span></tt> hasn&#8217;t already been called, in which case you
may want to try <tt class="docutils literal"><span class="pre">quick_ratio()</span></tt> or <tt class="docutils literal"><span class="pre">real_quick_ratio()</span></tt>
first to get an upper bound.</p>
</blockquote>
<p>quick_ratio()</p>
<blockquote>
<p>Return an upper bound on <tt class="docutils literal"><span class="pre">ratio()</span></tt> relatively quickly.</p>
<p>This isn&#8217;t defined beyond that it is an upper bound on
<tt class="docutils literal"><span class="pre">ratio()</span></tt>, and is faster to compute.</p>
</blockquote>
<p>real_quick_ratio()</p>
<blockquote>
<p>Return an upper bound on <tt class="docutils literal"><span class="pre">ratio()</span></tt> very quickly.</p>
<p>This isn&#8217;t defined beyond that it is an upper bound on
<tt class="docutils literal"><span class="pre">ratio()</span></tt>, and is faster to compute than either <tt class="docutils literal"><span class="pre">ratio()</span></tt> or
<tt class="docutils literal"><span class="pre">quick_ratio()</span></tt>.</p>
</blockquote>
</blockquote>
<p>The three methods that return the ratio of matching to total
characters can give different results due to differing levels of
approximation, although <tt class="docutils literal"><span class="pre">quick_ratio()</span></tt> and <tt class="docutils literal"><span class="pre">real_quick_ratio()</span></tt>
are always at least as large as <tt class="docutils literal"><span class="pre">ratio()</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">SequenceMatcher</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="s">&quot;abcd&quot;</span><span class="p">,</span> <span class="s">&quot;bcde&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">ratio</span><span class="p">()</span>
<span class="go">0.75</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">quick_ratio</span><span class="p">()</span>
<span class="go">0.75</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">real_quick_ratio</span><span class="p">()</span>
<span class="go">1.0</span>
</pre></div>
</div>
</div>
<div class="section" id="sequencematcher-examples">
<h2>7.4.2. SequenceMatcher Examples<a class="headerlink" href="#sequencematcher-examples" title="Permalink to this headline">¶</a></h2>
<p>This example compares two strings, considering blanks to be &#8220;junk:&#8221;</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">SequenceMatcher</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">==</span> <span class="s">&quot; &quot;</span><span class="p">,</span>
<span class="gp">... </span>                    <span class="s">&quot;private Thread currentThread;&quot;</span><span class="p">,</span>
<span class="gp">... </span>                    <span class="s">&quot;private volatile Thread currentThread;&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">ratio()</span></tt> returns a float in [0, 1], measuring the similarity of the
sequences.  As a rule of thumb, a <tt class="docutils literal"><span class="pre">ratio()</span></tt> value over 0.6 means the
sequences are close matches:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="nb">round</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">ratio</span><span class="p">(),</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">0.866</span>
</pre></div>
</div>
<p>If you&#8217;re only interested in where the sequences match,
<tt class="docutils literal"><span class="pre">get_matching_blocks()</span></tt> is handy:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">get_matching_blocks</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="s">&quot;a[</span><span class="si">%d</span><span class="s">] and b[</span><span class="si">%d</span><span class="s">] match for </span><span class="si">%d</span><span class="s"> elements&quot;</span> <span class="o">%</span> <span class="n">block</span>
<span class="go">a[0] and b[0] match for 8 elements</span>
<span class="go">a[8] and b[17] match for 21 elements</span>
<span class="go">a[29] and b[38] match for 0 elements</span>
</pre></div>
</div>
<p>Note that the last tuple returned by <tt class="docutils literal"><span class="pre">get_matching_blocks()</span></tt> is
always a dummy, <tt class="docutils literal"><span class="pre">(len(a),</span> <span class="pre">len(b),</span> <span class="pre">0)</span></tt>, and this is the only case in
which the last tuple element (number of elements matched) is <tt class="docutils literal"><span class="pre">0</span></tt>.</p>
<p>If you want to know how to change the first sequence into the second,
use <tt class="docutils literal"><span class="pre">get_opcodes()</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">opcode</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">get_opcodes</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="s">&quot;</span><span class="si">%6s</span><span class="s"> a[</span><span class="si">%d</span><span class="s">:</span><span class="si">%d</span><span class="s">] b[</span><span class="si">%d</span><span class="s">:</span><span class="si">%d</span><span class="s">]&quot;</span> <span class="o">%</span> <span class="n">opcode</span>
<span class="go"> equal a[0:8] b[0:8]</span>
<span class="go">insert a[8:8] b[8:17]</span>
<span class="go"> equal a[8:29] b[17:38]</span>
</pre></div>
</div>
<p>See also the function <tt class="docutils literal"><span class="pre">get_close_matches()</span></tt> in this module, which
shows how simple code building on <tt class="docutils literal"><span class="pre">SequenceMatcher</span></tt> can be used to
do useful work.</p>
</div>
<div class="section" id="differ-objects">
<h2>7.4.3. Differ Objects<a class="headerlink" href="#differ-objects" title="Permalink to this headline">¶</a></h2>
<p>Note that <tt class="docutils literal"><span class="pre">Differ</span></tt>-generated deltas make no claim to be <strong>minimal</strong>
diffs. To the contrary, minimal diffs are often counter-intuitive,
because they synch up anywhere possible, sometimes accidental matches
100 pages apart. Restricting synch points to contiguous matches
preserves some notion of locality, at the occasional cost of producing
a longer diff.</p>
<p>The <tt class="docutils literal"><span class="pre">Differ</span></tt> class has this constructor:</p>
<p>class class difflib.Differ([linejunk[, charjunk]])</p>
<blockquote>
<p>Optional keyword parameters <em>linejunk</em> and <em>charjunk</em> are for
filter functions (or <tt class="xref docutils literal"><span class="pre">None</span></tt>):</p>
<p><em>linejunk</em>: A function that accepts a single string argument, and
returns true if the string is junk.  The default is <tt class="xref docutils literal"><span class="pre">None</span></tt>,
meaning that no line is considered junk.</p>
<p><em>charjunk</em>: A function that accepts a single character argument (a
string of length 1), and returns true if the character is junk. The
default is <tt class="xref docutils literal"><span class="pre">None</span></tt>, meaning that no character is considered junk.</p>
<p><tt class="docutils literal"><span class="pre">Differ</span></tt> objects are used (deltas generated) via a single method:</p>
<p>compare(a, b)</p>
<blockquote>
<p>Compare two sequences of lines, and generate the delta (a
sequence of lines).</p>
<p>Each sequence must contain individual single-line strings ending
with newlines. Such sequences can be obtained from the
<tt class="docutils literal"><span class="pre">readlines()</span></tt> method of file-like objects.  The delta
generated also consists of newline-terminated strings, ready to
be printed as-is via the <tt class="docutils literal"><span class="pre">writelines()</span></tt> method of a file-like
object.</p>
</blockquote>
</blockquote>
</div>
<div class="section" id="differ-example">
<h2>7.4.4. Differ Example<a class="headerlink" href="#differ-example" title="Permalink to this headline">¶</a></h2>
<p>This example compares two texts. First we set up the texts, sequences
of individual single-line strings ending with newlines (such sequences
can also be obtained from the <tt class="docutils literal"><span class="pre">readlines()</span></tt> method of file-like
objects):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">text1</span> <span class="o">=</span> <span class="s">&#39;&#39;&#39;  1. Beautiful is better than ugly.</span>
<span class="gp">... </span><span class="s">  2. Explicit is better than implicit.</span>
<span class="gp">... </span><span class="s">  3. Simple is better than complex.</span>
<span class="gp">... </span><span class="s">  4. Complex is better than complicated.</span>
<span class="gp">... </span><span class="s">&#39;&#39;&#39;</span><span class="o">.</span><span class="n">splitlines</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">text1</span><span class="p">)</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">text1</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">&#39;\n&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">text2</span> <span class="o">=</span> <span class="s">&#39;&#39;&#39;  1. Beautiful is better than ugly.</span>
<span class="gp">... </span><span class="s">  3.   Simple is better than complex.</span>
<span class="gp">... </span><span class="s">  4. Complicated is better than complex.</span>
<span class="gp">... </span><span class="s">  5. Flat is better than nested.</span>
<span class="gp">... </span><span class="s">&#39;&#39;&#39;</span><span class="o">.</span><span class="n">splitlines</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Next we instantiate a Differ object:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">Differ</span><span class="p">()</span>
</pre></div>
</div>
<p>Note that when instantiating a <tt class="docutils literal"><span class="pre">Differ</span></tt> object we may pass functions
to filter out line and character &#8220;junk.&#8221;  See the <tt class="docutils literal"><span class="pre">Differ()</span></tt>
constructor for details.</p>
<p>Finally, we compare the two:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">text1</span><span class="p">,</span> <span class="n">text2</span><span class="p">))</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">result</span></tt> is a list of strings, so let&#8217;s pretty-print it:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pprint</span> <span class="kn">import</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="go">[&#39;    1. Beautiful is better than ugly.\n&#39;,</span>
<span class="go"> &#39;-   2. Explicit is better than implicit.\n&#39;,</span>
<span class="go"> &#39;-   3. Simple is better than complex.\n&#39;,</span>
<span class="go"> &#39;+   3.   Simple is better than complex.\n&#39;,</span>
<span class="go"> &#39;?     ++\n&#39;,</span>
<span class="go"> &#39;-   4. Complex is better than complicated.\n&#39;,</span>
<span class="go"> &#39;?            ^                     ---- ^\n&#39;,</span>
<span class="go"> &#39;+   4. Complicated is better than complex.\n&#39;,</span>
<span class="go"> &#39;?           ++++ ^                      ^\n&#39;,</span>
<span class="go"> &#39;+   5. Flat is better than nested.\n&#39;]</span>
</pre></div>
</div>
<p>As a single multi-line string it looks like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">writelines</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="go">    1. Beautiful is better than ugly.</span>
<span class="go">-   2. Explicit is better than implicit.</span>
<span class="go">-   3. Simple is better than complex.</span>
<span class="go">+   3.   Simple is better than complex.</span>
<span class="go">?     ++</span>
<span class="go">-   4. Complex is better than complicated.</span>
<span class="go">?            ^                     ---- ^</span>
<span class="go">+   4. Complicated is better than complex.</span>
<span class="go">?           ++++ ^                      ^</span>
<span class="go">+   5. Flat is better than nested.</span>
</pre></div>
</div>
</div>
<div class="section" id="a-command-line-interface-to-difflib">
<h2>7.4.5. A command-line interface to difflib<a class="headerlink" href="#a-command-line-interface-to-difflib" title="Permalink to this headline">¶</a></h2>
<p>This example shows how to use difflib to create a <tt class="docutils literal"><span class="pre">diff</span></tt>-like
utility. It is also contained in the Python source distribution, as
<tt class="docutils literal"><span class="pre">Tools/scripts/diff.py</span></tt>.</p>
<blockquote>
<p>&#8220;&#8221;&#8221; Command line interface to difflib.py providing diffs in four formats:</p>
<ul class="simple">
<li>ndiff:    lists every line and highlights interline changes.</li>
<li>context:  highlights clusters of changes in a before/after format.</li>
<li>unified:  highlights clusters of changes in an inline format.</li>
<li>html:     generates side by side comparison with change highlights.</li>
</ul>
<p>&#8220;&#8221;&#8220;</p>
<p>import sys, os, time, difflib, optparse</p>
<dl class="docutils">
<dt>def main():</dt>
<dd><blockquote class="first">
# Configure the option parser</blockquote>
<p>usage = &#8220;usage: %prog [options] fromfile tofile&#8221;
parser = optparse.OptionParser(usage)
parser.add_option(&#8220;-c&#8221;, action=&#8221;store_true&#8221;, default=False,</p>
<blockquote>
help=&#8217;Produce a context format diff (default)&#8217;)</blockquote>
<dl class="docutils">
<dt>parser.add_option(&#8220;-u&#8221;, action=&#8221;store_true&#8221;, default=False,</dt>
<dd>help=&#8217;Produce a unified format diff&#8217;)</dd>
</dl>
<p>hlp = &#8216;Produce HTML side by side diff (can use -c and -l in conjunction)&#8217;
parser.add_option(&#8220;-m&#8221;, action=&#8221;store_true&#8221;, default=False, help=hlp)
parser.add_option(&#8220;-n&#8221;, action=&#8221;store_true&#8221;, default=False,</p>
<blockquote>
help=&#8217;Produce a ndiff format diff&#8217;)</blockquote>
<dl class="docutils">
<dt>parser.add_option(&#8220;-l&#8221;, &#8220;&#8211;lines&#8221;, type=&#8221;int&#8221;, default=3,</dt>
<dd>help=&#8217;Set number of context lines (default 3)&#8217;)</dd>
</dl>
<p>(options, args) = parser.parse_args()</p>
<dl class="docutils">
<dt>if len(args) == 0:</dt>
<dd>parser.print_help()
sys.exit(1)</dd>
<dt>if len(args) != 2:</dt>
<dd>parser.error(&#8220;need to specify both a fromfile and tofile&#8221;)</dd>
</dl>
<p>n = options.lines
fromfile, tofile = args # as specified in the usage string</p>
<p># we&#8217;re passing these as arguments to the diff function
fromdate = time.ctime(os.stat(fromfile).st_mtime)
todate = time.ctime(os.stat(tofile).st_mtime)
fromlines = open(fromfile, &#8216;U&#8217;).readlines()
tolines = open(tofile, &#8216;U&#8217;).readlines()</p>
<dl class="docutils">
<dt>if options.u:</dt>
<dd><dl class="first last docutils">
<dt>diff = difflib.unified_diff(fromlines, tolines, fromfile, tofile,</dt>
<dd>fromdate, todate, n=n)</dd>
</dl>
</dd>
<dt>elif options.n:</dt>
<dd>diff = difflib.ndiff(fromlines, tolines)</dd>
<dt>elif options.m:</dt>
<dd><dl class="first last docutils">
<dt>diff = difflib.HtmlDiff().make_file(fromlines, tolines, fromfile,</dt>
<dd>tofile, context=options.c,
numlines=n)</dd>
</dl>
</dd>
<dt>else:</dt>
<dd><dl class="first last docutils">
<dt>diff = difflib.context_diff(fromlines, tolines, fromfile, tofile,</dt>
<dd>fromdate, todate, n=n)</dd>
</dl>
</dd>
</dl>
<p class="last"># we&#8217;re using writelines because diff is a generator
sys.stdout.writelines(diff)</p>
</dd>
<dt>if __name__ == &#8216;__main__&#8217;:</dt>
<dd>main()</dd>
</dl>
</blockquote>
</div>
</div>


          </div>
        </div>
      </div>


      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../modindex.html" title="Global Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="stringio.html" title="7.5. StringIO — Read and write strings as files"
             >next</a> |</li>
        <li class="right" >
          <a href="struct.html" title="7.3. struct — Interpret strings as packed binary data"
             >previous</a> |</li>
        <li><a href="../index.html">Jython v2.5.2 documentation</a> &raquo;</li>
          <li><a href="indexprogress.html" >The Python Standard Library and What Comes with Jython</a> &raquo;</li>
          <li><a href="strings.html" >7. String Services</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
      &copy; <a href="../copyright.html">Copyright</a> 2011, Jython Project.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 0.6.4.
    </div>
  </body>
</html>