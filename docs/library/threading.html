<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>16.2. threading — Higher-level threading interface &mdash; Jython v2.5.2 documentation</title>
    <link rel="stylesheet" href="../_static/green-theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.5.2',
        COLLAPSE_MODINDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Jython v2.5.2 documentation" href="../index.html" />
    <link rel="up" title="16. Optional Operating System Services" href="someos.html" />
    <link rel="next" title="16.3. thread — Multiple threads of control" href="thread.html" />
    <link rel="prev" title="16.1. select — Waiting for I/O completion" href="select.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../modindex.html" title="Global Module Index"
             accesskey="M">modules</a> |</li>
        <li class="right" >
          <a href="thread.html" title="16.3. thread — Multiple threads of control"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="select.html" title="16.1. select — Waiting for I/O completion"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Jython v2.5.2 documentation</a> &raquo;</li>
          <li><a href="indexprogress.html" >The Python Standard Library and What Comes with Jython</a> &raquo;</li>
          <li><a href="someos.html" accesskey="U">16. Optional Operating System Services</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/jython.png" alt="Logo"/>
            </a></p>
            <h3><a href="../index.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference external" href="#">16.2. <tt class="docutils literal"><span class="pre">threading</span></tt> &#8212; Higher-level threading interface</a><ul>
<li><a class="reference external" href="#thread-objects">16.2.1. Thread Objects</a></li>
<li><a class="reference external" href="#lock-objects">16.2.2. Lock Objects</a></li>
<li><a class="reference external" href="#rlock-objects">16.2.3. RLock Objects</a></li>
<li><a class="reference external" href="#condition-objects">16.2.4. Condition Objects</a></li>
<li><a class="reference external" href="#semaphore-objects">16.2.5. Semaphore Objects</a><ul>
<li><a class="reference external" href="#semaphore-example">16.2.5.1. <tt class="docutils literal"><span class="pre">Semaphore</span></tt> Example</a></li>
</ul>
</li>
<li><a class="reference external" href="#event-objects">16.2.6. Event Objects</a></li>
<li><a class="reference external" href="#timer-objects">16.2.7. Timer Objects</a></li>
<li><a class="reference external" href="#using-locks-conditions-and-semaphores-in-the-with-statement">16.2.8. Using locks, conditions, and semaphores in the <tt class="docutils literal"><span class="pre">with</span></tt> statement</a></li>
<li><a class="reference external" href="#importing-in-threaded-code">16.2.9. Importing in threaded code</a></li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="select.html"
                                  title="previous chapter">16.1. <tt class="docutils literal docutils literal docutils literal"><span class="pre">select</span></tt> &#8212; Waiting for I/O completion</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="thread.html"
                                  title="next chapter">16.3. <tt class="docutils literal docutils literal docutils literal"><span class="pre">thread</span></tt> &#8212; Multiple threads of control</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../_sources/library/threading.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="../search.html" method="get">
                <input type="text" name="q" size="18" />
                <input type="submit" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="threading-higher-level-threading-interface">
<h1>16.2. <tt class="docutils literal"><span class="pre">threading</span></tt> &#8212; Higher-level threading interface<a class="headerlink" href="#threading-higher-level-threading-interface" title="Permalink to this headline">¶</a></h1>
<p>This module constructs higher-level threading interfaces on top of the
lower level <tt class="docutils literal"><span class="pre">thread</span></tt> module. See also the <tt class="docutils literal"><span class="pre">mutex</span></tt> and <tt class="docutils literal"><span class="pre">Queue</span></tt>
modules.</p>
<p>The <tt class="docutils literal"><span class="pre">dummy_threading</span></tt> module is provided for situations where
<tt class="docutils literal"><span class="pre">threading</span></tt> cannot be used because <tt class="docutils literal"><span class="pre">thread</span></tt> is missing.</p>
<dl class="docutils">
<dt>Note: Starting with Python 2.6, this module provides PEP 8 compliant</dt>
<dd>aliases and properties to replace the <tt class="docutils literal"><span class="pre">camelCase</span></tt> names that were
inspired by Java&#8217;s threading API. This updated API is compatible
with that of the <tt class="docutils literal"><span class="pre">multiprocessing</span></tt> module. However, no schedule
has been set for the deprecation of the <tt class="docutils literal"><span class="pre">camelCase</span></tt> names and they
remain fully supported in both Python 2.x and 3.x.</dd>
<dt>Note: Starting with Python 2.5, several Thread methods raise</dt>
<dd><tt class="docutils literal"><span class="pre">RuntimeError</span></tt> instead of <tt class="docutils literal"><span class="pre">AssertionError</span></tt> if called
erroneously.</dd>
</dl>
<p>This module defines the following functions and objects:</p>
<p>threading.active_count()
threading.activeCount()</p>
<blockquote>
Return the number of <tt class="docutils literal"><span class="pre">Thread</span></tt> objects currently alive.  The
returned count is equal to the length of the list returned by
<tt class="docutils literal"><span class="pre">enumerate()</span></tt>.</blockquote>
<p>threading.Condition()</p>
<blockquote>
A factory function that returns a new condition variable object. A
condition variable allows one or more threads to wait until they
are notified by another thread.</blockquote>
<p>threading.current_thread()
threading.currentThread()</p>
<blockquote>
Return the current <tt class="docutils literal"><span class="pre">Thread</span></tt> object, corresponding to the caller&#8217;s
thread of control.  If the caller&#8217;s thread of control was not
created through the <tt class="docutils literal"><span class="pre">threading</span></tt> module, a dummy thread object
with limited functionality is returned.</blockquote>
<p>threading.enumerate()</p>
<blockquote>
Return a list of all <tt class="docutils literal"><span class="pre">Thread</span></tt> objects currently alive.  The list
includes daemonic threads, dummy thread objects created by
<tt class="docutils literal"><span class="pre">current_thread()</span></tt>, and the main thread.  It excludes terminated
threads and threads that have not yet been started.</blockquote>
<p>threading.Event()</p>
<blockquote>
A factory function that returns a new event object.  An event
manages a flag that can be set to true with the <tt class="docutils literal"><span class="pre">set()</span></tt> method
and reset to false with the <tt class="docutils literal"><span class="pre">clear()</span></tt> method.  The <tt class="docutils literal"><span class="pre">wait()</span></tt>
method blocks until the flag is true.</blockquote>
<p>class class threading.local</p>
<blockquote>
<p>A class that represents thread-local data.  Thread-local data are
data whose values are thread specific.  To manage thread-local
data, just create an instance of <tt class="docutils literal"><span class="pre">local</span></tt> (or a subclass) and
store attributes on it:</p>
<blockquote>
mydata = threading.local()
mydata.x = 1</blockquote>
<p>The instance&#8217;s values will be different for separate threads.</p>
<p>For more details and extensive examples, see the documentation
string of the <tt class="docutils literal"><span class="pre">_threading_local</span></tt> module.</p>
<p>New in version 2.4.</p>
</blockquote>
<p>threading.Lock()</p>
<blockquote>
A factory function that returns a new primitive lock object.  Once
a thread has acquired it, subsequent attempts to acquire it block,
until it is released; any thread may release it.</blockquote>
<p>threading.RLock()</p>
<blockquote>
A factory function that returns a new reentrant lock object. A
reentrant lock must be released by the thread that acquired it.
Once a thread has acquired a reentrant lock, the same thread may
acquire it again without blocking; the thread must release it once
for each time it has acquired it.</blockquote>
<p>threading.Semaphore([value])</p>
<blockquote>
A factory function that returns a new semaphore object.  A
semaphore manages a counter representing the number of
<tt class="docutils literal"><span class="pre">release()</span></tt> calls minus the number of <tt class="docutils literal"><span class="pre">acquire()</span></tt> calls, plus
an initial value. The <tt class="docutils literal"><span class="pre">acquire()</span></tt> method blocks if necessary
until it can return without making the counter negative.  If not
given, <em>value</em> defaults to 1.</blockquote>
<p>threading.BoundedSemaphore([value])</p>
<blockquote>
A factory function that returns a new bounded semaphore object.  A
bounded semaphore checks to make sure its current value doesn&#8217;t
exceed its initial value.  If it does, <tt class="docutils literal"><span class="pre">ValueError</span></tt> is raised. In
most situations semaphores are used to guard resources with limited
capacity.  If the semaphore is released too many times it&#8217;s a sign
of a bug.  If not given, <em>value</em> defaults to 1.</blockquote>
<p>class class threading.Thread</p>
<blockquote>
A class that represents a thread of control.  This class can be
safely subclassed in a limited fashion.</blockquote>
<p>class class threading.Timer</p>
<blockquote>
A thread that executes a function after a specified interval has
passed.</blockquote>
<p>threading.settrace(func)</p>
<blockquote>
<p>Set a trace function for all threads started from the <tt class="docutils literal"><span class="pre">threading</span></tt>
module. The <em>func</em> will be passed to  <tt class="docutils literal"><span class="pre">sys.settrace()</span></tt> for each
thread, before its <tt class="docutils literal"><span class="pre">run()</span></tt> method is called.</p>
<p>New in version 2.3.</p>
</blockquote>
<p>threading.setprofile(func)</p>
<blockquote>
<p>Set a profile function for all threads started from the
<tt class="docutils literal"><span class="pre">threading</span></tt> module. The <em>func</em> will be passed to
<tt class="docutils literal"><span class="pre">sys.setprofile()</span></tt> for each thread, before its <tt class="docutils literal"><span class="pre">run()</span></tt> method
is called.</p>
<p>New in version 2.3.</p>
</blockquote>
<p>threading.stack_size([size])</p>
<blockquote>
<p>Return the thread stack size used when creating new threads.  The
optional <em>size</em> argument specifies the stack size to be used for
subsequently created threads, and must be 0 (use platform or
configured default) or a positive integer value of at least 32,768
(32kB). If changing the thread stack size is unsupported, a
<tt class="docutils literal"><span class="pre">ThreadError</span></tt> is raised.  If the specified stack size is invalid,
a <tt class="docutils literal"><span class="pre">ValueError</span></tt> is raised and the stack size is unmodified.  32kB
is currently the minimum supported stack size value to guarantee
sufficient stack space for the interpreter itself.  Note that some
platforms may have particular restrictions on values for the stack
size, such as requiring a minimum stack size &gt; 32kB or requiring
allocation in multiples of the system memory page size - platform
documentation should be referred to for more information (4kB pages
are common; using multiples of 4096 for the stack size is the
suggested approach in the absence of more specific information).
Availability: Windows, systems with POSIX threads.</p>
<p>New in version 2.5.</p>
</blockquote>
<p>Detailed interfaces for the objects are documented below.</p>
<p>The design of this module is loosely based on Java&#8217;s threading model.
However, where Java makes locks and condition variables basic behavior
of every object, they are separate objects in Python.  Python&#8217;s
<tt class="docutils literal"><span class="pre">Thread</span></tt> class supports a subset of the behavior of Java&#8217;s Thread
class; currently, there are no priorities, no thread groups, and
threads cannot be destroyed, stopped, suspended, resumed, or
interrupted.  The static methods of Java&#8217;s Thread class, when
implemented, are mapped to module-level functions.</p>
<p>All of the methods described below are executed atomically.</p>
<div class="section" id="thread-objects">
<h2>16.2.1. Thread Objects<a class="headerlink" href="#thread-objects" title="Permalink to this headline">¶</a></h2>
<p>This class represents an activity that is run in a separate thread of
control. There are two ways to specify the activity: by passing a
callable object to the constructor, or by overriding the <tt class="docutils literal"><span class="pre">run()</span></tt>
method in a subclass.  No other methods (except for the constructor)
should be overridden in a subclass.  In other words,  <em>only</em>  override
the <tt class="docutils literal"><span class="pre">__init__()</span></tt> and <tt class="docutils literal"><span class="pre">run()</span></tt> methods of this class.</p>
<p>Once a thread object is created, its activity must be started by
calling the thread&#8217;s <tt class="docutils literal"><span class="pre">start()</span></tt> method.  This invokes the <tt class="docutils literal"><span class="pre">run()</span></tt>
method in a separate thread of control.</p>
<p>Once the thread&#8217;s activity is started, the thread is considered
&#8216;alive&#8217;. It stops being alive when its <tt class="docutils literal"><span class="pre">run()</span></tt> method terminates &#8211;
either normally, or by raising an unhandled exception.  The
<tt class="docutils literal"><span class="pre">is_alive()</span></tt> method tests whether the thread is alive.</p>
<p>Other threads can call a thread&#8217;s <tt class="docutils literal"><span class="pre">join()</span></tt> method.  This blocks the
calling thread until the thread whose <tt class="docutils literal"><span class="pre">join()</span></tt> method is called is
terminated.</p>
<p>A thread has a name.  The name can be passed to the constructor, and
read or changed through the <tt class="docutils literal"><span class="pre">name</span></tt> attribute.</p>
<p>A thread can be flagged as a &#8220;daemon thread&#8221;.  The significance of
this flag is that the entire Python program exits when only daemon
threads are left.  The initial value is inherited from the creating
thread.  The flag can be set through the <tt class="docutils literal"><span class="pre">daemon</span></tt> property.</p>
<p>There is a &#8220;main thread&#8221; object; this corresponds to the initial
thread of control in the Python program.  It is not a daemon thread.</p>
<p>There is the possibility that &#8220;dummy thread objects&#8221; are created.
These are thread objects corresponding to &#8220;alien threads&#8221;, which are
threads of control started outside the threading module, such as
directly from C code.  Dummy thread objects have limited
functionality; they are always considered alive and daemonic, and
cannot be <a href="#id1"><span class="problematic" id="id2">``</span></a>join()``ed.  They are never deleted, since it is
impossible to detect the termination of alien threads.</p>
<p>class class threading.Thread(group=None, target=None, name=None, args=(), kwargs={})</p>
<blockquote>
<p>This constructor should always be called with keyword arguments.
Arguments are:</p>
<p><em>group</em> should be <tt class="xref docutils literal"><span class="pre">None</span></tt>; reserved for future extension when a
<tt class="docutils literal"><span class="pre">ThreadGroup</span></tt> class is implemented.</p>
<p><em>target</em> is the callable object to be invoked by the <tt class="docutils literal"><span class="pre">run()</span></tt>
method. Defaults to <tt class="xref docutils literal"><span class="pre">None</span></tt>, meaning nothing is called.</p>
<p><em>name</em> is the thread name.  By default, a unique name is
constructed of the form &#8220;Thread-<em>N</em>&#8221; where <em>N</em> is a small decimal
number.</p>
<p><em>args</em> is the argument tuple for the target invocation.  Defaults
to <tt class="docutils literal"><span class="pre">()</span></tt>.</p>
<p><em>kwargs</em> is a dictionary of keyword arguments for the target
invocation. Defaults to <tt class="docutils literal"><span class="pre">{}</span></tt>.</p>
<p>If the subclass overrides the constructor, it must make sure to
invoke the base class constructor (<tt class="docutils literal"><span class="pre">Thread.__init__()</span></tt>) before
doing anything else to the thread.</p>
</blockquote>
<p>Thread.start()</p>
<blockquote>
<p>Start the thread&#8217;s activity.</p>
<p>It must be called at most once per thread object.  It arranges for
the object&#8217;s <tt class="docutils literal"><span class="pre">run()</span></tt> method to be invoked in a separate thread of
control.</p>
<p>This method will raise a <tt class="docutils literal"><span class="pre">RuntimeException</span></tt> if called more than
once on the same thread object.</p>
</blockquote>
<p>Thread.run()</p>
<blockquote>
<p>Method representing the thread&#8217;s activity.</p>
<p>You may override this method in a subclass.  The standard <tt class="docutils literal"><span class="pre">run()</span></tt>
method invokes the callable object passed to the object&#8217;s
constructor as the <em>target</em> argument, if any, with sequential and
keyword arguments taken from the <em>args</em> and <em>kwargs</em> arguments,
respectively.</p>
</blockquote>
<p>Thread.join([timeout])</p>
<blockquote>
<p>Wait until the thread terminates. This blocks the calling thread
until the thread whose <tt class="docutils literal"><span class="pre">join()</span></tt> method is called terminates &#8211;
either normally or through an unhandled exception &#8211; or until the
optional timeout occurs.</p>
<p>When the <em>timeout</em> argument is present and not <tt class="xref docutils literal"><span class="pre">None</span></tt>, it should
be a floating point number specifying a timeout for the operation
in seconds (or fractions thereof). As <tt class="docutils literal"><span class="pre">join()</span></tt> always returns
<tt class="xref docutils literal"><span class="pre">None</span></tt>, you must call <tt class="docutils literal"><span class="pre">isAlive()</span></tt> after <tt class="docutils literal"><span class="pre">join()</span></tt> to decide
whether a timeout happened &#8211; if the thread is still alive, the
<tt class="docutils literal"><span class="pre">join()</span></tt> call timed out.</p>
<p>When the <em>timeout</em> argument is not present or <tt class="xref docutils literal"><span class="pre">None</span></tt>, the
operation will block until the thread terminates.</p>
<p>A thread can be <a href="#id3"><span class="problematic" id="id4">``</span></a>join()``ed many times.</p>
<p><tt class="docutils literal"><span class="pre">join()</span></tt> raises a <tt class="docutils literal"><span class="pre">RuntimeError</span></tt> if an attempt is made to join
the current thread as that would cause a deadlock. It is also an
error to <tt class="docutils literal"><span class="pre">join()</span></tt> a thread before it has been started and
attempts to do so raises the same exception.</p>
</blockquote>
<p>Thread.getName()
Thread.setName()</p>
<blockquote>
Old API for <tt class="docutils literal"><span class="pre">name</span></tt>.</blockquote>
<p>Thread.name</p>
<blockquote>
A string used for identification purposes only. It has no
semantics. Multiple threads may be given the same name.  The
initial name is set by the constructor.</blockquote>
<p>Thread.ident</p>
<blockquote>
<p>The &#8216;thread identifier&#8217; of this thread or <tt class="xref docutils literal"><span class="pre">None</span></tt> if the thread
has not been started.  This is a nonzero integer.  See the
<tt class="docutils literal"><span class="pre">thread.get_ident()</span></tt> function.  Thread identifiers may be
recycled when a thread exits and another thread is created.  The
identifier is available even after the thread has exited.</p>
<p>New in version 2.6.</p>
</blockquote>
<p>Thread.is_alive()
Thread.isAlive()</p>
<blockquote>
<p>Return whether the thread is alive.</p>
<p>Roughly, a thread is alive from the moment the <tt class="docutils literal"><span class="pre">start()</span></tt> method
returns until its <tt class="docutils literal"><span class="pre">run()</span></tt> method terminates. The module function
<tt class="docutils literal"><span class="pre">enumerate()</span></tt> returns a list of all alive threads.</p>
</blockquote>
<p>Thread.isDaemon()
Thread.setDaemon()</p>
<blockquote>
Old API for <tt class="docutils literal"><span class="pre">daemon</span></tt>.</blockquote>
<p>Thread.daemon</p>
<blockquote>
<p>A boolean value indicating whether this thread is a daemon thread
(True) or not (False).  This must be set before <tt class="docutils literal"><span class="pre">start()</span></tt> is
called, otherwise <tt class="docutils literal"><span class="pre">RuntimeError</span></tt> is raised.  Its initial value is
inherited from the creating thread; the main thread is not a daemon
thread and therefore all threads created in the main thread default
to <tt class="docutils literal"><span class="pre">daemon</span></tt> = <tt class="xref docutils literal"><span class="pre">False</span></tt>.</p>
<p>The entire Python program exits when no alive non-daemon threads
are left.</p>
</blockquote>
</div>
<div class="section" id="lock-objects">
<h2>16.2.2. Lock Objects<a class="headerlink" href="#lock-objects" title="Permalink to this headline">¶</a></h2>
<p>A primitive lock is a synchronization primitive that is not owned by a
particular thread when locked.  In Python, it is currently the lowest
level synchronization primitive available, implemented directly by the
<tt class="docutils literal"><span class="pre">thread</span></tt> extension module.</p>
<p>A primitive lock is in one of two states, &#8220;locked&#8221; or &#8220;unlocked&#8221;. It
is created in the unlocked state.  It has two basic methods,
<tt class="docutils literal"><span class="pre">acquire()</span></tt> and <tt class="docutils literal"><span class="pre">release()</span></tt>.  When the state is unlocked,
<tt class="docutils literal"><span class="pre">acquire()</span></tt> changes the state to locked and returns immediately.
When the state is locked, <tt class="docutils literal"><span class="pre">acquire()</span></tt> blocks until a call to
<tt class="docutils literal"><span class="pre">release()</span></tt> in another thread changes it to unlocked, then the
<tt class="docutils literal"><span class="pre">acquire()</span></tt> call resets it to locked and returns.  The <tt class="docutils literal"><span class="pre">release()</span></tt>
method should only be called in the locked state; it changes the state
to unlocked and returns immediately. If an attempt is made to release
an unlocked lock, a <tt class="docutils literal"><span class="pre">RuntimeError</span></tt> will be raised.</p>
<p>When more than one thread is blocked in <tt class="docutils literal"><span class="pre">acquire()</span></tt> waiting for the
state to turn to unlocked, only one thread proceeds when a
<tt class="docutils literal"><span class="pre">release()</span></tt> call resets the state to unlocked; which one of the
waiting threads proceeds is not defined, and may vary across
implementations.</p>
<p>All methods are executed atomically.</p>
<p>Lock.acquire([blocking=1])</p>
<blockquote>
<p>Acquire a lock, blocking or non-blocking.</p>
<p>When invoked without arguments, block until the lock is unlocked,
then set it to locked, and return true.</p>
<p>When invoked with the <em>blocking</em> argument set to true, do the same
thing as when called without arguments, and return true.</p>
<p>When invoked with the <em>blocking</em> argument set to false, do not
block.  If a call without an argument would block, return false
immediately; otherwise, do the same thing as when called without
arguments, and return true.</p>
</blockquote>
<p>Lock.release()</p>
<blockquote>
<p>Release a lock.</p>
<p>When the lock is locked, reset it to unlocked, and return.  If any
other threads are blocked waiting for the lock to become unlocked,
allow exactly one of them to proceed.</p>
<p>Do not call this method when the lock is unlocked.</p>
<p>There is no return value.</p>
</blockquote>
</div>
<div class="section" id="rlock-objects">
<h2>16.2.3. RLock Objects<a class="headerlink" href="#rlock-objects" title="Permalink to this headline">¶</a></h2>
<p>A reentrant lock is a synchronization primitive that may be acquired
multiple times by the same thread.  Internally, it uses the concepts
of &#8220;owning thread&#8221; and &#8220;recursion level&#8221; in addition to the
locked/unlocked state used by primitive locks.  In the locked state,
some thread owns the lock; in the unlocked state, no thread owns it.</p>
<p>To lock the lock, a thread calls its <tt class="docutils literal"><span class="pre">acquire()</span></tt> method; this
returns once the thread owns the lock.  To unlock the lock, a thread
calls its <tt class="docutils literal"><span class="pre">release()</span></tt> method. <tt class="docutils literal"><span class="pre">acquire()</span></tt>/<tt class="docutils literal"><span class="pre">release()</span></tt> call pairs
may be nested; only the final <tt class="docutils literal"><span class="pre">release()</span></tt> (the <tt class="docutils literal"><span class="pre">release()</span></tt> of the
outermost pair) resets the lock to unlocked and allows another thread
blocked in <tt class="docutils literal"><span class="pre">acquire()</span></tt> to proceed.</p>
<p>RLock.acquire([blocking=1])</p>
<blockquote>
<p>Acquire a lock, blocking or non-blocking.</p>
<p>When invoked without arguments: if this thread already owns the
lock, increment the recursion level by one, and return immediately.
Otherwise, if another thread owns the lock, block until the lock is
unlocked.  Once the lock is unlocked (not owned by any thread),
then grab ownership, set the recursion level to one, and return.
If more than one thread is blocked waiting until the lock is
unlocked, only one at a time will be able to grab ownership of the
lock. There is no return value in this case.</p>
<p>When invoked with the <em>blocking</em> argument set to true, do the same
thing as when called without arguments, and return true.</p>
<p>When invoked with the <em>blocking</em> argument set to false, do not
block.  If a call without an argument would block, return false
immediately; otherwise, do the same thing as when called without
arguments, and return true.</p>
</blockquote>
<p>RLock.release()</p>
<blockquote>
<p>Release a lock, decrementing the recursion level.  If after the
decrement it is zero, reset the lock to unlocked (not owned by any
thread), and if any other threads are blocked waiting for the lock
to become unlocked, allow exactly one of them to proceed.  If after
the decrement the recursion level is still nonzero, the lock
remains locked and owned by the calling thread.</p>
<p>Only call this method when the calling thread owns the lock. A
<tt class="docutils literal"><span class="pre">RuntimeError</span></tt> is raised if this method is called when the lock
is unlocked.</p>
<p>There is no return value.</p>
</blockquote>
</div>
<div class="section" id="condition-objects">
<h2>16.2.4. Condition Objects<a class="headerlink" href="#condition-objects" title="Permalink to this headline">¶</a></h2>
<p>A condition variable is always associated with some kind of lock; this
can be passed in or one will be created by default.  (Passing one in
is useful when several condition variables must share the same lock.)</p>
<p>A condition variable has <tt class="docutils literal"><span class="pre">acquire()</span></tt> and <tt class="docutils literal"><span class="pre">release()</span></tt> methods that
call the corresponding methods of the associated lock. It also has a
<tt class="docutils literal"><span class="pre">wait()</span></tt> method, and <tt class="docutils literal"><span class="pre">notify()</span></tt> and <tt class="docutils literal"><span class="pre">notifyAll()</span></tt> methods.
These three must only be called when the calling thread has acquired
the lock, otherwise a <tt class="docutils literal"><span class="pre">RuntimeError</span></tt> is raised.</p>
<p>The <tt class="docutils literal"><span class="pre">wait()</span></tt> method releases the lock, and then blocks until it is
awakened by a <tt class="docutils literal"><span class="pre">notify()</span></tt> or <tt class="docutils literal"><span class="pre">notifyAll()</span></tt> call for the same
condition variable in another thread.  Once awakened, it re-acquires
the lock and returns.  It is also possible to specify a timeout.</p>
<p>The <tt class="docutils literal"><span class="pre">notify()</span></tt> method wakes up one of the threads waiting for the
condition variable, if any are waiting.  The <tt class="docutils literal"><span class="pre">notifyAll()</span></tt> method
wakes up all threads waiting for the condition variable.</p>
<p>Note: the <tt class="docutils literal"><span class="pre">notify()</span></tt> and <tt class="docutils literal"><span class="pre">notifyAll()</span></tt> methods don&#8217;t release the
lock; this means that the thread or threads awakened will not return
from their <tt class="docutils literal"><span class="pre">wait()</span></tt> call immediately, but only when the thread that
called <tt class="docutils literal"><span class="pre">notify()</span></tt> or <tt class="docutils literal"><span class="pre">notifyAll()</span></tt> finally relinquishes ownership
of the lock.</p>
<p>Tip: the typical programming style using condition variables uses the
lock to synchronize access to some shared state; threads that are
interested in a particular change of state call <tt class="docutils literal"><span class="pre">wait()</span></tt> repeatedly
until they see the desired state, while threads that modify the state
call <tt class="docutils literal"><span class="pre">notify()</span></tt> or <tt class="docutils literal"><span class="pre">notifyAll()</span></tt> when they change the state in
such a way that it could possibly be a desired state for one of the
waiters.  For example, the following code is a generic producer-
consumer situation with unlimited buffer capacity:</p>
<blockquote>
<p># Consume one item
cv.acquire()
while not an_item_is_available():</p>
<blockquote>
cv.wait()</blockquote>
<p>get_an_available_item()
cv.release()</p>
<p># Produce one item
cv.acquire()
make_an_item_available()
cv.notify()
cv.release()</p>
</blockquote>
<p>To choose between <tt class="docutils literal"><span class="pre">notify()</span></tt> and <tt class="docutils literal"><span class="pre">notifyAll()</span></tt>, consider whether
one state change can be interesting for only one or several waiting
threads.  E.g. in a typical producer-consumer situation, adding one
item to the buffer only needs to wake up one consumer thread.</p>
<p>class class threading.Condition([lock])</p>
<blockquote>
If the <em>lock</em> argument is given and not <tt class="xref docutils literal"><span class="pre">None</span></tt>, it must be a
<tt class="docutils literal"><span class="pre">Lock</span></tt> or <tt class="docutils literal"><span class="pre">RLock</span></tt> object, and it is used as the underlying
lock.  Otherwise, a new <tt class="docutils literal"><span class="pre">RLock</span></tt> object is created and used as the
underlying lock.</blockquote>
<p>Condition.acquire(<a href="#id5"><span class="problematic" id="id6">*</span></a>args)</p>
<blockquote>
Acquire the underlying lock. This method calls the corresponding
method on the underlying lock; the return value is whatever that
method returns.</blockquote>
<p>Condition.release()</p>
<blockquote>
Release the underlying lock. This method calls the corresponding
method on the underlying lock; there is no return value.</blockquote>
<p>Condition.wait([timeout])</p>
<blockquote>
<p>Wait until notified or until a timeout occurs. If the calling
thread has not acquired the lock when this method is called, a
<tt class="docutils literal"><span class="pre">RuntimeError</span></tt> is raised.</p>
<p>This method releases the underlying lock, and then blocks until it
is awakened by a <tt class="docutils literal"><span class="pre">notify()</span></tt> or <tt class="docutils literal"><span class="pre">notifyAll()</span></tt> call for the same
condition variable in another thread, or until the optional timeout
occurs.  Once awakened or timed out, it re-acquires the lock and
returns.</p>
<p>When the <em>timeout</em> argument is present and not <tt class="xref docutils literal"><span class="pre">None</span></tt>, it should
be a floating point number specifying a timeout for the operation
in seconds (or fractions thereof).</p>
<p>When the underlying lock is an <tt class="docutils literal"><span class="pre">RLock</span></tt>, it is not released using
its <tt class="docutils literal"><span class="pre">release()</span></tt> method, since this may not actually unlock the
lock when it was acquired multiple times recursively.  Instead, an
internal interface of the <tt class="docutils literal"><span class="pre">RLock</span></tt> class is used, which really
unlocks it even when it has been recursively acquired several
times. Another internal interface is then used to restore the
recursion level when the lock is reacquired.</p>
</blockquote>
<p>Condition.notify()</p>
<blockquote>
<p>Wake up a thread waiting on this condition, if any.  If the calling
thread has not acquired the lock when this method is called, a
<tt class="docutils literal"><span class="pre">RuntimeError</span></tt> is raised.</p>
<p>This method wakes up one of the threads waiting for the condition
variable, if any are waiting; it is a no-op if no threads are
waiting.</p>
<p>The current implementation wakes up exactly one thread, if any are
waiting. However, it&#8217;s not safe to rely on this behavior.  A
future, optimized implementation may occasionally wake up more than
one thread.</p>
<p>Note: the awakened thread does not actually return from its
<tt class="docutils literal"><span class="pre">wait()</span></tt> call until it can reacquire the lock.  Since
<tt class="docutils literal"><span class="pre">notify()</span></tt> does not release the lock, its caller should.</p>
</blockquote>
<p>Condition.notify_all()
Condition.notifyAll()</p>
<blockquote>
Wake up all threads waiting on this condition.  This method acts
like <tt class="docutils literal"><span class="pre">notify()</span></tt>, but wakes up all waiting threads instead of one.
If the calling thread has not acquired the lock when this method is
called, a <tt class="docutils literal"><span class="pre">RuntimeError</span></tt> is raised.</blockquote>
</div>
<div class="section" id="semaphore-objects">
<h2>16.2.5. Semaphore Objects<a class="headerlink" href="#semaphore-objects" title="Permalink to this headline">¶</a></h2>
<p>This is one of the oldest synchronization primitives in the history of
computer science, invented by the early Dutch computer scientist
Edsger W. Dijkstra (he used <tt class="docutils literal"><span class="pre">P()</span></tt> and <tt class="docutils literal"><span class="pre">V()</span></tt> instead of
<tt class="docutils literal"><span class="pre">acquire()</span></tt> and <tt class="docutils literal"><span class="pre">release()</span></tt>).</p>
<p>A semaphore manages an internal counter which is decremented by each
<tt class="docutils literal"><span class="pre">acquire()</span></tt> call and incremented by each <tt class="docutils literal"><span class="pre">release()</span></tt> call.  The
counter can never go below zero; when <tt class="docutils literal"><span class="pre">acquire()</span></tt> finds that it is
zero, it blocks, waiting until some other thread calls <tt class="docutils literal"><span class="pre">release()</span></tt>.</p>
<p>class class threading.Semaphore([value])</p>
<blockquote>
The optional argument gives the initial <em>value</em> for the internal
counter; it defaults to <tt class="docutils literal"><span class="pre">1</span></tt>. If the <em>value</em> given is less than 0,
<tt class="docutils literal"><span class="pre">ValueError</span></tt> is raised.</blockquote>
<p>Semaphore.acquire([blocking])</p>
<blockquote>
<p>Acquire a semaphore.</p>
<p>When invoked without arguments: if the internal counter is larger
than zero on entry, decrement it by one and return immediately.  If
it is zero on entry, block, waiting until some other thread has
called <tt class="docutils literal"><span class="pre">release()</span></tt> to make it larger than zero.  This is done
with proper interlocking so that if multiple <tt class="docutils literal"><span class="pre">acquire()</span></tt> calls
are blocked, <tt class="docutils literal"><span class="pre">release()</span></tt> will wake exactly one of them up.  The
implementation may pick one at random, so the order in which
blocked threads are awakened should not be relied on.  There is no
return value in this case.</p>
<p>When invoked with <em>blocking</em> set to true, do the same thing as when
called without arguments, and return true.</p>
<p>When invoked with <em>blocking</em> set to false, do not block.  If a call
without an argument would block, return false immediately;
otherwise, do the same thing as when called without arguments, and
return true.</p>
</blockquote>
<p>Semaphore.release()</p>
<blockquote>
Release a semaphore, incrementing the internal counter by one.
When it was zero on entry and another thread is waiting for it to
become larger than zero again, wake up that thread.</blockquote>
<div class="section" id="semaphore-example">
<h3>16.2.5.1. <tt class="docutils literal"><span class="pre">Semaphore</span></tt> Example<a class="headerlink" href="#semaphore-example" title="Permalink to this headline">¶</a></h3>
<p>Semaphores are often used to guard resources with limited capacity,
for example, a database server.  In any situation where the size of
the resource size is fixed, you should use a bounded semaphore.
Before spawning any worker threads, your main thread would initialize
the semaphore:</p>
<blockquote>
maxconnections = 5
...
pool_sema = BoundedSemaphore(value=maxconnections)</blockquote>
<p>Once spawned, worker threads call the semaphore&#8217;s acquire and release
methods when they need to connect to the server:</p>
<blockquote>
pool_sema.acquire()
conn = connectdb()
... use connection ...
conn.close()
pool_sema.release()</blockquote>
<p>The use of a bounded semaphore reduces the chance that a programming
error which causes the semaphore to be released more than it&#8217;s
acquired will go undetected.</p>
</div>
</div>
<div class="section" id="event-objects">
<h2>16.2.6. Event Objects<a class="headerlink" href="#event-objects" title="Permalink to this headline">¶</a></h2>
<p>This is one of the simplest mechanisms for communication between
threads: one thread signals an event and other threads wait for it.</p>
<p>An event object manages an internal flag that can be set to true with
the <tt class="docutils literal"><span class="pre">set()</span></tt> method and reset to false with the <tt class="docutils literal"><span class="pre">clear()</span></tt> method.
The <tt class="docutils literal"><span class="pre">wait()</span></tt> method blocks until the flag is true.</p>
<p>class class threading.Event</p>
<blockquote>
The internal flag is initially false.</blockquote>
<p>Event.is_set()
Event.isSet()</p>
<blockquote>
Return true if and only if the internal flag is true.</blockquote>
<p>Event.set()</p>
<blockquote>
Set the internal flag to true. All threads waiting for it to become
true are awakened. Threads that call <tt class="docutils literal"><span class="pre">wait()</span></tt> once the flag is
true will not block at all.</blockquote>
<p>Event.clear()</p>
<blockquote>
Reset the internal flag to false. Subsequently, threads calling
<tt class="docutils literal"><span class="pre">wait()</span></tt> will block until <tt class="docutils literal"><span class="pre">set()</span></tt> is called to set the internal
flag to true again.</blockquote>
<p>Event.wait([timeout])</p>
<blockquote>
<p>Block until the internal flag is true. If the internal flag is true
on entry, return immediately.  Otherwise, block until another
thread calls <tt class="docutils literal"><span class="pre">set()</span></tt> to set the flag to true, or until the
optional timeout occurs.</p>
<p>When the timeout argument is present and not <tt class="xref docutils literal"><span class="pre">None</span></tt>, it should be
a floating point number specifying a timeout for the operation in
seconds (or fractions thereof).</p>
</blockquote>
</div>
<div class="section" id="timer-objects">
<h2>16.2.7. Timer Objects<a class="headerlink" href="#timer-objects" title="Permalink to this headline">¶</a></h2>
<p>This class represents an action that should be run only after a
certain amount of time has passed &#8212; a timer.  <tt class="docutils literal"><span class="pre">Timer</span></tt> is a
subclass of <tt class="docutils literal"><span class="pre">Thread</span></tt> and as such also functions as an example of
creating custom threads.</p>
<p>Timers are started, as with threads, by calling their <tt class="docutils literal"><span class="pre">start()</span></tt>
method.  The timer can be stopped (before its action has begun) by
calling the <tt class="docutils literal"><span class="pre">cancel()</span></tt> method.  The interval the timer will wait
before executing its action may not be exactly the same as the
interval specified by the user.</p>
<p>For example:</p>
<blockquote>
<dl class="docutils">
<dt>def hello():</dt>
<dd>print &#8220;hello, world&#8221;</dd>
</dl>
<p>t = Timer(30.0, hello)
t.start() # after 30 seconds, &#8220;hello, world&#8221; will be printed</p>
</blockquote>
<p>class class threading.Timer(interval, function, args=[], kwargs={})</p>
<blockquote>
Create a timer that will run <em>function</em> with arguments <em>args</em> and
keyword arguments <em>kwargs</em>, after <em>interval</em> seconds have passed.</blockquote>
<p>Timer.cancel()</p>
<blockquote>
Stop the timer, and cancel the execution of the timer&#8217;s action.
This will only work if the timer is still in its waiting stage.</blockquote>
</div>
<div class="section" id="using-locks-conditions-and-semaphores-in-the-with-statement">
<h2>16.2.8. Using locks, conditions, and semaphores in the <tt class="docutils literal"><span class="pre">with</span></tt> statement<a class="headerlink" href="#using-locks-conditions-and-semaphores-in-the-with-statement" title="Permalink to this headline">¶</a></h2>
<p>All of the objects provided by this module that have <tt class="docutils literal"><span class="pre">acquire()</span></tt> and
<tt class="docutils literal"><span class="pre">release()</span></tt> methods can be used as context managers for a <tt class="docutils literal"><span class="pre">with</span></tt>
statement.  The <tt class="docutils literal"><span class="pre">acquire()</span></tt> method will be called when the block is
entered, and <tt class="docutils literal"><span class="pre">release()</span></tt> will be called when the block is exited.</p>
<p>Currently, <tt class="docutils literal"><span class="pre">Lock</span></tt>, <tt class="docutils literal"><span class="pre">RLock</span></tt>, <tt class="docutils literal"><span class="pre">Condition</span></tt>, <tt class="docutils literal"><span class="pre">Semaphore</span></tt>, and
<tt class="docutils literal"><span class="pre">BoundedSemaphore</span></tt> objects may be used as <tt class="docutils literal"><span class="pre">with</span></tt> statement context
managers.  For example:</p>
<blockquote>
<p>import threading</p>
<p>some_rlock = threading.RLock()</p>
<dl class="docutils">
<dt>with some_rlock:</dt>
<dd>print &#8220;some_rlock is locked while this executes&#8221;</dd>
</dl>
</blockquote>
</div>
<div class="section" id="importing-in-threaded-code">
<h2>16.2.9. Importing in threaded code<a class="headerlink" href="#importing-in-threaded-code" title="Permalink to this headline">¶</a></h2>
<p>While the import machinery is thread safe, there are two key
restrictions on threaded imports due to inherent limitations in the
way that thread safety is provided:</p>
<ul class="simple">
<li>Firstly, other than in the main module, an import should not have
the side effect of spawning a new thread and then waiting for that
thread in any way. Failing to abide by this restriction can lead to
a deadlock if the spawned thread directly or indirectly attempts to
import a module.</li>
<li>Secondly, all import attempts must be completed before the
interpreter starts shutting itself down. This can be most easily
achieved by only performing imports from non-daemon threads created
through the threading module. Daemon threads and threads created
directly with the thread module will require some other form of
synchronization to ensure they do not attempt imports after system
shutdown has commenced. Failure to abide by this restriction will
lead to intermittent exceptions and crashes during interpreter
shutdown (as the late imports attempt to access machinery which is
no longer in a valid state).</li>
</ul>
</div>
</div>


          </div>
        </div>
      </div>


      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../modindex.html" title="Global Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="thread.html" title="16.3. thread — Multiple threads of control"
             >next</a> |</li>
        <li class="right" >
          <a href="select.html" title="16.1. select — Waiting for I/O completion"
             >previous</a> |</li>
        <li><a href="../index.html">Jython v2.5.2 documentation</a> &raquo;</li>
          <li><a href="indexprogress.html" >The Python Standard Library and What Comes with Jython</a> &raquo;</li>
          <li><a href="someos.html" >16. Optional Operating System Services</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
      &copy; <a href="../copyright.html">Copyright</a> 2011, Jython Project.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 0.6.4.
    </div>
  </body>
</html>