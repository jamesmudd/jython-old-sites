<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>2. Built-in Functions &mdash; Jython v2.5.2 documentation</title>
    <link rel="stylesheet" href="../_static/green-theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.5.2',
        COLLAPSE_MODINDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Jython v2.5.2 documentation" href="../index.html" />
    <link rel="up" title="The Python Standard Library and What Comes with Jython" href="indexprogress.html" />
    <link rel="next" title="3. Built-in Constants" href="constants.html" />
    <link rel="prev" title="1. Introduction" href="intro.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../modindex.html" title="Global Module Index"
             accesskey="M">modules</a> |</li>
        <li class="right" >
          <a href="constants.html" title="3. Built-in Constants"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="intro.html" title="1. Introduction"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Jython v2.5.2 documentation</a> &raquo;</li>
          <li><a href="indexprogress.html" accesskey="U">The Python Standard Library and What Comes with Jython</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/jython.png" alt="Logo"/>
            </a></p>
            <h3><a href="../index.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference external" href="#">2. Built-in Functions</a><ul>
<li><a class="reference external" href="#non-essential-built-in-functions">2.1. Non-essential Built-in Functions</a></li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="intro.html"
                                  title="previous chapter">1. Introduction</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="constants.html"
                                  title="next chapter">3. Built-in Constants</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../_sources/library/functions.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="../search.html" method="get">
                <input type="text" name="q" size="18" />
                <input type="submit" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="built-in-functions">
<h1>2. Built-in Functions<a class="headerlink" href="#built-in-functions" title="Permalink to this headline">Â¶</a></h1>
<p>The Python interpreter has a number of functions built into it that
are always available.  They are listed here in alphabetical order.</p>
<p>abs(x)</p>
<blockquote>
Return the absolute value of a number.  The argument may be a plain
or long integer or a floating point number.  If the argument is a
complex number, its magnitude is returned.</blockquote>
<p>all(iterable)</p>
<blockquote>
<p>Return True if all elements of the <em>iterable</em> are true (or if the
iterable is empty).  Equivalent to:</p>
<blockquote>
<dl class="docutils">
<dt>def all(iterable):</dt>
<dd><dl class="first docutils">
<dt>for element in iterable:</dt>
<dd><dl class="first last docutils">
<dt>if not element:</dt>
<dd>return False</dd>
</dl>
</dd>
</dl>
<p class="last">return True</p>
</dd>
</dl>
</blockquote>
<p>New in version 2.5.</p>
</blockquote>
<p>any(iterable)</p>
<blockquote>
<p>Return True if any element of the <em>iterable</em> is true.  If the
iterable is empty, return False.  Equivalent to:</p>
<blockquote>
<dl class="docutils">
<dt>def any(iterable):</dt>
<dd><dl class="first docutils">
<dt>for element in iterable:</dt>
<dd><dl class="first last docutils">
<dt>if element:</dt>
<dd>return True</dd>
</dl>
</dd>
</dl>
<p class="last">return False</p>
</dd>
</dl>
</blockquote>
<p>New in version 2.5.</p>
</blockquote>
<p>basestring()</p>
<blockquote>
<p>This abstract type is the superclass for <tt class="docutils literal"><span class="pre">str</span></tt> and <tt class="docutils literal"><span class="pre">unicode</span></tt>.
It cannot be called or instantiated, but it can be used to test
whether an object is an instance of <tt class="docutils literal"><span class="pre">str</span></tt> or <tt class="docutils literal"><span class="pre">unicode</span></tt>.
<tt class="docutils literal"><span class="pre">isinstance(obj,</span> <span class="pre">basestring)</span></tt> is equivalent to <tt class="docutils literal"><span class="pre">isinstance(obj,</span>
<span class="pre">(str,</span> <span class="pre">unicode))</span></tt>.</p>
<p>New in version 2.3.</p>
</blockquote>
<p>bin(x)</p>
<blockquote>
<p>Convert an integer number to a binary string. The result is a valid
Python expression.  If <em>x</em> is not a Python <tt class="docutils literal"><span class="pre">int</span></tt> object, it has
to define an <tt class="docutils literal"><span class="pre">__index__()</span></tt> method that returns an integer.</p>
<p>New in version 2.6.</p>
</blockquote>
<p>bool([x])</p>
<blockquote>
<p>Convert a value to a Boolean, using the standard truth testing
procedure.  If <em>x</em> is false or omitted, this returns <tt class="xref docutils literal"><span class="pre">False</span></tt>;
otherwise it returns <tt class="xref docutils literal"><span class="pre">True</span></tt>. <tt class="docutils literal"><span class="pre">bool</span></tt> is also a class, which is a
subclass of <tt class="docutils literal"><span class="pre">int</span></tt>. Class <tt class="docutils literal"><span class="pre">bool</span></tt> cannot be subclassed further.
Its only instances are <tt class="xref docutils literal"><span class="pre">False</span></tt> and <tt class="xref docutils literal"><span class="pre">True</span></tt>.</p>
<p>New in version 2.2.1.</p>
<p>Changed in version 2.3: If no argument is given, this function
returns <tt class="xref docutils literal"><span class="pre">False</span></tt>.</p>
</blockquote>
<p>callable(object)</p>
<blockquote>
Return <tt class="xref docutils literal"><span class="pre">True</span></tt> if the <em>object</em> argument appears callable,
<tt class="xref docutils literal"><span class="pre">False</span></tt> if not.  If this returns true, it is still possible that
a call fails, but if it is false, calling <em>object</em> will never
succeed.  Note that classes are callable (calling a class returns a
new instance); class instances are callable if they have a
<tt class="docutils literal"><span class="pre">__call__()</span></tt> method.</blockquote>
<p>chr(i)</p>
<blockquote>
Return a string of one character whose ASCII code is the integer
<em>i</em>.  For example, <tt class="docutils literal"><span class="pre">chr(97)</span></tt> returns the string <tt class="docutils literal"><span class="pre">'a'</span></tt>. This is
the inverse of <tt class="docutils literal"><span class="pre">ord()</span></tt>.  The argument must be in the range
[0..255], inclusive; <tt class="docutils literal"><span class="pre">ValueError</span></tt> will be raised if <em>i</em> is
outside that range. See also <tt class="docutils literal"><span class="pre">unichr()</span></tt>.</blockquote>
<p>classmethod(function)</p>
<blockquote>
<p>Return a class method for <em>function</em>.</p>
<p>A class method receives the class as implicit first argument, just
like an instance method receives the instance. To declare a class
method, use this idiom:</p>
<blockquote>
<dl class="docutils">
<dt>class C:</dt>
<dd>&#64;classmethod
def f(cls, arg1, arg2, ...): ...</dd>
</dl>
</blockquote>
<p>The <tt class="docutils literal"><span class="pre">&#64;classmethod</span></tt> form is a function <em>decorator</em> &#8211; see the
description of function definitions in <em>Function definitions</em> for
details.</p>
<p>It can be called either on the class (such as <tt class="docutils literal"><span class="pre">C.f()</span></tt>) or on an
instance (such as <tt class="docutils literal"><span class="pre">C().f()</span></tt>).  The instance is ignored except for
its class. If a class method is called for a derived class, the
derived class object is passed as the implied first argument.</p>
<p>Class methods are different than C++ or Java static methods. If you
want those, see <tt class="docutils literal"><span class="pre">staticmethod()</span></tt> in this section.</p>
<p>For more information on class methods, consult the documentation on
the standard type hierarchy in <em>The standard type hierarchy</em>.</p>
<p>New in version 2.2.</p>
<p>Changed in version 2.4: Function decorator syntax added.</p>
</blockquote>
<p>cmp(x, y)</p>
<blockquote>
Compare the two objects <em>x</em> and <em>y</em> and return an integer according
to the outcome.  The return value is negative if <tt class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></tt>, zero if
<tt class="docutils literal"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></tt> and strictly positive if <tt class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">y</span></tt>.</blockquote>
<p>compile(source, filename, mode[, flags[, dont_inherit]])</p>
<blockquote>
<p>Compile the <em>source</em> into a code or AST object.  Code objects can
be executed by an <tt class="docutils literal"><span class="pre">exec</span></tt> statement or evaluated by a call to
<tt class="docutils literal"><span class="pre">eval()</span></tt>. <em>source</em> can either be a string or an AST object.
Refer to the <tt class="docutils literal"><span class="pre">ast</span></tt> module documentation for information on how to
work with AST objects.</p>
<p>The <em>filename</em> argument should give the file from which the code
was read; pass some recognizable value if it wasn&#8217;t read from a
file (<tt class="docutils literal"><span class="pre">'&lt;string&gt;'</span></tt> is commonly used).</p>
<p>The <em>mode</em> argument specifies what kind of code must be compiled;
it can be <tt class="docutils literal"><span class="pre">'exec'</span></tt> if <em>source</em> consists of a sequence of
statements, <tt class="docutils literal"><span class="pre">'eval'</span></tt> if it consists of a single expression, or
<tt class="docutils literal"><span class="pre">'single'</span></tt> if it consists of a single interactive statement (in
the latter case, expression statements that evaluate to something
other than <tt class="xref docutils literal"><span class="pre">None</span></tt> will be printed).</p>
<p>The optional arguments <em>flags</em> and <em>dont_inherit</em> control which
future statements (see <strong>PEP 236</strong>) affect the compilation of
<em>source</em>.  If neither is present (or both are zero) the code is
compiled with those future statements that are in effect in the
code that is calling compile.  If the <em>flags</em> argument is given and
<em>dont_inherit</em> is not (or is zero) then the future statements
specified by the <em>flags</em> argument are used in addition to those
that would be used anyway. If <em>dont_inherit</em> is a non-zero integer
then the <em>flags</em> argument is it &#8211; the future statements in effect
around the call to compile are ignored.</p>
<p>Future statements are specified by bits which can be bitwise ORed
together to specify multiple statements.  The bitfield required to
specify a given feature can be found as the <tt class="docutils literal"><span class="pre">compiler_flag</span></tt>
attribute on the <tt class="docutils literal"><span class="pre">_Feature</span></tt> instance in the <tt class="docutils literal"><span class="pre">__future__</span></tt>
module.</p>
<p>This function raises <tt class="docutils literal"><span class="pre">SyntaxError</span></tt> if the compiled source is
invalid, and <tt class="docutils literal"><span class="pre">TypeError</span></tt> if the source contains null bytes.</p>
<dl class="docutils">
<dt>Note: When compiling a string with multi-line statements, line endings</dt>
<dd>must be represented by a single newline character (<tt class="docutils literal"><span class="pre">'\n'</span></tt>), and
the input must be terminated by at least one newline character.
If line endings are represented by <tt class="docutils literal"><span class="pre">'\r\n'</span></tt>, use
<tt class="docutils literal"><span class="pre">str.replace()</span></tt> to change them into <tt class="docutils literal"><span class="pre">'\n'</span></tt>.</dd>
</dl>
<p>Changed in version 2.3: The <em>flags</em> and <em>dont_inherit</em> arguments
were added.</p>
<p>Changed in version 2.6: Support for compiling AST objects.</p>
</blockquote>
<p>complex([real[, imag]])</p>
<blockquote>
<p>Create a complex number with the value <em>real</em> + <em>imag**j or convert
a string or number to a complex number.  If the first parameter is
a string, it will be interpreted as a complex number and the
function must be called without a second parameter.  The second
parameter can never be a string. Each argument may be any numeric
type (including complex). If *imag</em> is omitted, it defaults to zero
and the function serves as a numeric conversion function like
<tt class="docutils literal"><span class="pre">int()</span></tt>, <tt class="docutils literal"><span class="pre">long()</span></tt> and <tt class="docutils literal"><span class="pre">float()</span></tt>.  If both arguments are
omitted, returns <tt class="docutils literal"><span class="pre">0j</span></tt>.</p>
<p>The complex type is described in <em>Numeric Types &#8212; int, float,
long, complex</em>.</p>
</blockquote>
<p>delattr(object, name)</p>
<blockquote>
This is a relative of <tt class="docutils literal"><span class="pre">setattr()</span></tt>.  The arguments are an object
and a string.  The string must be the name of one of the object&#8217;s
attributes.  The function deletes the named attribute, provided the
object allows it.  For example, <tt class="docutils literal"><span class="pre">delattr(x,</span> <span class="pre">'foobar')</span></tt> is
equivalent to <tt class="docutils literal"><span class="pre">del</span> <span class="pre">x.foobar</span></tt>.</blockquote>
<p>dict([arg])</p>
<blockquote>
<p>Create a new data dictionary, optionally with items taken from
<em>arg</em>. The dictionary type is described in <em>Mapping Types &#8212;
dict</em>.</p>
<p>For other containers see the built in <tt class="docutils literal"><span class="pre">list</span></tt>, <tt class="docutils literal"><span class="pre">set</span></tt>, and
<tt class="docutils literal"><span class="pre">tuple</span></tt> classes, and the <tt class="docutils literal"><span class="pre">collections</span></tt> module.</p>
</blockquote>
<p>dir([object])</p>
<blockquote>
<p>Without arguments, return the list of names in the current local
scope.  With an argument, attempt to return a list of valid
attributes for that object.</p>
<p>If the object has a method named <tt class="docutils literal"><span class="pre">__dir__()</span></tt>, this method will be
called and must return the list of attributes. This allows objects
that implement a custom <tt class="docutils literal"><span class="pre">__getattr__()</span></tt> or <tt class="docutils literal"><span class="pre">__getattribute__()</span></tt>
function to customize the way <tt class="docutils literal"><span class="pre">dir()</span></tt> reports their attributes.</p>
<p>If the object does not provide <tt class="docutils literal"><span class="pre">__dir__()</span></tt>, the function tries
its best to gather information from the object&#8217;s <tt class="docutils literal"><span class="pre">__dict__</span></tt>
attribute, if defined, and from its type object.  The resulting
list is not necessarily complete, and may be inaccurate when the
object has a custom <tt class="docutils literal"><span class="pre">__getattr__()</span></tt>.</p>
<p>The default <tt class="docutils literal"><span class="pre">dir()</span></tt> mechanism behaves differently with different
types of objects, as it attempts to produce the most relevant,
rather than complete, information:</p>
<ul class="simple">
<li>If the object is a module object, the list contains the names of
the module&#8217;s attributes.</li>
<li>If the object is a type or class object, the list contains the
names of its attributes, and recursively of the attributes of its
bases.</li>
<li>Otherwise, the list contains the object&#8217;s attributes&#8217; names, the
names of its class&#8217;s attributes, and recursively of the
attributes of its class&#8217;s base classes.</li>
</ul>
<p>The resulting list is sorted alphabetically.  For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">struct</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">()</span>   <span class="c"># doctest: +SKIP</span>
<span class="go">[&#39;__builtins__&#39;, &#39;__doc__&#39;, &#39;__name__&#39;, &#39;struct&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">(</span><span class="n">struct</span><span class="p">)</span>   <span class="c"># doctest: +NORMALIZE_WHITESPACE</span>
<span class="go">[&#39;Struct&#39;, &#39;__builtins__&#39;, &#39;__doc__&#39;, &#39;__file__&#39;, &#39;__name__&#39;,</span>
<span class="go"> &#39;__package__&#39;, &#39;_clearcache&#39;, &#39;calcsize&#39;, &#39;error&#39;, &#39;pack&#39;, &#39;pack_into&#39;,</span>
<span class="go"> &#39;unpack&#39;, &#39;unpack_from&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Foo</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__dir__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="p">[</span><span class="s">&quot;kan&quot;</span><span class="p">,</span> <span class="s">&quot;ga&quot;</span><span class="p">,</span> <span class="s">&quot;roo&quot;</span><span class="p">]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="go">[&#39;ga&#39;, &#39;kan&#39;, &#39;roo&#39;]</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Note: Because <tt class="docutils literal"><span class="pre">dir()</span></tt> is supplied primarily as a convenience for use</dt>
<dd>at an interactive prompt, it tries to supply an interesting set
of names more than it tries to supply a rigorously or
consistently defined set of names, and its detailed behavior may
change across releases.  For example, metaclass attributes are
not in the result list when the argument is a class.</dd>
</dl>
</blockquote>
<p>divmod(a, b)</p>
<blockquote>
<p>Take two (non complex) numbers as arguments and return a pair of
numbers consisting of their quotient and remainder when using long
division.  With mixed operand types, the rules for binary
arithmetic operators apply.  For plain and long integers, the
result is the same as <tt class="docutils literal"><span class="pre">(a</span> <span class="pre">//</span> <span class="pre">b,</span> <span class="pre">a</span> <span class="pre">%</span> <span class="pre">b)</span></tt>. For floating point
numbers the result is <tt class="docutils literal"><span class="pre">(q,</span> <span class="pre">a</span> <span class="pre">%</span> <span class="pre">b)</span></tt>, where <em>q</em> is usually
<tt class="docutils literal"><span class="pre">math.floor(a</span> <span class="pre">/</span> <span class="pre">b)</span></tt> but may be 1 less than that.  In any case <tt class="docutils literal"><span class="pre">q</span>
<span class="pre">*</span> <span class="pre">b</span> <span class="pre">+</span> <span class="pre">a</span> <span class="pre">%</span> <span class="pre">b</span></tt> is very close to <em>a</em>, if <tt class="docutils literal"><span class="pre">a</span> <span class="pre">%</span> <span class="pre">b</span></tt> is non-zero it has
the same sign as <em>b</em>, and <tt class="docutils literal"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">abs(a</span> <span class="pre">%</span> <span class="pre">b)</span> <span class="pre">&lt;</span> <span class="pre">abs(b)</span></tt>.</p>
<p>Changed in version 2.3: Using <tt class="docutils literal"><span class="pre">divmod()</span></tt> with complex numbers is
deprecated.</p>
</blockquote>
<p>enumerate(sequence[, start=0])</p>
<blockquote>
<p>Return an enumerate object. <em>sequence</em> must be a sequence, an
<em>iterator</em>, or some other object which supports iteration.  The
<tt class="docutils literal"><span class="pre">next()</span></tt> method of the iterator returned by <tt class="docutils literal"><span class="pre">enumerate()</span></tt>
returns a tuple containing a count (from <em>start</em> which defaults to
0) and the corresponding value obtained from iterating over
<em>iterable</em>. <tt class="docutils literal"><span class="pre">enumerate()</span></tt> is useful for obtaining an indexed
series: <tt class="docutils literal"><span class="pre">(0,</span> <span class="pre">seq[0])</span></tt>, <tt class="docutils literal"><span class="pre">(1,</span> <span class="pre">seq[1])</span></tt>, <tt class="docutils literal"><span class="pre">(2,</span> <span class="pre">seq[2])</span></tt>, .... For
example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">season</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="s">&#39;Spring&#39;</span><span class="p">,</span> <span class="s">&#39;Summer&#39;</span><span class="p">,</span> <span class="s">&#39;Fall&#39;</span><span class="p">,</span> <span class="s">&#39;Winter&#39;</span><span class="p">]):</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">i</span><span class="p">,</span> <span class="n">season</span>
<span class="go">0 Spring</span>
<span class="go">1 Summer</span>
<span class="go">2 Fall</span>
<span class="go">3 Winter</span>
</pre></div>
</div>
<p>New in version 2.3.</p>
<p>New in version 2.6: The <em>start</em> parameter.</p>
</blockquote>
<p>eval(expression[, globals[, locals]])</p>
<blockquote>
<p>The arguments are a string and optional globals and locals.  If
provided, <em>globals</em> must be a dictionary.  If provided, <em>locals</em>
can be any mapping object.</p>
<p>Changed in version 2.4: formerly <em>locals</em> was required to be a
dictionary.</p>
<p>The <em>expression</em> argument is parsed and evaluated as a Python
expression (technically speaking, a condition list) using the
<em>globals</em> and <em>locals</em> dictionaries as global and local namespace.
If the <em>globals</em> dictionary is present and lacks &#8216;__builtins__&#8217;,
the current globals are copied into <em>globals</em> before <em>expression</em>
is parsed.  This means that <em>expression</em> normally has full access
to the standard <tt class="docutils literal"><span class="pre">__builtin__</span></tt> module and restricted environments
are propagated.  If the <em>locals</em> dictionary is omitted it defaults
to the <em>globals</em> dictionary.  If both dictionaries are omitted, the
expression is executed in the environment where <tt class="docutils literal"><span class="pre">eval()</span></tt> is
called.  The return value is the result of the evaluated
expression. Syntax errors are reported as exceptions.  Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="nb">eval</span><span class="p">(</span><span class="s">&#39;x+1&#39;</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p>This function can also be used to execute arbitrary code objects
(such as those created by <tt class="docutils literal"><span class="pre">compile()</span></tt>).  In this case pass a code
object instead of a string.  If the code object has been compiled
with <tt class="docutils literal"><span class="pre">'exec'</span></tt> as the <em>kind</em> argument, <tt class="docutils literal"><span class="pre">eval()</span></tt>&#8216;s return value
will be <tt class="xref docutils literal"><span class="pre">None</span></tt>.</p>
<p>Hints: dynamic execution of statements is supported by the <tt class="docutils literal"><span class="pre">exec</span></tt>
statement.  Execution of statements from a file is supported by the
<tt class="docutils literal"><span class="pre">execfile()</span></tt> function.  The <tt class="docutils literal"><span class="pre">globals()</span></tt> and <tt class="docutils literal"><span class="pre">locals()</span></tt>
functions returns the current global and local dictionary,
respectively, which may be useful to pass around for use by
<tt class="docutils literal"><span class="pre">eval()</span></tt> or <tt class="docutils literal"><span class="pre">execfile()</span></tt>.</p>
</blockquote>
<p>execfile(filename[, globals[, locals]])</p>
<blockquote>
<p>This function is similar to the <tt class="docutils literal"><span class="pre">exec</span></tt> statement, but parses a
file instead of a string.  It is different from the <tt class="docutils literal"><span class="pre">import</span></tt>
statement in that it does not use the module administration &#8212; it
reads the file unconditionally and does not create a new module.
[1]</p>
<p>The arguments are a file name and two optional dictionaries.  The
file is parsed and evaluated as a sequence of Python statements
(similarly to a module) using the <em>globals</em> and <em>locals</em>
dictionaries as global and local namespace. If provided, <em>locals</em>
can be any mapping object.</p>
<p>Changed in version 2.4: formerly <em>locals</em> was required to be a
dictionary.</p>
<p>If the <em>locals</em> dictionary is omitted it defaults to the <em>globals</em>
dictionary. If both dictionaries are omitted, the expression is
executed in the environment where <tt class="docutils literal"><span class="pre">execfile()</span></tt> is called.  The
return value is <tt class="xref docutils literal"><span class="pre">None</span></tt>.</p>
<dl class="docutils">
<dt>Note: The default <em>locals</em> act as described for function <tt class="docutils literal"><span class="pre">locals()</span></tt></dt>
<dd>below: modifications to the default <em>locals</em> dictionary should
not be attempted.  Pass an explicit <em>locals</em> dictionary if you
need to see effects of the code on <em>locals</em> after function
<tt class="docutils literal"><span class="pre">execfile()</span></tt> returns.  <tt class="docutils literal"><span class="pre">execfile()</span></tt> cannot be used reliably
to modify a function&#8217;s locals.</dd>
</dl>
</blockquote>
<p>file(filename[, mode[, bufsize]])</p>
<blockquote>
<p>Constructor function for the <tt class="docutils literal"><span class="pre">file</span></tt> type, described further in
section <em>File Objects</em>.  The constructor&#8217;s arguments are the same
as those of the <tt class="docutils literal"><span class="pre">open()</span></tt> built-in function described below.</p>
<p>When opening a file, it&#8217;s preferable to use <tt class="docutils literal"><span class="pre">open()</span></tt> instead of
invoking this constructor directly.  <tt class="docutils literal"><span class="pre">file</span></tt> is more suited to
type testing (for example, writing <tt class="docutils literal"><span class="pre">isinstance(f,</span> <span class="pre">file)</span></tt>).</p>
<p>New in version 2.2.</p>
</blockquote>
<p>filter(function, iterable)</p>
<blockquote>
<p>Construct a list from those elements of <em>iterable</em> for which
<em>function</em> returns true.  <em>iterable</em> may be either a sequence, a
container which supports iteration, or an iterator.  If <em>iterable</em>
is a string or a tuple, the result also has that type; otherwise it
is always a list.  If <em>function</em> is <tt class="xref docutils literal"><span class="pre">None</span></tt>, the identity function
is assumed, that is, all elements of <em>iterable</em> that are false are
removed.</p>
<p>Note that <tt class="docutils literal"><span class="pre">filter(function,</span> <span class="pre">iterable)</span></tt> is equivalent to <tt class="docutils literal"><span class="pre">[item</span>
<span class="pre">for</span> <span class="pre">item</span> <span class="pre">in</span> <span class="pre">iterable</span> <span class="pre">if</span> <span class="pre">function(item)]</span></tt> if function is not
<tt class="xref docutils literal"><span class="pre">None</span></tt> and <tt class="docutils literal"><span class="pre">[item</span> <span class="pre">for</span> <span class="pre">item</span> <span class="pre">in</span> <span class="pre">iterable</span> <span class="pre">if</span> <span class="pre">item]</span></tt> if function is
<tt class="xref docutils literal"><span class="pre">None</span></tt>.</p>
<p>See <tt class="docutils literal"><span class="pre">itertools.filterfalse()</span></tt> for the complementary function that
returns elements of <em>iterable</em> for which <em>function</em> returns false.</p>
</blockquote>
<p>float([x])</p>
<blockquote>
<p>Convert a string or a number to floating point.  If the argument is
a string, it must contain a possibly signed decimal or floating
point number, possibly embedded in whitespace. The argument may
also be [+|-]nan or [+|-]inf. Otherwise, the argument may be a
plain or long integer or a floating point number, and a floating
point number with the same value (within Python&#8217;s floating point
precision) is returned.  If no argument is given, returns <tt class="docutils literal"><span class="pre">0.0</span></tt>.</p>
<dl class="docutils">
<dt>Note: When passing in a string, values for NaN and Infinity may be</dt>
<dd>returned, depending on the underlying C library.  Float accepts
the strings nan, inf and -inf for NaN and positive or negative
infinity. The case and a leading + are ignored as well as a
leading - is ignored for NaN. Float always represents NaN and
infinity as nan, inf or -inf.</dd>
</dl>
<p>The float type is described in <em>Numeric Types &#8212; int, float, long,
complex</em>.</p>
</blockquote>
<p>format(value[, format_spec])</p>
<blockquote>
<p>Convert a <em>value</em> to a &#8220;formatted&#8221; representation, as controlled by
<em>format_spec</em>.  The interpretation of <em>format_spec</em> will depend on
the type of the <em>value</em> argument, however there is a standard
formatting syntax that is used by most built-in types: <em>Format
Specification Mini-Language</em>.</p>
<dl class="docutils">
<dt>Note: <tt class="docutils literal"><span class="pre">format(value,</span> <span class="pre">format_spec)</span></tt> merely calls</dt>
<dd><tt class="docutils literal"><span class="pre">value.__format__(format_spec)</span></tt>.</dd>
</dl>
<p>New in version 2.6.</p>
</blockquote>
<p>frozenset([iterable])</p>
<blockquote>
<p>Return a frozenset object, optionally with elements taken from
<em>iterable</em>. The frozenset type is described in <em>Set Types &#8212; set,
frozenset</em>.</p>
<p>For other containers see the built in <tt class="docutils literal"><span class="pre">dict</span></tt>, <tt class="docutils literal"><span class="pre">list</span></tt>, and
<tt class="docutils literal"><span class="pre">tuple</span></tt> classes, and the <tt class="docutils literal"><span class="pre">collections</span></tt> module.</p>
<p>New in version 2.4.</p>
</blockquote>
<p>getattr(object, name[, default])</p>
<blockquote>
Return the value of the named attributed of <em>object</em>.  <em>name</em> must
be a string. If the string is the name of one of the object&#8217;s
attributes, the result is the value of that attribute.  For
example, <tt class="docutils literal"><span class="pre">getattr(x,</span> <span class="pre">'foobar')</span></tt> is equivalent to <tt class="docutils literal"><span class="pre">x.foobar</span></tt>.
If the named attribute does not exist, <em>default</em> is returned if
provided, otherwise <tt class="docutils literal"><span class="pre">AttributeError</span></tt> is raised.</blockquote>
<p>globals()</p>
<blockquote>
Return a dictionary representing the current global symbol table.
This is always the dictionary of the current module (inside a
function or method, this is the module where it is defined, not the
module from which it is called).</blockquote>
<p>hasattr(object, name)</p>
<blockquote>
The arguments are an object and a string.  The result is <tt class="xref docutils literal"><span class="pre">True</span></tt>
if the string is the name of one of the object&#8217;s attributes,
<tt class="xref docutils literal"><span class="pre">False</span></tt> if not. (This is implemented by calling <tt class="docutils literal"><span class="pre">getattr(object,</span>
<span class="pre">name)</span></tt> and seeing whether it raises an exception or not.)</blockquote>
<p>hash(object)</p>
<blockquote>
Return the hash value of the object (if it has one).  Hash values
are integers. They are used to quickly compare dictionary keys
during a dictionary lookup. Numeric values that compare equal have
the same hash value (even if they are of different types, as is the
case for 1 and 1.0).</blockquote>
<p>help([object])</p>
<blockquote>
<p>Invoke the built-in help system.  (This function is intended for
interactive use.)  If no argument is given, the interactive help
system starts on the interpreter console.  If the argument is a
string, then the string is looked up as the name of a module,
function, class, method, keyword, or documentation topic, and a
help page is printed on the console.  If the argument is any other
kind of object, a help page on the object is generated.</p>
<p>This function is added to the built-in namespace by the <tt class="docutils literal"><span class="pre">site</span></tt>
module.</p>
<p>New in version 2.2.</p>
</blockquote>
<p>hex(x)</p>
<blockquote>
<p>Convert an integer number (of any size) to a hexadecimal string.
The result is a valid Python expression.</p>
<p>Changed in version 2.4: Formerly only returned an unsigned literal.</p>
</blockquote>
<p>id(object)</p>
<blockquote>
Return the &#8220;identity&#8221; of an object.  This is an integer (or long
integer) which is guaranteed to be unique and constant for this
object during its lifetime. Two objects with non-overlapping
lifetimes may have the same <tt class="docutils literal"><span class="pre">id()</span></tt> value. (Implementation note:
this is the address of the object.)</blockquote>
<p>input([prompt])</p>
<blockquote>
<p>Equivalent to <tt class="docutils literal"><span class="pre">eval(raw_input(prompt))</span></tt>.</p>
<dl class="docutils">
<dt>Warning: This function is not safe from user errors!  It expects a valid</dt>
<dd>Python expression as input; if the input is not syntactically
valid, a <tt class="docutils literal"><span class="pre">SyntaxError</span></tt> will be raised. Other exceptions may be
raised if there is an error during evaluation.  (On the other
hand, sometimes this is exactly what you need when writing a
quick script for expert use.)</dd>
</dl>
<p>If the <tt class="docutils literal"><span class="pre">readline</span></tt> module was loaded, then <tt class="docutils literal"><span class="pre">input()</span></tt> will use it
to provide elaborate line editing and history features.</p>
<p>Consider using the <tt class="docutils literal"><span class="pre">raw_input()</span></tt> function for general input from
users.</p>
</blockquote>
<p>int([x[, radix]])</p>
<blockquote>
<p>Convert a string or number to a plain integer.  If the argument is
a string, it must contain a possibly signed decimal number
representable as a Python integer, possibly embedded in whitespace.
The <em>radix</em> parameter gives the base for the conversion (which is
10 by default) and may be any integer in the range [2, 36], or
zero.  If <em>radix</em> is zero, the proper radix is determined based on
the contents of string; the interpretation is the same as for
integer literals.  (See <em>Numeric literals</em>.)  If <em>radix</em> is
specified and <em>x</em> is not a string, <tt class="docutils literal"><span class="pre">TypeError</span></tt> is raised.
Otherwise, the argument may be a plain or long integer or a
floating point number.  Conversion of floating point numbers to
integers truncates (towards zero).  If the argument is outside the
integer range a long object will be returned instead.  If no
arguments are given, returns <tt class="docutils literal"><span class="pre">0</span></tt>.</p>
<p>The integer type is described in <em>Numeric Types &#8212; int, float,
long, complex</em>.</p>
</blockquote>
<p>isinstance(object, classinfo)</p>
<blockquote>
<p>Return true if the <em>object</em> argument is an instance of the
<em>classinfo</em> argument, or of a (direct or indirect) subclass
thereof.  Also return true if <em>classinfo</em> is a type object (new-
style class) and <em>object</em> is an object of that type or of a (direct
or indirect) subclass thereof.  If <em>object</em> is not a class instance
or an object of the given type, the function always returns false.
If <em>classinfo</em> is neither a class object nor a type object, it may
be a tuple of class or type objects, or may recursively contain
other such tuples (other sequence types are not accepted).  If
<em>classinfo</em> is not a class, type, or tuple of classes, types, and
such tuples, a <tt class="docutils literal"><span class="pre">TypeError</span></tt> exception is raised.</p>
<p>Changed in version 2.2: Support for a tuple of type information was
added.</p>
</blockquote>
<p>issubclass(class, classinfo)</p>
<blockquote>
<p>Return true if <em>class</em> is a subclass (direct or indirect) of
<em>classinfo</em>.  A class is considered a subclass of itself.
<em>classinfo</em> may be a tuple of class objects, in which case every
entry in <em>classinfo</em> will be checked. In any other case, a
<tt class="docutils literal"><span class="pre">TypeError</span></tt> exception is raised.</p>
<p>Changed in version 2.3: Support for a tuple of type information was
added.</p>
</blockquote>
<p>iter(o[, sentinel])</p>
<blockquote>
<p>Return an <em>iterator</em> object.  The first argument is interpreted
very differently depending on the presence of the second argument.
Without a second argument, <em>o</em> must be a collection object which
supports the iteration protocol (the <tt class="docutils literal"><span class="pre">__iter__()</span></tt> method), or it
must support the sequence protocol (the <tt class="docutils literal"><span class="pre">__getitem__()</span></tt> method
with integer arguments starting at <tt class="docutils literal"><span class="pre">0</span></tt>).  If it does not support
either of those protocols, <tt class="docutils literal"><span class="pre">TypeError</span></tt> is raised. If the second
argument, <em>sentinel</em>, is given, then <em>o</em> must be a callable object.
The iterator created in this case will call <em>o</em> with no arguments
for each call to its <tt class="docutils literal"><span class="pre">next()</span></tt> method; if the value returned is
equal to <em>sentinel</em>, <tt class="docutils literal"><span class="pre">StopIteration</span></tt> will be raised, otherwise
the value will be returned.</p>
<p>New in version 2.2.</p>
</blockquote>
<p>len(s)</p>
<blockquote>
Return the length (the number of items) of an object.  The argument
may be a sequence (string, tuple or list) or a mapping
(dictionary).</blockquote>
<p>list([iterable])</p>
<blockquote>
<p>Return a list whose items are the same and in the same order as
<em>iterable</em>&#8216;s items.  <em>iterable</em> may be either a sequence, a
container that supports iteration, or an iterator object.  If
<em>iterable</em> is already a list, a copy is made and returned, similar
to <tt class="docutils literal"><span class="pre">iterable[:]</span></tt>.  For instance, <tt class="docutils literal"><span class="pre">list('abc')</span></tt> returns <tt class="docutils literal"><span class="pre">['a',</span>
<span class="pre">'b',</span> <span class="pre">'c']</span></tt> and <tt class="docutils literal"><span class="pre">list(</span> <span class="pre">(1,</span> <span class="pre">2,</span> <span class="pre">3)</span> <span class="pre">)</span></tt> returns <tt class="docutils literal"><span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3]</span></tt>.  If no
argument is given, returns a new empty list, <tt class="docutils literal"><span class="pre">[]</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">list</span></tt> is a mutable sequence type, as documented in <em>Sequence
Types &#8212; str, unicode, list, tuple, buffer, xrange</em>. For other
containers see the built in <tt class="docutils literal"><span class="pre">dict</span></tt>, <tt class="docutils literal"><span class="pre">set</span></tt>, and <tt class="docutils literal"><span class="pre">tuple</span></tt>
classes, and the <tt class="docutils literal"><span class="pre">collections</span></tt> module.</p>
</blockquote>
<p>locals()</p>
<blockquote>
<p>Update and return a dictionary representing the current local
symbol table.</p>
<dl class="docutils">
<dt>Note: The contents of this dictionary should not be modified; changes</dt>
<dd>may not affect the values of local variables used by the
interpreter.</dd>
</dl>
<p>Free variables are returned by <tt class="docutils literal"><span class="pre">locals()</span></tt> when it is called in a
function block. Modifications of free variables may not affect the
values used by the interpreter.  Free variables are not returned in
class blocks.</p>
</blockquote>
<p>long([x[, radix]])</p>
<blockquote>
<p>Convert a string or number to a long integer.  If the argument is a
string, it must contain a possibly signed number of arbitrary size,
possibly embedded in whitespace. The <em>radix</em> argument is
interpreted in the same way as for <tt class="docutils literal"><span class="pre">int()</span></tt>, and may only be given
when <em>x</em> is a string. Otherwise, the argument may be a plain or
long integer or a floating point number, and a long integer with
the same value is returned.    Conversion of floating point numbers
to integers truncates (towards zero).  If no arguments are given,
returns <tt class="docutils literal"><span class="pre">0L</span></tt>.</p>
<p>The long type is described in <em>Numeric Types &#8212; int, float, long,
complex</em>.</p>
</blockquote>
<p>map(function, iterable, ...)</p>
<blockquote>
Apply <em>function</em> to every item of <em>iterable</em> and return a list of
the results. If additional <em>iterable</em> arguments are passed,
<em>function</em> must take that many arguments and is applied to the
items from all iterables in parallel.  If one iterable is shorter
than another it is assumed to be extended with <tt class="xref docutils literal"><span class="pre">None</span></tt> items.  If
<em>function</em> is <tt class="xref docutils literal"><span class="pre">None</span></tt>, the identity function is assumed; if there
are multiple arguments, <tt class="docutils literal"><span class="pre">map()</span></tt> returns a list consisting of
tuples containing the corresponding items from all iterables (a
kind of transpose operation).  The <em>iterable</em> arguments may be a
sequence  or any iterable object; the result is always a list.</blockquote>
<p>max(iterable[, args...][, key])</p>
<blockquote>
<p>With a single argument <em>iterable</em>, return the largest item of a
non-empty iterable (such as a string, tuple or list).  With more
than one argument, return the largest of the arguments.</p>
<p>The optional <em>key</em> argument specifies a one-argument ordering
function like that used for <tt class="docutils literal"><span class="pre">list.sort()</span></tt>.  The <em>key</em> argument,
if supplied, must be in keyword form (for example,
<tt class="docutils literal"><span class="pre">max(a,b,c,key=func)</span></tt>).</p>
<p>Changed in version 2.5: Added support for the optional <em>key</em>
argument.</p>
</blockquote>
<p>min(iterable[, args...][, key])</p>
<blockquote>
<p>With a single argument <em>iterable</em>, return the smallest item of a
non-empty iterable (such as a string, tuple or list).  With more
than one argument, return the smallest of the arguments.</p>
<p>The optional <em>key</em> argument specifies a one-argument ordering
function like that used for <tt class="docutils literal"><span class="pre">list.sort()</span></tt>.  The <em>key</em> argument,
if supplied, must be in keyword form (for example,
<tt class="docutils literal"><span class="pre">min(a,b,c,key=func)</span></tt>).</p>
<p>Changed in version 2.5: Added support for the optional <em>key</em>
argument.</p>
</blockquote>
<p>next(iterator[, default])</p>
<blockquote>
<p>Retrieve the next item from the <em>iterator</em> by calling its
<tt class="docutils literal"><span class="pre">next()</span></tt> method.  If <em>default</em> is given, it is returned if the
iterator is exhausted, otherwise <tt class="docutils literal"><span class="pre">StopIteration</span></tt> is raised.</p>
<p>New in version 2.6.</p>
</blockquote>
<p>object()</p>
<blockquote>
<p>Return a new featureless object.  <tt class="docutils literal"><span class="pre">object</span></tt> is a base for all new
style classes.  It has the methods that are common to all instances
of new style classes.</p>
<p>New in version 2.2.</p>
<p>Changed in version 2.3: This function does not accept any
arguments. Formerly, it accepted arguments but ignored them.</p>
</blockquote>
<p>oct(x)</p>
<blockquote>
<p>Convert an integer number (of any size) to an octal string.  The
result is a valid Python expression.</p>
<p>Changed in version 2.4: Formerly only returned an unsigned literal.</p>
</blockquote>
<p>open(filename[, mode[, bufsize]])</p>
<blockquote>
<p>Open a file, returning an object of the <tt class="docutils literal"><span class="pre">file</span></tt> type described in
section <em>File Objects</em>.  If the file cannot be opened, <tt class="docutils literal"><span class="pre">IOError</span></tt>
is raised.  When opening a file, it&#8217;s preferable to use <tt class="docutils literal"><span class="pre">open()</span></tt>
instead of invoking the <tt class="docutils literal"><span class="pre">file</span></tt> constructor directly.</p>
<p>The first two arguments are the same as for <tt class="docutils literal"><span class="pre">stdio</span></tt>&#8216;s
<tt class="docutils literal"><span class="pre">fopen()</span></tt>: <em>filename</em> is the file name to be opened, and <em>mode</em>
is a string indicating how the file is to be opened.</p>
<p>The most commonly-used values of <em>mode</em> are <tt class="docutils literal"><span class="pre">'r'</span></tt> for reading,
<tt class="docutils literal"><span class="pre">'w'</span></tt> for writing (truncating the file if it already exists), and
<tt class="docutils literal"><span class="pre">'a'</span></tt> for appending (which on <em>some</em> Unix systems means that
<em>all</em> writes append to the end of the file regardless of the
current seek position).  If <em>mode</em> is omitted, it defaults to
<tt class="docutils literal"><span class="pre">'r'</span></tt>.  The default is to use text mode, which may convert
<tt class="docutils literal"><span class="pre">'\n'</span></tt> characters to a platform-specific representation on
writing and back on reading.  Thus, when opening a binary file, you
should append <tt class="docutils literal"><span class="pre">'b'</span></tt> to the <em>mode</em> value to open the file in
binary mode, which will improve portability.  (Appending <tt class="docutils literal"><span class="pre">'b'</span></tt> is
useful even on systems that don&#8217;t treat binary and text files
differently, where it serves as documentation.)  See below for more
possible values of <em>mode</em>.</p>
<p>The optional <em>bufsize</em> argument specifies the file&#8217;s desired buffer
size: 0 means unbuffered, 1 means line buffered, any other positive
value means use a buffer of (approximately) that size.  A negative
<em>bufsize</em> means to use the system default, which is usually line
buffered for tty devices and fully buffered for other files.  If
omitted, the system default is used. [2]</p>
<p>Modes <tt class="docutils literal"><span class="pre">'r+'</span></tt>, <tt class="docutils literal"><span class="pre">'w+'</span></tt> and <tt class="docutils literal"><span class="pre">'a+'</span></tt> open the file for updating
(note that <tt class="docutils literal"><span class="pre">'w+'</span></tt> truncates the file).  Append <tt class="docutils literal"><span class="pre">'b'</span></tt> to the
mode to open the file in binary mode, on systems that differentiate
between binary and text files; on systems that don&#8217;t have this
distinction, adding the <tt class="docutils literal"><span class="pre">'b'</span></tt> has no effect.</p>
<p>In addition to the standard <tt class="docutils literal"><span class="pre">fopen()</span></tt> values <em>mode</em> may be
<tt class="docutils literal"><span class="pre">'U'</span></tt> or <tt class="docutils literal"><span class="pre">'rU'</span></tt>.  Python is usually built with universal
newline support; supplying <tt class="docutils literal"><span class="pre">'U'</span></tt> opens the file as a text file,
but lines may be terminated by any of the following: the Unix end-
of-line convention <tt class="docutils literal"><span class="pre">'\n'</span></tt>,  the Macintosh convention <tt class="docutils literal"><span class="pre">'\r'</span></tt>, or
the Windows convention <tt class="docutils literal"><span class="pre">'\r\n'</span></tt>. All of these external
representations are seen as <tt class="docutils literal"><span class="pre">'\n'</span></tt> by the Python program. If
Python is built without universal newline support a <em>mode</em> with
<tt class="docutils literal"><span class="pre">'U'</span></tt> is the same as normal text mode.  Note that file objects so
opened also have an attribute called <tt class="docutils literal"><span class="pre">newlines</span></tt> which has a value
of <tt class="xref docutils literal"><span class="pre">None</span></tt> (if no newlines have yet been seen), <tt class="docutils literal"><span class="pre">'\n'</span></tt>,
<tt class="docutils literal"><span class="pre">'\r'</span></tt>, <tt class="docutils literal"><span class="pre">'\r\n'</span></tt>, or a tuple containing all the newline types
seen.</p>
<p>Python enforces that the mode, after stripping <tt class="docutils literal"><span class="pre">'U'</span></tt>, begins with
<tt class="docutils literal"><span class="pre">'r'</span></tt>, <tt class="docutils literal"><span class="pre">'w'</span></tt> or <tt class="docutils literal"><span class="pre">'a'</span></tt>.</p>
<p>Python provides many file handling modules including <tt class="docutils literal"><span class="pre">fileinput</span></tt>,
<tt class="docutils literal"><span class="pre">os</span></tt>, <tt class="docutils literal"><span class="pre">os.path</span></tt>, <tt class="docutils literal"><span class="pre">tempfile</span></tt>, and <tt class="docutils literal"><span class="pre">shutil</span></tt>.</p>
<p>Changed in version 2.5: Restriction on first letter of mode string
introduced.</p>
</blockquote>
<p>ord(c)</p>
<blockquote>
Given a string of length one, return an integer representing the
Unicode code point of the character when the argument is a unicode
object, or the value of the byte when the argument is an 8-bit
string. For example, <tt class="docutils literal"><span class="pre">ord('a')</span></tt> returns the integer <tt class="docutils literal"><span class="pre">97</span></tt>,
<tt class="docutils literal"><span class="pre">ord(u'\u2020')</span></tt> returns <tt class="docutils literal"><span class="pre">8224</span></tt>.  This is the inverse of
<tt class="docutils literal"><span class="pre">chr()</span></tt> for 8-bit strings and of <tt class="docutils literal"><span class="pre">unichr()</span></tt> for unicode
objects.  If a unicode argument is given and Python was built with
UCS2 Unicode, then the character&#8217;s code point must be in the range
[0..65535] inclusive; otherwise the string length is two, and a
<tt class="docutils literal"><span class="pre">TypeError</span></tt> will be raised.</blockquote>
<p>pow(x, y[, z])</p>
<blockquote>
<p>Return <em>x</em> to the power <em>y</em>; if <em>z</em> is present, return <em>x</em> to the
power <em>y</em>, modulo <em>z</em> (computed more efficiently than <tt class="docutils literal"><span class="pre">pow(x,</span> <span class="pre">y)</span> <span class="pre">%</span>
<span class="pre">z</span></tt>). The two-argument form <tt class="docutils literal"><span class="pre">pow(x,</span> <span class="pre">y)</span></tt> is equivalent to using
the power operator: <tt class="docutils literal"><span class="pre">x**y</span></tt>.</p>
<p>The arguments must have numeric types.  With mixed operand types,
the coercion rules for binary arithmetic operators apply.  For int
and long int operands, the result has the same type as the operands
(after coercion) unless the second argument is negative; in that
case, all arguments are converted to float and a float result is
delivered.  For example, <tt class="docutils literal"><span class="pre">10**2</span></tt> returns <tt class="docutils literal"><span class="pre">100</span></tt>, but <tt class="docutils literal"><span class="pre">10**-2</span></tt>
returns <tt class="docutils literal"><span class="pre">0.01</span></tt>.  (This last feature was added in Python 2.2.  In
Python 2.1 and before, if both arguments were of integer types and
the second argument was negative, an exception was raised.) If the
second argument is negative, the third argument must be omitted. If
<em>z</em> is present, <em>x</em> and <em>y</em> must be of integer types, and <em>y</em> must
be non-negative.  (This restriction was added in Python 2.2.  In
Python 2.1 and before, floating 3-argument <tt class="docutils literal"><span class="pre">pow()</span></tt> returned
platform-dependent results depending on floating-point rounding
accidents.)</p>
</blockquote>
<p>print([object, ...][, sep=&#8217; &#8216;][, end=&#8217;n&#8217;][, file=sys.stdout])</p>
<blockquote>
<p>Print <em>object*(s) to the stream *file</em>, separated by <em>sep</em> and
followed by <em>end</em>.  <em>sep</em>, <em>end</em> and <em>file</em>, if present, must be
given as keyword arguments.</p>
<p>All non-keyword arguments are converted to strings like <tt class="docutils literal"><span class="pre">str()</span></tt>
does and written to the stream, separated by <em>sep</em> and followed by
<em>end</em>.  Both <em>sep</em> and <em>end</em> must be strings; they can also be
<tt class="xref docutils literal"><span class="pre">None</span></tt>, which means to use the default values.  If no <em>object</em> is
given, <tt class="docutils literal"><span class="pre">print()</span></tt> will just write <em>end</em>.</p>
<p>The <em>file</em> argument must be an object with a <tt class="docutils literal"><span class="pre">write(string)</span></tt>
method; if it is not present or <tt class="xref docutils literal"><span class="pre">None</span></tt>, <tt class="docutils literal"><span class="pre">sys.stdout</span></tt> will be
used.</p>
<dl class="docutils">
<dt>Note: This function is not normally available as a builtin since the</dt>
<dd><p class="first">name <tt class="docutils literal"><span class="pre">print</span></tt> is recognized as the <tt class="docutils literal"><span class="pre">print</span></tt> statement.  To
disable the statement and use the <tt class="docutils literal"><span class="pre">print()</span></tt> function, use this
future statement at the top of your module:</p>
<blockquote class="last">
from __future__ import print_function</blockquote>
</dd>
</dl>
<p>New in version 2.6.</p>
</blockquote>
<p>property([fget[, fset[, fdel[, doc]]]])</p>
<blockquote>
<p>Return a property attribute for <a href="#id1"><span class="problematic" id="id2">*</span></a>new-style class*es (classes that
derive from <tt class="docutils literal"><span class="pre">object</span></tt>).</p>
<p><em>fget</em> is a function for getting an attribute value, likewise
<em>fset</em> is a function for setting, and <em>fdel</em> a function for
del&#8217;ing, an attribute.  Typical use is to define a managed
attribute x:</p>
<blockquote>
<dl class="docutils">
<dt>class C(object):</dt>
<dd><dl class="first docutils">
<dt>def __init__(self):</dt>
<dd>self._x = None</dd>
<dt>def getx(self):</dt>
<dd>return self._x</dd>
<dt>def setx(self, value):</dt>
<dd>self._x = value</dd>
<dt>def delx(self):</dt>
<dd>del self._x</dd>
</dl>
<p class="last">x = property(getx, setx, delx, &#8220;I&#8217;m the &#8216;x&#8217; property.&#8221;)</p>
</dd>
</dl>
</blockquote>
<p>If given, <em>doc</em> will be the docstring of the property attribute.
Otherwise, the property will copy <em>fget</em>&#8216;s docstring (if it
exists).  This makes it possible to create read-only properties
easily using <tt class="docutils literal"><span class="pre">property()</span></tt> as a <em>decorator</em>:</p>
<blockquote>
<dl class="docutils">
<dt>class Parrot(object):</dt>
<dd><dl class="first docutils">
<dt>def __init__(self):</dt>
<dd>self._voltage = 100000</dd>
</dl>
<p>&#64;property
def voltage(self):</p>
<blockquote class="last">
&#8220;&#8221;&#8220;Get the current voltage.&#8221;&#8220;&#8221;
return self._voltage</blockquote>
</dd>
</dl>
</blockquote>
<p>turns the <tt class="docutils literal"><span class="pre">voltage()</span></tt> method into a &#8220;getter&#8221; for a read-only
attribute with the same name.</p>
<p>A property object has <tt class="docutils literal"><span class="pre">getter</span></tt>, <tt class="docutils literal"><span class="pre">setter</span></tt>, and <tt class="docutils literal"><span class="pre">deleter</span></tt>
methods usable as decorators that create a copy of the property
with the corresponding accessor function set to the decorated
function.  This is best explained with an example:</p>
<blockquote>
<dl class="docutils">
<dt>class C(object):</dt>
<dd><dl class="first docutils">
<dt>def __init__(self):</dt>
<dd>self._x = None</dd>
</dl>
<p>&#64;property
def x(self):</p>
<blockquote>
&#8220;&#8221;&#8220;I&#8217;m the &#8216;x&#8217; property.&#8221;&#8220;&#8221;
return self._x</blockquote>
<p>&#64;x.setter
def x(self, value):</p>
<blockquote>
self._x = value</blockquote>
<p>&#64;x.deleter
def x(self):</p>
<blockquote class="last">
del self._x</blockquote>
</dd>
</dl>
</blockquote>
<p>This code is exactly equivalent to the first example.  Be sure to
give the additional functions the same name as the original
property (<tt class="docutils literal"><span class="pre">x</span></tt> in this case.)</p>
<p>The returned property also has the attributes <tt class="docutils literal"><span class="pre">fget</span></tt>, <tt class="docutils literal"><span class="pre">fset</span></tt>,
and <tt class="docutils literal"><span class="pre">fdel</span></tt> corresponding to the constructor arguments.</p>
<p>New in version 2.2.</p>
<p>Changed in version 2.5: Use <em>fget</em>&#8216;s docstring if no <em>doc</em> given.</p>
<p>Changed in version 2.6: The <tt class="docutils literal"><span class="pre">getter</span></tt>, <tt class="docutils literal"><span class="pre">setter</span></tt>, and <tt class="docutils literal"><span class="pre">deleter</span></tt>
attributes were added.</p>
</blockquote>
<p>range([start], stop[, step])</p>
<blockquote>
<p>This is a versatile function to create lists containing arithmetic
progressions. It is most often used in <tt class="docutils literal"><span class="pre">for</span></tt> loops.  The
arguments must be plain integers.  If the <em>step</em> argument is
omitted, it defaults to <tt class="docutils literal"><span class="pre">1</span></tt>.  If the <em>start</em> argument is omitted,
it defaults to <tt class="docutils literal"><span class="pre">0</span></tt>.  The full form returns a list of plain
integers <tt class="docutils literal"><span class="pre">[start,</span> <span class="pre">start</span> <span class="pre">+</span> <span class="pre">step,</span> <span class="pre">start</span> <span class="pre">+</span> <span class="pre">2</span> <span class="pre">*</span> <span class="pre">step,</span> <span class="pre">...]</span></tt>.  If
<em>step</em> is positive, the last element is the largest <tt class="docutils literal"><span class="pre">start</span> <span class="pre">+</span> <span class="pre">i</span> <span class="pre">*</span>
<span class="pre">step</span></tt> less than <em>stop</em>; if <em>step</em> is negative, the last element is
the smallest <tt class="docutils literal"><span class="pre">start</span> <span class="pre">+</span> <span class="pre">i</span> <span class="pre">*</span> <span class="pre">step</span></tt> greater than <em>stop</em>.  <em>step</em> must
not be zero (or else <tt class="docutils literal"><span class="pre">ValueError</span></tt> is raised).  Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="go">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">11</span><span class="p">)</span>
<span class="go">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">[0, 5, 10, 15, 20, 25]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">[0, 3, 6, 9]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">[]</span>
</pre></div>
</div>
</blockquote>
<p>raw_input([prompt])</p>
<blockquote>
<p>If the <em>prompt</em> argument is present, it is written to standard
output without a trailing newline.  The function then reads a line
from input, converts it to a string (stripping a trailing newline),
and returns that. When EOF is read, <tt class="docutils literal"><span class="pre">EOFError</span></tt> is raised.
Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="nb">raw_input</span><span class="p">(</span><span class="s">&#39;--&gt; &#39;</span><span class="p">)</span>
<span class="go">--&gt; Monty Python&#39;s Flying Circus</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">&quot;Monty Python&#39;s Flying Circus&quot;</span>
</pre></div>
</div>
<p>If the <tt class="docutils literal"><span class="pre">readline</span></tt> module was loaded, then <tt class="docutils literal"><span class="pre">raw_input()</span></tt> will
use it to provide elaborate line editing and history features.</p>
</blockquote>
<p>reduce(function, iterable[, initializer])</p>
<blockquote>
Apply <em>function</em> of two arguments cumulatively to the items of
<em>iterable</em>, from left to right, so as to reduce the iterable to a
single value.  For example, <tt class="docutils literal"><span class="pre">reduce(lambda</span> <span class="pre">x,</span> <span class="pre">y:</span> <span class="pre">x+y,</span> <span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4,</span>
<span class="pre">5])</span></tt> calculates <tt class="docutils literal"><span class="pre">((((1+2)+3)+4)+5)</span></tt>. The left argument, <em>x</em>, is
the accumulated value and the right argument, <em>y</em>, is the update
value from the <em>iterable</em>.  If the optional <em>initializer</em> is
present, it is placed before the items of the iterable in the
calculation, and serves as a default when the iterable is empty.
If <em>initializer</em> is not given and <em>iterable</em> contains only one
item, the first item is returned.</blockquote>
<p>reload(module)</p>
<blockquote>
<p>Reload a previously imported <em>module</em>.  The argument must be a
module object, so it must have been successfully imported before.
This is useful if you have edited the module source file using an
external editor and want to try out the new version without leaving
the Python interpreter.  The return value is the module object (the
same as the <em>module</em> argument).</p>
<p>When <tt class="docutils literal"><span class="pre">reload(module)</span></tt> is executed:</p>
<ul class="simple">
<li>Python modules&#8217; code is recompiled and the module-level code
reexecuted, defining a new set of objects which are bound to
names in the module&#8217;s dictionary.  The <tt class="docutils literal"><span class="pre">init</span></tt> function of
extension modules is not called a second time.</li>
<li>As with all other objects in Python the old objects are only
reclaimed after their reference counts drop to zero.</li>
<li>The names in the module namespace are updated to point to any new
or changed objects.</li>
<li>Other references to the old objects (such as names external to
the module) are not rebound to refer to the new objects and must
be updated in each namespace where they occur if that is desired.</li>
</ul>
<p>There are a number of other caveats:</p>
<p>If a module is syntactically correct but its initialization fails,
the first <tt class="docutils literal"><span class="pre">import</span></tt> statement for it does not bind its name
locally, but does store a (partially initialized) module object in
<tt class="docutils literal"><span class="pre">sys.modules</span></tt>.  To reload the module you must first <tt class="docutils literal"><span class="pre">import</span></tt> it
again (this will bind the name to the partially initialized module
object) before you can <tt class="docutils literal"><span class="pre">reload()</span></tt> it.</p>
<p>When a module is reloaded, its dictionary (containing the module&#8217;s
global variables) is retained.  Redefinitions of names will
override the old definitions, so this is generally not a problem.
If the new version of a module does not define a name that was
defined by the old version, the old definition remains.  This
feature can be used to the module&#8217;s advantage if it maintains a
global table or cache of objects &#8212; with a <tt class="docutils literal"><span class="pre">try</span></tt> statement it
can test for the table&#8217;s presence and skip its initialization if
desired:</p>
<blockquote>
<dl class="docutils">
<dt>try:</dt>
<dd>cache</dd>
<dt>except NameError:</dt>
<dd>cache = {}</dd>
</dl>
</blockquote>
<p>It is legal though generally not very useful to reload built-in or
dynamically loaded modules, except for <tt class="docutils literal"><span class="pre">sys</span></tt>, <tt class="docutils literal"><span class="pre">__main__</span></tt> and
<tt class="docutils literal"><span class="pre">__builtin__</span></tt>. In many cases, however, extension modules are not
designed to be initialized more than once, and may fail in
arbitrary ways when reloaded.</p>
<p>If a module imports objects from another module using <tt class="docutils literal"><span class="pre">from</span></tt> ...
<tt class="docutils literal"><span class="pre">import</span></tt> ..., calling <tt class="docutils literal"><span class="pre">reload()</span></tt> for the other module does not
redefine the objects imported from it &#8212; one way around this is to
re-execute the <tt class="docutils literal"><span class="pre">from</span></tt> statement, another is to use <tt class="docutils literal"><span class="pre">import</span></tt> and
qualified names (<em>module</em>.*name*) instead.</p>
<p>If a module instantiates instances of a class, reloading the module
that defines the class does not affect the method definitions of
the instances &#8212; they continue to use the old class definition.
The same is true for derived classes.</p>
</blockquote>
<p>repr(object)</p>
<blockquote>
Return a string containing a printable representation of an object.
This is the same value yielded by conversions (reverse quotes).  It
is sometimes useful to be able to access this operation as an
ordinary function.  For many types, this function makes an attempt
to return a string that would yield an object with the same value
when passed to <tt class="docutils literal"><span class="pre">eval()</span></tt>, otherwise the representation is a string
enclosed in angle brackets that contains the name of the type of
the object together with additional information often including the
name and address of the object.  A class can control what this
function returns for its instances by defining a <tt class="docutils literal"><span class="pre">__repr__()</span></tt>
method.</blockquote>
<p>reversed(seq)</p>
<blockquote>
<p>Return a reverse <em>iterator</em>.  <em>seq</em> must be an object which has a
<tt class="docutils literal"><span class="pre">__reversed__()</span></tt> method or supports the sequence protocol (the
<tt class="docutils literal"><span class="pre">__len__()</span></tt> method and the <tt class="docutils literal"><span class="pre">__getitem__()</span></tt> method with integer
arguments starting at <tt class="docutils literal"><span class="pre">0</span></tt>).</p>
<p>New in version 2.4.</p>
<p>Changed in version 2.6: Added the possibility to write a custom
<tt class="docutils literal"><span class="pre">__reversed__()</span></tt> method.</p>
</blockquote>
<p>round(x[, n])</p>
<blockquote>
Return the floating point value <em>x</em> rounded to <em>n</em> digits after the
decimal point.  If <em>n</em> is omitted, it defaults to zero. The result
is a floating point number.  Values are rounded to the closest
multiple of 10 to the power minus <em>n</em>; if two multiples are equally
close, rounding is done away from 0 (so. for example,
<tt class="docutils literal"><span class="pre">round(0.5)</span></tt> is <tt class="docutils literal"><span class="pre">1.0</span></tt> and <tt class="docutils literal"><span class="pre">round(-0.5)</span></tt> is <tt class="docutils literal"><span class="pre">-1.0</span></tt>).</blockquote>
<p>set([iterable])</p>
<blockquote>
<p>Return a new set, optionally with elements are taken from
<em>iterable</em>. The set type is described in <em>Set Types &#8212; set,
frozenset</em>.</p>
<p>For other containers see the built in <tt class="docutils literal"><span class="pre">dict</span></tt>, <tt class="docutils literal"><span class="pre">list</span></tt>, and
<tt class="docutils literal"><span class="pre">tuple</span></tt> classes, and the <tt class="docutils literal"><span class="pre">collections</span></tt> module.</p>
<p>New in version 2.4.</p>
</blockquote>
<p>setattr(object, name, value)</p>
<blockquote>
This is the counterpart of <tt class="docutils literal"><span class="pre">getattr()</span></tt>.  The arguments are an
object, a string and an arbitrary value.  The string may name an
existing attribute or a new attribute.  The function assigns the
value to the attribute, provided the object allows it.  For
example, <tt class="docutils literal"><span class="pre">setattr(x,</span> <span class="pre">'foobar',</span> <span class="pre">123)</span></tt> is equivalent to <tt class="docutils literal"><span class="pre">x.foobar</span>
<span class="pre">=</span> <span class="pre">123</span></tt>.</blockquote>
<p>slice([start], stop[, step])</p>
<blockquote>
Return a <em>slice</em> object representing the set of indices specified
by <tt class="docutils literal"><span class="pre">range(start,</span> <span class="pre">stop,</span> <span class="pre">step)</span></tt>.  The <em>start</em> and <em>step</em> arguments
default to <tt class="xref docutils literal"><span class="pre">None</span></tt>.  Slice objects have read-only data attributes
<tt class="docutils literal"><span class="pre">start</span></tt>, <tt class="docutils literal"><span class="pre">stop</span></tt> and <tt class="docutils literal"><span class="pre">step</span></tt> which merely return the argument
values (or their default).  They have no other explicit
functionality; however they are used by Numerical Python and other
third party extensions.  Slice objects are also generated when
extended indexing syntax is used.  For example:
<tt class="docutils literal"><span class="pre">a[start:stop:step]</span></tt> or <tt class="docutils literal"><span class="pre">a[start:stop,</span> <span class="pre">i]</span></tt>.  See
<tt class="docutils literal"><span class="pre">itertools.islice()</span></tt> for an alternate version that returns an
iterator.</blockquote>
<p>sorted(iterable[, cmp[, key[, reverse]]])</p>
<blockquote>
<p>Return a new sorted list from the items in <em>iterable</em>.</p>
<p>The optional arguments <em>cmp</em>, <em>key</em>, and <em>reverse</em> have the same
meaning as those for the <tt class="docutils literal"><span class="pre">list.sort()</span></tt> method (described in
section <em>Mutable Sequence Types</em>).</p>
<p><em>cmp</em> specifies a custom comparison function of two arguments
(iterable elements) which should return a negative, zero or
positive number depending on whether the first argument is
considered smaller than, equal to, or larger than the second
argument: <tt class="docutils literal"><span class="pre">cmp=lambda</span> <span class="pre">x,y:</span> <span class="pre">cmp(x.lower(),</span> <span class="pre">y.lower())</span></tt>.  The
default value is <tt class="xref docutils literal"><span class="pre">None</span></tt>.</p>
<p><em>key</em> specifies a function of one argument that is used to extract
a comparison key from each list element: <tt class="docutils literal"><span class="pre">key=str.lower</span></tt>.  The
default value is <tt class="xref docutils literal"><span class="pre">None</span></tt>.</p>
<p><em>reverse</em> is a boolean value.  If set to <tt class="xref docutils literal"><span class="pre">True</span></tt>, then the list
elements are sorted as if each comparison were reversed.</p>
<p>In general, the <em>key</em> and <em>reverse</em> conversion processes are much
faster than specifying an equivalent <em>cmp</em> function.  This is
because <em>cmp</em> is called multiple times for each list element while
<em>key</em> and <em>reverse</em> touch each element only once.  To convert an
old-style <em>cmp</em> function to a <em>key</em> function, see the CmpToKey
recipe in the ASPN cookbook.</p>
<p>New in version 2.4.</p>
</blockquote>
<p>staticmethod(function)</p>
<blockquote>
<p>Return a static method for <em>function</em>.</p>
<p>A static method does not receive an implicit first argument. To
declare a static method, use this idiom:</p>
<blockquote>
<dl class="docutils">
<dt>class C:</dt>
<dd>&#64;staticmethod
def f(arg1, arg2, ...): ...</dd>
</dl>
</blockquote>
<p>The <tt class="docutils literal"><span class="pre">&#64;staticmethod</span></tt> form is a function <em>decorator</em> &#8211; see the
description of function definitions in <em>Function definitions</em> for
details.</p>
<p>It can be called either on the class (such as <tt class="docutils literal"><span class="pre">C.f()</span></tt>) or on an
instance (such as <tt class="docutils literal"><span class="pre">C().f()</span></tt>).  The instance is ignored except for
its class.</p>
<p>Static methods in Python are similar to those found in Java or C++.
For a more advanced concept, see <tt class="docutils literal"><span class="pre">classmethod()</span></tt> in this section.</p>
<p>For more information on static methods, consult the documentation
on the standard type hierarchy in <em>The standard type hierarchy</em>.</p>
<p>New in version 2.2.</p>
<p>Changed in version 2.4: Function decorator syntax added.</p>
</blockquote>
<p>str([object])</p>
<blockquote>
<p>Return a string containing a nicely printable representation of an
object.  For strings, this returns the string itself.  The
difference with <tt class="docutils literal"><span class="pre">repr(object)</span></tt> is that <tt class="docutils literal"><span class="pre">str(object)</span></tt> does not
always attempt to return a string that is acceptable to <tt class="docutils literal"><span class="pre">eval()</span></tt>;
its goal is to return a printable string.  If no argument is given,
returns the empty string, <tt class="docutils literal"><span class="pre">''</span></tt>.</p>
<p>For more information on strings see <em>Sequence Types &#8212; str,
unicode, list, tuple, buffer, xrange</em> which describes sequence
functionality (strings are sequences), and also the string-specific
methods described in the <em>String Methods</em> section. To output
formatted strings use template strings or the <tt class="docutils literal"><span class="pre">%</span></tt> operator
described in the <em>String Formatting Operations</em> section. In
addition see the <em>String Services</em> section. See also <tt class="docutils literal"><span class="pre">unicode()</span></tt>.</p>
</blockquote>
<p>sum(iterable[, start])</p>
<blockquote>
<p>Sums <em>start</em> and the items of an <em>iterable</em> from left to right and
returns the total.  <em>start</em> defaults to <tt class="docutils literal"><span class="pre">0</span></tt>. The <em>iterable</em>&#8216;s
items are normally numbers, and are not allowed to be strings.  The
fast, correct way to concatenate a sequence of strings is by
calling <tt class="docutils literal"><span class="pre">''.join(sequence)</span></tt>. Note that <tt class="docutils literal"><span class="pre">sum(range(n),</span> <span class="pre">m)</span></tt> is
equivalent to <tt class="docutils literal"><span class="pre">reduce(operator.add,</span> <span class="pre">range(n),</span> <span class="pre">m)</span></tt> To add floating
point values with extended precision, see <tt class="docutils literal"><span class="pre">math.fsum()</span></tt>.</p>
<p>New in version 2.3.</p>
</blockquote>
<p>super(type[, object-or-type])</p>
<blockquote>
<p>Return a proxy object that delegates method calls to a parent or
sibling class of <em>type</em>.  This is useful for accessing inherited
methods that have been overridden in a class. The search order is
same as that used by <tt class="docutils literal"><span class="pre">getattr()</span></tt> except that the <em>type</em> itself is
skipped.</p>
<p>The <tt class="docutils literal"><span class="pre">__mro__</span></tt> attribute of the <em>type</em> lists the method resolution
search order used by both <tt class="docutils literal"><span class="pre">getattr()</span></tt> and <tt class="docutils literal"><span class="pre">super()</span></tt>.  The
attribute is dynamic and can change whenever the inheritance
hierarchy is updated.</p>
<p>If the second argument is omitted, the super object returned is
unbound.  If the second argument is an object, <tt class="docutils literal"><span class="pre">isinstance(obj,</span>
<span class="pre">type)</span></tt> must be true.  If the second argument is a type,
<tt class="docutils literal"><span class="pre">issubclass(type2,</span> <span class="pre">type)</span></tt> must be true (this is useful for
classmethods).</p>
<p>Note: <tt class="docutils literal"><span class="pre">super()</span></tt> only works for <a href="#id3"><span class="problematic" id="id4">*</span></a>new-style class*es.</p>
<p>There are two typical use cases for <em>super</em>.  In a class hierarchy
with single inheritance, <em>super</em> can be used to refer to parent
classes without naming them explicitly, thus making the code more
maintainable.  This use closely parallels the use of <em>super</em> in
other programming languages.</p>
<p>The second use case is to support cooperative multiple inheritance
in a dynamic execution environment.  This use case is unique to
Python and is not found in statically compiled languages or
languages that only support single inheritance.  This makes it
possible to implement &#8220;diamond diagrams&#8221; where multiple base
classes implement the same method.  Good design dictates that this
method have the same calling signature in every case (because the
order of calls is determined at runtime, because that order adapts
to changes in the class hierarchy, and because that order can
include sibling classes that are unknown prior to runtime).</p>
<p>For both use cases, a typical superclass call looks like this:</p>
<blockquote>
<dl class="docutils">
<dt>class C(B):</dt>
<dd><dl class="first last docutils">
<dt>def method(self, arg):</dt>
<dd>super(C, self).method(arg)</dd>
</dl>
</dd>
</dl>
</blockquote>
<p>Note that <tt class="docutils literal"><span class="pre">super()</span></tt> is implemented as part of the binding process
for explicit dotted attribute lookups such as
<tt class="docutils literal"><span class="pre">super().__getitem__(name)</span></tt>. It does so by implementing its own
<tt class="docutils literal"><span class="pre">__getattribute__()</span></tt> method for searching classes in a
predictable order that supports cooperative multiple inheritance.
Accordingly, <tt class="docutils literal"><span class="pre">super()</span></tt> is undefined for implicit lookups using
statements or operators such as <tt class="docutils literal"><span class="pre">super()[name]</span></tt>.</p>
<p>Also note that <tt class="docutils literal"><span class="pre">super()</span></tt> is not limited to use inside methods.
The two argument form specifies the arguments exactly and makes the
appropriate references.</p>
<p>New in version 2.2.</p>
</blockquote>
<p>tuple([iterable])</p>
<blockquote>
<p>Return a tuple whose items are the same and in the same order as
<em>iterable</em>&#8216;s items.  <em>iterable</em> may be a sequence, a container that
supports iteration, or an iterator object. If <em>iterable</em> is already
a tuple, it is returned unchanged. For instance, <tt class="docutils literal"><span class="pre">tuple('abc')</span></tt>
returns <tt class="docutils literal"><span class="pre">('a',</span> <span class="pre">'b',</span> <span class="pre">'c')</span></tt> and <tt class="docutils literal"><span class="pre">tuple([1,</span> <span class="pre">2,</span> <span class="pre">3])</span></tt> returns <tt class="docutils literal"><span class="pre">(1,</span>
<span class="pre">2,</span> <span class="pre">3)</span></tt>.  If no argument is given, returns a new empty tuple,
<tt class="docutils literal"><span class="pre">()</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">tuple</span></tt> is an immutable sequence type, as documented in <em>Sequence
Types &#8212; str, unicode, list, tuple, buffer, xrange</em>. For other
containers see the built in <tt class="docutils literal"><span class="pre">dict</span></tt>, <tt class="docutils literal"><span class="pre">list</span></tt>, and <tt class="docutils literal"><span class="pre">set</span></tt>
classes, and the <tt class="docutils literal"><span class="pre">collections</span></tt> module.</p>
</blockquote>
<p>type(object)</p>
<blockquote>
<p>Return the type of an <em>object</em>.  The return value is a type object.
The <tt class="docutils literal"><span class="pre">isinstance()</span></tt> built-in function is recommended for testing
the type of an object.</p>
<p>With three arguments, <tt class="docutils literal"><span class="pre">type()</span></tt> functions as a constructor as
detailed below.</p>
</blockquote>
<p>type(name, bases, dict)</p>
<blockquote>
<p>Return a new type object.  This is essentially a dynamic form of
the <tt class="docutils literal"><span class="pre">class</span></tt> statement. The <em>name</em> string is the class name and
becomes the <tt class="docutils literal"><span class="pre">__name__</span></tt> attribute; the <em>bases</em> tuple itemizes the
base classes and becomes the <tt class="docutils literal"><span class="pre">__bases__</span></tt> attribute; and the
<em>dict</em> dictionary is the namespace containing definitions for class
body and becomes the <tt class="docutils literal"><span class="pre">__dict__</span></tt> attribute.  For example, the
following two statements create identical <tt class="docutils literal"><span class="pre">type</span></tt> objects:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">X</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="s">&#39;X&#39;</span><span class="p">,</span> <span class="p">(</span><span class="nb">object</span><span class="p">,),</span> <span class="nb">dict</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>New in version 2.2.</p>
</blockquote>
<p>unichr(i)</p>
<blockquote>
<p>Return the Unicode string of one character whose Unicode code is
the integer <em>i</em>.  For example, <tt class="docutils literal"><span class="pre">unichr(97)</span></tt> returns the string
<tt class="docutils literal"><span class="pre">u'a'</span></tt>.  This is the inverse of <tt class="docutils literal"><span class="pre">ord()</span></tt> for Unicode strings.
The valid range for the argument depends how Python was configured
&#8211; it may be either UCS2 [0..0xFFFF] or UCS4 [0..0x10FFFF].
<tt class="docutils literal"><span class="pre">ValueError</span></tt> is raised otherwise. For ASCII and 8-bit strings see
<tt class="docutils literal"><span class="pre">chr()</span></tt>.</p>
<p>New in version 2.0.</p>
</blockquote>
<p>unicode([object[, encoding[, errors]]])</p>
<blockquote>
<p>Return the Unicode string version of <em>object</em> using one of the
following modes:</p>
<p>If <em>encoding</em> and/or <em>errors</em> are given, <tt class="docutils literal"><span class="pre">unicode()</span></tt> will decode
the object which can either be an 8-bit string or a character
buffer using the codec for <em>encoding</em>. The <em>encoding</em> parameter is
a string giving the name of an encoding; if the encoding is not
known, <tt class="docutils literal"><span class="pre">LookupError</span></tt> is raised. Error handling is done according
to <em>errors</em>; this specifies the treatment of characters which are
invalid in the input encoding.  If <em>errors</em> is <tt class="docutils literal"><span class="pre">'strict'</span></tt> (the
default), a <tt class="docutils literal"><span class="pre">ValueError</span></tt> is raised on errors, while a value of
<tt class="docutils literal"><span class="pre">'ignore'</span></tt> causes errors to be silently ignored, and a value of
<tt class="docutils literal"><span class="pre">'replace'</span></tt> causes the official Unicode replacement character,
<tt class="docutils literal"><span class="pre">U+FFFD</span></tt>, to be used to replace input characters which cannot be
decoded.  See also the <tt class="docutils literal"><span class="pre">codecs</span></tt> module.</p>
<p>If no optional parameters are given, <tt class="docutils literal"><span class="pre">unicode()</span></tt> will mimic the
behaviour of <tt class="docutils literal"><span class="pre">str()</span></tt> except that it returns Unicode strings
instead of 8-bit strings. More precisely, if <em>object</em> is a Unicode
string or subclass it will return that Unicode string without any
additional decoding applied.</p>
<p>For objects which provide a <tt class="docutils literal"><span class="pre">__unicode__()</span></tt> method, it will call
this method without arguments to create a Unicode string. For all
other objects, the 8-bit string version or representation is
requested and then converted to a Unicode string using the codec
for the default encoding in <tt class="docutils literal"><span class="pre">'strict'</span></tt> mode.</p>
<p>For more information on Unicode strings see <em>Sequence Types &#8212;
str, unicode, list, tuple, buffer, xrange</em> which describes sequence
functionality (Unicode strings are sequences), and also the string-
specific methods described in the <em>String Methods</em> section. To
output formatted strings use template strings or the <tt class="docutils literal"><span class="pre">%</span></tt> operator
described in the <em>String Formatting Operations</em> section. In
addition see the <em>String Services</em> section. See also <tt class="docutils literal"><span class="pre">str()</span></tt>.</p>
<p>New in version 2.0.</p>
<p>Changed in version 2.2: Support for <tt class="docutils literal"><span class="pre">__unicode__()</span></tt> added.</p>
</blockquote>
<p>vars([object])</p>
<blockquote>
<p>Without arguments, return a dictionary corresponding to the current
local symbol table.  With a module, class or class instance object
as argument (or anything else that has a <tt class="docutils literal"><span class="pre">__dict__</span></tt> attribute),
returns a dictionary corresponding to the object&#8217;s symbol table.</p>
<dl class="docutils">
<dt>Note: The returned dictionary should not be modified: the effects on</dt>
<dd>the corresponding symbol table are undefined. [3]</dd>
</dl>
</blockquote>
<p>xrange([start], stop[, step])</p>
<blockquote>
<p>This function is very similar to <tt class="docutils literal"><span class="pre">range()</span></tt>, but returns an
&#8220;xrange object&#8221; instead of a list.  This is an opaque sequence type
which yields the same values as the corresponding list, without
actually storing them all simultaneously. The advantage of
<tt class="docutils literal"><span class="pre">xrange()</span></tt> over <tt class="docutils literal"><span class="pre">range()</span></tt> is minimal (since <tt class="docutils literal"><span class="pre">xrange()</span></tt> still
has to create the values when asked for them) except when a very
large range is used on a memory-starved machine or when all of the
range&#8217;s elements are never used (such as when the loop is usually
terminated with <tt class="docutils literal"><span class="pre">break</span></tt>).</p>
<dl class="docutils">
<dt>Note: <tt class="docutils literal"><span class="pre">xrange()</span></tt> is intended to be simple and fast. Implementations</dt>
<dd>may impose restrictions to achieve this. The C implementation of
Python restricts all arguments to native C longs (&#8220;short&#8221; Python
integers), and also requires that the number of elements fit in a
native C long.  If a larger range is needed, an alternate version
can be crafted using the <tt class="docutils literal"><span class="pre">itertools</span></tt> module:
<tt class="docutils literal"><span class="pre">islice(count(start,</span> <span class="pre">step),</span> <span class="pre">(stop-start+step-1)//step)</span></tt>.</dd>
</dl>
</blockquote>
<p>zip([iterable, ...])</p>
<blockquote>
<p>This function returns a list of tuples, where the <em>i</em>-th tuple
contains the <em>i</em>-th element from each of the argument sequences or
iterables. The returned list is truncated in length to the length
of the shortest argument sequence. When there are multiple
arguments which are all of the same length, <tt class="docutils literal"><span class="pre">zip()</span></tt> is similar to
<tt class="docutils literal"><span class="pre">map()</span></tt> with an initial argument of <tt class="xref docutils literal"><span class="pre">None</span></tt>. With a single
sequence argument, it returns a list of 1-tuples. With no
arguments, it returns an empty list.</p>
<p>The left-to-right evaluation order of the iterables is guaranteed.
This makes possible an idiom for clustering a data series into
n-length groups using <tt class="docutils literal"><span class="pre">zip(*[iter(s)]*n)</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">zip()</span></tt> in conjunction with the <tt class="docutils literal"><span class="pre">*</span></tt> operator can be used to
unzip a list:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">zipped</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">zipped</span>
<span class="go">[(1, 4), (2, 5), (3, 6)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">zipped</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">==</span> <span class="nb">list</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span> <span class="ow">and</span> <span class="n">y</span> <span class="o">==</span> <span class="nb">list</span><span class="p">(</span><span class="n">y2</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>New in version 2.0.</p>
<p>Changed in version 2.4: Formerly, <tt class="docutils literal"><span class="pre">zip()</span></tt> required at least one
argument and <tt class="docutils literal"><span class="pre">zip()</span></tt> raised a <tt class="docutils literal"><span class="pre">TypeError</span></tt> instead of returning
an empty list.</p>
</blockquote>
<p>__import__(name[, globals[, locals[, fromlist[, level]]]])</p>
<blockquote>
<dl class="docutils">
<dt>Note: This is an advanced function that is not needed in everyday</dt>
<dd>Python programming.</dd>
</dl>
<p>This function is invoked by the <tt class="docutils literal"><span class="pre">import</span></tt> statement.  It can be
replaced (by importing the <tt class="docutils literal"><span class="pre">builtins</span></tt> module and assigning to
<tt class="docutils literal"><span class="pre">builtins.__import__</span></tt>) in order to change semantics of the
<tt class="docutils literal"><span class="pre">import</span></tt> statement, but nowadays it is usually simpler to use
import hooks (see <strong>PEP 302</strong>).  Direct use of <tt class="docutils literal"><span class="pre">__import__()</span></tt> is
rare, except in cases where you want to import a module whose name
is only known at runtime.</p>
<p>The function imports the module <em>name</em>, potentially using the given
<em>globals</em> and <em>locals</em> to determine how to interpret the name in a
package context. The <em>fromlist</em> gives the names of objects or
submodules that should be imported from the module given by <em>name</em>.
The standard implementation does not use its <em>locals</em> argument at
all, and uses its <em>globals</em> only to determine the package context
of the <tt class="docutils literal"><span class="pre">import</span></tt> statement.</p>
<p><em>level</em> specifies whether to use absolute or relative imports.  The
default is <tt class="docutils literal"><span class="pre">-1</span></tt> which indicates both absolute and relative
imports will be attempted.  <tt class="docutils literal"><span class="pre">0</span></tt> means only perform absolute
imports.  Positive values for <em>level</em> indicate the number of parent
directories to search relative to the directory of the module
calling <tt class="docutils literal"><span class="pre">__import__()</span></tt>.</p>
<p>When the <em>name</em> variable is of the form <tt class="docutils literal"><span class="pre">package.module</span></tt>,
normally, the top-level package (the name up till the first dot) is
returned, <em>not</em> the module named by <em>name</em>.  However, when a non-
empty <em>fromlist</em> argument is given, the module named by <em>name</em> is
returned.</p>
<p>For example, the statement <tt class="docutils literal"><span class="pre">import</span> <span class="pre">spam</span></tt> results in bytecode
resembling the following code:</p>
<blockquote>
spam = __import__(&#8216;spam&#8217;, globals(), locals(), [], -1)</blockquote>
<p>The statement <tt class="docutils literal"><span class="pre">import</span> <span class="pre">spam.ham</span></tt> results in this call:</p>
<blockquote>
spam = __import__(&#8216;spam.ham&#8217;, globals(), locals(), [], -1)</blockquote>
<p>Note how <tt class="docutils literal"><span class="pre">__import__()</span></tt> returns the toplevel module here because
this is the object that is bound to a name by the <tt class="docutils literal"><span class="pre">import</span></tt>
statement.</p>
<p>On the other hand, the statement <tt class="docutils literal"><span class="pre">from</span> <span class="pre">spam.ham</span> <span class="pre">import</span> <span class="pre">eggs,</span>
<span class="pre">sausage</span> <span class="pre">as</span> <span class="pre">saus</span></tt> results in</p>
<blockquote>
_temp = __import__(&#8216;spam.ham&#8217;, globals(), locals(), [&#8216;eggs&#8217;, &#8216;sausage&#8217;], -1)
eggs = _temp.eggs
saus = _temp.sausage</blockquote>
<p>Here, the <tt class="docutils literal"><span class="pre">spam.ham</span></tt> module is returned from <tt class="docutils literal"><span class="pre">__import__()</span></tt>.
From this object, the names to import are retrieved and assigned to
their respective names.</p>
<p>If you simply want to import a module (potentially within a
package) by name, you can call <tt class="docutils literal"><span class="pre">__import__()</span></tt> and then look it up
in <tt class="docutils literal"><span class="pre">sys.modules</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">name</span> <span class="o">=</span> <span class="s">&#39;foo.bar.baz&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">__import__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
<span class="go">&lt;module &#39;foo&#39; from ...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">baz</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">baz</span>
<span class="go">&lt;module &#39;foo.bar.baz&#39; from ...&gt;</span>
</pre></div>
</div>
<p>Changed in version 2.5: The level parameter was added.</p>
<p>Changed in version 2.5: Keyword support for parameters was added.</p>
</blockquote>
<div class="section" id="non-essential-built-in-functions">
<h2>2.1. Non-essential Built-in Functions<a class="headerlink" href="#non-essential-built-in-functions" title="Permalink to this headline">Â¶</a></h2>
<p>There are several built-in functions that are no longer essential to
learn, know or use in modern Python programming.  They have been kept
here to maintain backwards compatibility with programs written for
older versions of Python.</p>
<p>Python programmers, trainers, students and book writers should feel
free to bypass these functions without concerns about missing
something important.</p>
<p>apply(function, args[, keywords])</p>
<blockquote>
<p>The <em>function</em> argument must be a callable object (a user-defined
or built-in function or method, or a class object) and the <em>args</em>
argument must be a sequence.  The <em>function</em> is called with <em>args</em>
as the argument list; the number of arguments is the length of the
tuple. If the optional <em>keywords</em> argument is present, it must be a
dictionary whose keys are strings.  It specifies keyword arguments
to be added to the end of the argument list. Calling <tt class="docutils literal"><span class="pre">apply()</span></tt> is
different from just calling <tt class="docutils literal"><span class="pre">function(args)</span></tt>, since in that case
there is always exactly one argument.  The use of <tt class="docutils literal"><span class="pre">apply()</span></tt> is
equivalent to <tt class="docutils literal"><span class="pre">function(*args,</span> <span class="pre">**keywords)</span></tt>.</p>
<p>Deprecated since version 2.3: Use the extended call syntax with
<tt class="docutils literal"><span class="pre">*args</span></tt> and <tt class="docutils literal"><span class="pre">**keywords</span></tt> instead.</p>
</blockquote>
<p>buffer(object[, offset[, size]])</p>
<blockquote>
The <em>object</em> argument must be an object that supports the buffer
call interface (such as strings, arrays, and buffers).  A new
buffer object will be created which references the <em>object</em>
argument. The buffer object will be a slice from the beginning of
<em>object</em> (or from the specified <em>offset</em>). The slice will extend to
the end of <em>object</em> (or will have a length given by the <em>size</em>
argument).</blockquote>
<p>coerce(x, y)</p>
<blockquote>
Return a tuple consisting of the two numeric arguments converted to
a common type, using the same rules as used by arithmetic
operations. If coercion is not possible, raise <tt class="docutils literal"><span class="pre">TypeError</span></tt>.</blockquote>
<p>intern(string)</p>
<blockquote>
<p>Enter <em>string</em> in the table of &#8220;interned&#8221; strings and return the
interned string &#8211; which is <em>string</em> itself or a copy. Interning
strings is useful to gain a little performance on dictionary lookup
&#8211; if the keys in a dictionary are interned, and the lookup key is
interned, the key comparisons (after hashing) can be done by a
pointer compare instead of a string compare.  Normally, the names
used in Python programs are automatically interned, and the
dictionaries used to hold module, class or instance attributes have
interned keys.</p>
<p>Changed in version 2.3: Interned strings are not immortal (like
they used to be in Python 2.2 and before); you must keep a
reference to the return value of <tt class="docutils literal"><span class="pre">intern()</span></tt> around to benefit
from it.</p>
</blockquote>
<p>-[ Footnotes ]-</p>
<dl class="docutils">
<dt>[1] It is used relatively rarely so does not warrant being made into a</dt>
<dd>statement.</dd>
<dt>[2] Specifying a buffer size currently has no effect on systems that</dt>
<dd>don&#8217;t have <tt class="docutils literal"><span class="pre">setvbuf()</span></tt>.  The interface to specify the buffer
size is not done using a method that calls <tt class="docutils literal"><span class="pre">setvbuf()</span></tt>, because
that may dump core when called after any I/O has been performed,
and there&#8217;s no reliable way to determine whether this is the case.</dd>
<dt>[3] In the current implementation, local variable bindings cannot</dt>
<dd>normally be affected this way, but variables retrieved from other
scopes (such as modules) can be.  This may change.</dd>
</dl>
</div>
</div>


          </div>
        </div>
      </div>


      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../modindex.html" title="Global Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="constants.html" title="3. Built-in Constants"
             >next</a> |</li>
        <li class="right" >
          <a href="intro.html" title="1. Introduction"
             >previous</a> |</li>
        <li><a href="../index.html">Jython v2.5.2 documentation</a> &raquo;</li>
          <li><a href="indexprogress.html" >The Python Standard Library and What Comes with Jython</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
      &copy; <a href="../copyright.html">Copyright</a> 2011, Jython Project.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 0.6.4.
    </div>
  </body>
</html>