<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>15.5. logging — Logging facility for Python &mdash; Jython v2.5.2 documentation</title>
    <link rel="stylesheet" href="../_static/green-theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.5.2',
        COLLAPSE_MODINDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Jython v2.5.2 documentation" href="../index.html" />
    <link rel="up" title="15. Generic Operating System Services" href="allos.html" />
    <link rel="next" title="15.6. getpass — Portable password input" href="getpass.html" />
    <link rel="prev" title="15.4. getopt — Parser for command line options" href="getopt.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../modindex.html" title="Global Module Index"
             accesskey="M">modules</a> |</li>
        <li class="right" >
          <a href="getpass.html" title="15.6. getpass — Portable password input"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="getopt.html" title="15.4. getopt — Parser for command line options"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Jython v2.5.2 documentation</a> &raquo;</li>
          <li><a href="indexprogress.html" >The Python Standard Library and What Comes with Jython</a> &raquo;</li>
          <li><a href="allos.html" accesskey="U">15. Generic Operating System Services</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/jython.png" alt="Logo"/>
            </a></p>
            <h3><a href="../index.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference external" href="#">15.5. <tt class="docutils literal"><span class="pre">logging</span></tt> &#8212; Logging facility for Python</a><ul>
<li><a class="reference external" href="#logging-tutorial">15.5.1. Logging tutorial</a><ul>
<li><a class="reference external" href="#simple-examples">15.5.1.1. Simple examples</a></li>
<li><a class="reference external" href="#loggers">15.5.1.2. Loggers</a></li>
<li><a class="reference external" href="#handlers">15.5.1.3. Handlers</a></li>
<li><a class="reference external" href="#formatters">15.5.1.4. Formatters</a></li>
<li><a class="reference external" href="#configuring-logging">15.5.1.5. Configuring Logging</a></li>
<li><a class="reference external" href="#configuring-logging-for-a-library">15.5.1.6. Configuring Logging for a Library</a></li>
</ul>
</li>
<li><a class="reference external" href="#logging-levels">15.5.2. Logging Levels</a></li>
<li><a class="reference external" href="#logger-objects">15.5.3. Logger Objects</a></li>
<li><a class="reference external" href="#basic-example">15.5.4. Basic example</a></li>
<li><a class="reference external" href="#logging-to-multiple-destinations">15.5.5. Logging to multiple destinations</a></li>
<li><a class="reference external" href="#adding-contextual-information-to-your-logging-output">15.5.6. Adding contextual information to your logging output</a></li>
<li><a class="reference external" href="#sending-and-receiving-logging-events-across-a-network">15.5.7. Sending and receiving logging events across a network</a></li>
<li><a class="reference external" href="#handler-objects">15.5.8. Handler Objects</a><ul>
<li><a class="reference external" href="#streamhandler">15.5.8.1. StreamHandler</a></li>
<li><a class="reference external" href="#filehandler">15.5.8.2. FileHandler</a></li>
<li><a class="reference external" href="#watchedfilehandler">15.5.8.3. WatchedFileHandler</a></li>
<li><a class="reference external" href="#rotatingfilehandler">15.5.8.4. RotatingFileHandler</a></li>
<li><a class="reference external" href="#timedrotatingfilehandler">15.5.8.5. TimedRotatingFileHandler</a></li>
<li><a class="reference external" href="#sockethandler">15.5.8.6. SocketHandler</a></li>
<li><a class="reference external" href="#datagramhandler">15.5.8.7. DatagramHandler</a></li>
<li><a class="reference external" href="#sysloghandler">15.5.8.8. SysLogHandler</a></li>
<li><a class="reference external" href="#nteventloghandler">15.5.8.9. NTEventLogHandler</a></li>
<li><a class="reference external" href="#smtphandler">15.5.8.10. SMTPHandler</a></li>
<li><a class="reference external" href="#memoryhandler">15.5.8.11. MemoryHandler</a></li>
<li><a class="reference external" href="#httphandler">15.5.8.12. HTTPHandler</a></li>
</ul>
</li>
<li><a class="reference external" href="#formatter-objects">15.5.9. Formatter Objects</a></li>
<li><a class="reference external" href="#filter-objects">15.5.10. Filter Objects</a></li>
<li><a class="reference external" href="#logrecord-objects">15.5.11. LogRecord Objects</a></li>
<li><a class="reference external" href="#loggeradapter-objects">15.5.12. LoggerAdapter Objects</a></li>
<li><a class="reference external" href="#thread-safety">15.5.13. Thread Safety</a></li>
<li><a class="reference external" href="#configuration">15.5.14. Configuration</a><ul>
<li><a class="reference external" href="#configuration-functions">15.5.14.1. Configuration functions</a></li>
<li><a class="reference external" href="#configuration-file-format">15.5.14.2. Configuration file format</a></li>
<li><a class="reference external" href="#configuration-server-example">15.5.14.3. Configuration server example</a></li>
</ul>
</li>
<li><a class="reference external" href="#more-examples">15.5.15. More examples</a><ul>
<li><a class="reference external" href="#multiple-handlers-and-formatters">15.5.15.1. Multiple handlers and formatters</a></li>
<li><a class="reference external" href="#using-logging-in-multiple-modules">15.5.15.2. Using logging in multiple modules</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="getopt.html"
                                  title="previous chapter">15.4. <tt class="docutils literal docutils literal"><span class="pre">getopt</span></tt> &#8212; Parser for command line options</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="getpass.html"
                                  title="next chapter">15.6. <tt class="docutils literal docutils literal"><span class="pre">getpass</span></tt> &#8212; Portable password input</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../_sources/library/logging.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="../search.html" method="get">
                <input type="text" name="q" size="18" />
                <input type="submit" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="logging-logging-facility-for-python">
<h1>15.5. <tt class="docutils literal"><span class="pre">logging</span></tt> &#8212; Logging facility for Python<a class="headerlink" href="#logging-logging-facility-for-python" title="Permalink to this headline">¶</a></h1>
<p>New in version 2.3.</p>
<p>This module defines functions and classes which implement a flexible
error logging system for applications.</p>
<p>Logging is performed by calling methods on instances of the <tt class="docutils literal"><span class="pre">Logger</span></tt>
class (hereafter called <em>loggers</em>). Each instance has a name, and they
are conceptually arranged in a namespace hierarchy using dots
(periods) as separators. For example, a logger named &#8220;scan&#8221; is the
parent of loggers &#8220;scan.text&#8221;, &#8220;scan.html&#8221; and &#8220;scan.pdf&#8221;. Logger
names can be anything you want, and indicate the area of an
application in which a logged message originates.</p>
<p>Logged messages also have levels of importance associated with them.
The default levels provided are <tt class="docutils literal"><span class="pre">DEBUG</span></tt>, <tt class="docutils literal"><span class="pre">INFO</span></tt>, <tt class="docutils literal"><span class="pre">WARNING</span></tt>,
<tt class="docutils literal"><span class="pre">ERROR</span></tt> and <tt class="docutils literal"><span class="pre">CRITICAL</span></tt>. As a convenience, you indicate the
importance of a logged message by calling an appropriate method of
<tt class="docutils literal"><span class="pre">Logger</span></tt>. The methods are <tt class="docutils literal"><span class="pre">debug()</span></tt>, <tt class="docutils literal"><span class="pre">info()</span></tt>, <tt class="docutils literal"><span class="pre">warning()</span></tt>,
<tt class="docutils literal"><span class="pre">error()</span></tt> and <tt class="docutils literal"><span class="pre">critical()</span></tt>, which mirror the default levels. You
are not constrained to use these levels: you can specify your own and
use a more general <tt class="docutils literal"><span class="pre">Logger</span></tt> method, <tt class="docutils literal"><span class="pre">log()</span></tt>, which takes an
explicit level argument.</p>
<div class="section" id="logging-tutorial">
<h2>15.5.1. Logging tutorial<a class="headerlink" href="#logging-tutorial" title="Permalink to this headline">¶</a></h2>
<p>The key benefit of having the logging API provided by a standard
library module is that all Python modules can participate in logging,
so your application log can include messages from third-party modules.</p>
<p>It is, of course, possible to log messages with different verbosity
levels or to different destinations.  Support for writing log messages
to files, HTTP GET/POST locations, email via SMTP, generic sockets, or
OS-specific logging mechanisms are all supported by the standard
module.  You can also create your own log destination class if you
have special requirements not met by any of the built-in classes.</p>
<div class="section" id="simple-examples">
<h3>15.5.1.1. Simple examples<a class="headerlink" href="#simple-examples" title="Permalink to this headline">¶</a></h3>
<p>Most applications are probably going to want to log to a file, so
let&#8217;s start with that case. Using the <tt class="docutils literal"><span class="pre">basicConfig()</span></tt> function, we
can set up the default handler so that debug messages are written to a
file:</p>
<blockquote>
<p>import logging
LOG_FILENAME = &#8216;/tmp/logging_example.out&#8217;
logging.basicConfig(filename=LOG_FILENAME,level=logging.DEBUG,)</p>
<p>logging.debug(&#8216;This message should go to the log file&#8217;)</p>
</blockquote>
<p>And now if we open the file and look at what we have, we should find
the log message:</p>
<blockquote>
DEBUG:root:This message should go to the log file</blockquote>
<p>If you run the script repeatedly, the additional log messages are
appended to the file.  To create a new file each time, you can pass a
<em>filemode</em> argument to <tt class="docutils literal"><span class="pre">basicConfig()</span></tt> with a value of <tt class="docutils literal"><span class="pre">'w'</span></tt>.
Rather than managing the file size yourself, though, it is simpler to
use a <tt class="docutils literal"><span class="pre">RotatingFileHandler</span></tt>:</p>
<blockquote>
<p>import glob
import logging
import logging.handlers</p>
<p>LOG_FILENAME = &#8216;/tmp/logging_rotatingfile_example.out&#8217;</p>
<p># Set up a specific logger with our desired output level
my_logger = logging.getLogger(&#8216;MyLogger&#8217;)
my_logger.setLevel(logging.DEBUG)</p>
<p># Add the log message handler to the logger
handler = logging.handlers.RotatingFileHandler(</p>
<blockquote>
LOG_FILENAME, maxBytes=20, backupCount=5)</blockquote>
<p>my_logger.addHandler(handler)</p>
<p># Log some messages
for i in range(20):</p>
<blockquote>
my_logger.debug(&#8216;i = %d&#8217; % i)</blockquote>
<p># See what files are created
logfiles = glob.glob(&#8216;%s*&#8217; % LOG_FILENAME)</p>
<dl class="docutils">
<dt>for filename in logfiles:</dt>
<dd>print filename</dd>
</dl>
</blockquote>
<p>The result should be 6 separate files, each with part of the log
history for the application:</p>
<blockquote>
/tmp/logging_rotatingfile_example.out
/tmp/logging_rotatingfile_example.out.1
/tmp/logging_rotatingfile_example.out.2
/tmp/logging_rotatingfile_example.out.3
/tmp/logging_rotatingfile_example.out.4
/tmp/logging_rotatingfile_example.out.5</blockquote>
<p>The most current file is always
<tt class="docutils literal"><span class="pre">/tmp/logging_rotatingfile_example.out</span></tt>, and each time it reaches
the size limit it is renamed with the suffix <tt class="docutils literal"><span class="pre">.1</span></tt>. Each of the
existing backup files is renamed to increment the suffix (<tt class="docutils literal"><span class="pre">.1</span></tt>
becomes <tt class="docutils literal"><span class="pre">.2</span></tt>, etc.)  and the <tt class="docutils literal"><span class="pre">.6</span></tt> file is erased.</p>
<p>Obviously this example sets the log length much much too small as an
extreme example.  You would want to set <em>maxBytes</em> to an appropriate
value.</p>
<p>Another useful feature of the logging API is the ability to produce
different messages at different log levels.  This allows you to
instrument your code with debug messages, for example, but turning the
log level down so that those debug messages are not written for your
production system.  The default levels are <tt class="docutils literal"><span class="pre">CRITICAL</span></tt>, <tt class="docutils literal"><span class="pre">ERROR</span></tt>,
<tt class="docutils literal"><span class="pre">WARNING</span></tt>, <tt class="docutils literal"><span class="pre">INFO</span></tt>, <tt class="docutils literal"><span class="pre">DEBUG</span></tt> and <tt class="docutils literal"><span class="pre">NOTSET</span></tt>.</p>
<p>The logger, handler, and log message call each specify a level.  The
log message is only emitted if the handler and logger are configured
to emit messages of that level or lower.  For example, if a message is
<tt class="docutils literal"><span class="pre">CRITICAL</span></tt>, and the logger is set to <tt class="docutils literal"><span class="pre">ERROR</span></tt>, the message is
emitted.  If a message is a <tt class="docutils literal"><span class="pre">WARNING</span></tt>, and the logger is set to
produce only <a href="#id1"><span class="problematic" id="id2">``</span></a>ERROR``s, the message is not emitted:</p>
<blockquote>
<p>import logging
import sys</p>
<dl class="docutils">
<dt>LEVELS = {&#8216;debug&#8217;: logging.DEBUG,</dt>
<dd>&#8216;info&#8217;: logging.INFO,
&#8216;warning&#8217;: logging.WARNING,
&#8216;error&#8217;: logging.ERROR,
&#8216;critical&#8217;: logging.CRITICAL}</dd>
<dt>if len(sys.argv) &gt; 1:</dt>
<dd>level_name = sys.argv[1]
level = LEVELS.get(level_name, logging.NOTSET)
logging.basicConfig(level=level)</dd>
</dl>
<p>logging.debug(&#8216;This is a debug message&#8217;)
logging.info(&#8216;This is an info message&#8217;)
logging.warning(&#8216;This is a warning message&#8217;)
logging.error(&#8216;This is an error message&#8217;)
logging.critical(&#8216;This is a critical error message&#8217;)</p>
</blockquote>
<p>Run the script with an argument like &#8216;debug&#8217; or &#8216;warning&#8217; to see which
messages show up at different levels:</p>
<blockquote>
<p>$ python logging_level_example.py debug
DEBUG:root:This is a debug message
INFO:root:This is an info message
WARNING:root:This is a warning message
ERROR:root:This is an error message
CRITICAL:root:This is a critical error message</p>
<p>$ python logging_level_example.py info
<a class="reference external" href="INFO:root:This">INFO:root:This</a> is an info message
WARNING:root:This is a warning message
ERROR:root:This is an error message
CRITICAL:root:This is a critical error message</p>
</blockquote>
<p>You will notice that these log messages all have <tt class="docutils literal"><span class="pre">root</span></tt> embedded in
them.  The logging module supports a hierarchy of loggers with
different names.  An easy way to tell where a specific log message
comes from is to use a separate logger object for each of your
modules.  Each new logger &#8220;inherits&#8221; the configuration of its parent,
and log messages sent to a logger include the name of that logger.
Optionally, each logger can be configured differently, so that
messages from different modules are handled in different ways.  Let&#8217;s
look at a simple example of how to log from different modules so it is
easy to trace the source of the message:</p>
<blockquote>
<p>import logging</p>
<p>logging.basicConfig(level=logging.WARNING)</p>
<p>logger1 = logging.getLogger(&#8216;package1.module1&#8217;)
logger2 = logging.getLogger(&#8216;package2.module2&#8217;)</p>
<p>logger1.warning(&#8216;This message comes from one module&#8217;)
logger2.warning(&#8216;And this message comes from another module&#8217;)</p>
</blockquote>
<p>And the output:</p>
<blockquote>
$ python logging_modules_example.py
WARNING:package1.module1:This message comes from one module
WARNING:package2.module2:And this message comes from another module</blockquote>
<p>There are many more options for configuring logging, including
different log message formatting options, having messages delivered to
multiple destinations, and changing the configuration of a long-
running application on the fly using a socket interface.  All of these
options are covered in depth in the library module documentation.</p>
</div>
<div class="section" id="loggers">
<h3>15.5.1.2. Loggers<a class="headerlink" href="#loggers" title="Permalink to this headline">¶</a></h3>
<p>The logging library takes a modular approach and offers the several
categories of components: loggers, handlers, filters, and formatters.
Loggers expose the interface that application code directly uses.
Handlers send the log records to the appropriate destination. Filters
provide a finer grained facility for determining which log records to
send on to a handler.  Formatters specify the layout of the resultant
log record.</p>
<p><tt class="docutils literal"><span class="pre">Logger</span></tt> objects have a threefold job.  First, they expose several
methods to application code so that applications can log messages at
runtime. Second, logger objects determine which log messages to act
upon based upon severity (the default filtering facility) or filter
objects.  Third, logger objects pass along relevant log messages to
all interested log handlers.</p>
<p>The most widely used methods on logger objects fall into two
categories: configuration and message sending.</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">Logger.setLevel()</span></tt> specifies the lowest-severity log message a
logger will handle, where debug is the lowest built-in severity
level and critical is the highest built-in severity.  For example,
if the severity level is info, the logger will handle only info,
warning, error, and critical messages and will ignore debug
messages.</li>
<li><tt class="docutils literal"><span class="pre">Logger.addFilter()</span></tt> and <tt class="docutils literal"><span class="pre">Logger.removeFilter()</span></tt> add and remove
filter objects from the logger object.  This tutorial does not
address filters.</li>
</ul>
<p>With the logger object configured, the following methods create log
messages:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">Logger.debug()</span></tt>, <tt class="docutils literal"><span class="pre">Logger.info()</span></tt>, <tt class="docutils literal"><span class="pre">Logger.warning()</span></tt>,
<tt class="docutils literal"><span class="pre">Logger.error()</span></tt>, and <tt class="docutils literal"><span class="pre">Logger.critical()</span></tt> all create log records
with a message and a level that corresponds to their respective
method names. The message is actually a format string, which may
contain the standard string substitution syntax of <tt class="docutils literal"><span class="pre">%s</span></tt>, <tt class="docutils literal"><span class="pre">%d</span></tt>,
<tt class="docutils literal"><span class="pre">%f</span></tt>, and so on.  The rest of their arguments is a list of objects
that correspond with the substitution fields in the message.  With
regard to <tt class="docutils literal"><span class="pre">**kwargs</span></tt>, the logging methods care only about a
keyword of <tt class="docutils literal"><span class="pre">exc_info</span></tt> and use it to determine whether to log
exception information.</li>
<li><tt class="docutils literal"><span class="pre">Logger.exception()</span></tt> creates a log message similar to
<tt class="docutils literal"><span class="pre">Logger.error()</span></tt>.  The difference is that <tt class="docutils literal"><span class="pre">Logger.exception()</span></tt>
dumps a stack trace along with it.  Call this method only from an
exception handler.</li>
<li><tt class="docutils literal"><span class="pre">Logger.log()</span></tt> takes a log level as an explicit argument.  This is
a little more verbose for logging messages than using the log level
convenience methods listed above, but this is how to log at custom
log levels.</li>
</ul>
<p><tt class="docutils literal"><span class="pre">getLogger()</span></tt> returns a reference to a logger instance with the
specified if it it is provided, or <tt class="docutils literal"><span class="pre">root</span></tt> if not.  The names are
period-separated hierarchical structures.  Multiple calls to
<tt class="docutils literal"><span class="pre">getLogger()</span></tt> with the same name will return a reference to the same
logger object.  Loggers that are further down in the hierarchical list
are children of loggers higher up in the list. For example, given a
logger with a name of <tt class="docutils literal"><span class="pre">foo</span></tt>, loggers with names of <tt class="docutils literal"><span class="pre">foo.bar</span></tt>,
<tt class="docutils literal"><span class="pre">foo.bar.baz</span></tt>, and <tt class="docutils literal"><span class="pre">foo.bam</span></tt> are all children of <tt class="docutils literal"><span class="pre">foo</span></tt>. Child
loggers propagate messages up to their parent loggers.  Because of
this, it is unnecessary to define and configure all the loggers an
application uses. It is sufficient to configure a top-level logger and
create child loggers as needed.</p>
</div>
<div class="section" id="handlers">
<h3>15.5.1.3. Handlers<a class="headerlink" href="#handlers" title="Permalink to this headline">¶</a></h3>
<p><tt class="docutils literal"><span class="pre">Handler</span></tt> objects are responsible for dispatching the appropriate
log messages (based on the log messages&#8217; severity) to the handler&#8217;s
specified destination.  Logger objects can add zero or more handler
objects to themselves with an <tt class="docutils literal"><span class="pre">addHandler()</span></tt> method.  As an example
scenario, an application may want to send all log messages to a log
file, all log messages of error or higher to stdout, and all messages
of critical to an email address.  This scenario requires three
individual handlers where each handler is responsible for sending
messages of a specific severity to a specific location.</p>
<p>The standard library includes quite a few handler types; this tutorial
uses only <tt class="docutils literal"><span class="pre">StreamHandler</span></tt> and <tt class="docutils literal"><span class="pre">FileHandler</span></tt> in its examples.</p>
<p>There are very few methods in a handler for application developers to
concern themselves with.  The only handler methods that seem relevant
for application developers who are using the built-in handler objects
(that is, not creating custom handlers) are the following
configuration methods:</p>
<ul class="simple">
<li>The <tt class="docutils literal"><span class="pre">Handler.setLevel()</span></tt> method, just as in logger objects,
specifies the lowest severity that will be dispatched to the
appropriate destination.  Why are there two <tt class="docutils literal"><span class="pre">setLevel()</span></tt> methods?
The level set in the logger determines which severity of messages it
will pass to its handlers.  The level set in each handler determines
which messages that handler will send on. <tt class="docutils literal"><span class="pre">setFormatter()</span></tt> selects
a Formatter object for this handler to use.</li>
<li><tt class="docutils literal"><span class="pre">addFilter()</span></tt> and <tt class="docutils literal"><span class="pre">removeFilter()</span></tt> respectively configure and
deconfigure filter objects on handlers.</li>
</ul>
<p>Application code should not directly instantiate and use handlers.
Instead, the <tt class="docutils literal"><span class="pre">Handler</span></tt> class is a base class that defines the
interface that all Handlers should have and establishes some default
behavior that child classes can use (or override).</p>
</div>
<div class="section" id="formatters">
<h3>15.5.1.4. Formatters<a class="headerlink" href="#formatters" title="Permalink to this headline">¶</a></h3>
<p>Formatter objects configure the final order, structure, and contents
of the log message.  Unlike the base <tt class="docutils literal"><span class="pre">logging.Handler</span></tt> class,
application code may instantiate formatter classes, although you could
likely subclass the formatter if your application needs special
behavior.  The constructor takes two optional arguments: a message
format string and a date format string.  If there is no message format
string, the default is to use the raw message.  If there is no date
format string, the default date format is:</p>
<blockquote>
%Y-%m-%d %H:%M:%S</blockquote>
<p>with the milliseconds tacked on at the end.</p>
<p>The message format string uses <tt class="docutils literal"><span class="pre">%(&lt;dictionary</span> <span class="pre">key&gt;)s</span></tt> styled string
substitution; the possible keys are documented in <em>Formatter Objects</em>.</p>
<p>The following message format string will log the time in a human-
readable format, the severity of the message, and the contents of the
message, in that order:</p>
<blockquote>
&#8220;%(asctime)s - %(levelname)s - %(message)s&#8221;</blockquote>
</div>
<div class="section" id="configuring-logging">
<h3>15.5.1.5. Configuring Logging<a class="headerlink" href="#configuring-logging" title="Permalink to this headline">¶</a></h3>
<p>Programmers can configure logging either by creating loggers,
handlers, and formatters explicitly in a main module with the
configuration methods listed above (using Python code), or by creating
a logging config file.  The following code is an example of
configuring a very simple logger, a console handler, and a simple
formatter in a Python module:</p>
<blockquote>
<p>import logging</p>
<p># create logger
logger = logging.getLogger(&#8220;simple_example&#8221;)
logger.setLevel(logging.DEBUG)
# create console handler and set level to debug
ch = logging.StreamHandler()
ch.setLevel(logging.DEBUG)
# create formatter
formatter = logging.Formatter(&#8220;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#8221;)
# add formatter to ch
ch.setFormatter(formatter)
# add ch to logger
logger.addHandler(ch)</p>
<p># &#8220;application&#8221; code
logger.debug(&#8220;debug message&#8221;)
logger.info(&#8220;info message&#8221;)
logger.warn(&#8220;warn message&#8221;)
logger.error(&#8220;error message&#8221;)
logger.critical(&#8220;critical message&#8221;)</p>
</blockquote>
<p>Running this module from the command line produces the following
output:</p>
<blockquote>
$ python simple_logging_module.py
2005-03-19 15:10:26,618 - simple_example - DEBUG - debug message
2005-03-19 15:10:26,620 - simple_example - INFO - info message
2005-03-19 15:10:26,695 - simple_example - WARNING - warn message
2005-03-19 15:10:26,697 - simple_example - ERROR - error message
2005-03-19 15:10:26,773 - simple_example - CRITICAL - critical message</blockquote>
<p>The following Python module creates a logger, handler, and formatter
nearly identical to those in the example listed above, with the only
difference being the names of the objects:</p>
<blockquote>
<p>import logging
import logging.config</p>
<p>logging.config.fileConfig(&#8220;logging.conf&#8221;)</p>
<p># create logger
logger = logging.getLogger(&#8220;simpleExample&#8221;)</p>
<p># &#8220;application&#8221; code
logger.debug(&#8220;debug message&#8221;)
logger.info(&#8220;info message&#8221;)
logger.warn(&#8220;warn message&#8221;)
logger.error(&#8220;error message&#8221;)
logger.critical(&#8220;critical message&#8221;)</p>
</blockquote>
<p>Here is the logging.conf file:</p>
<blockquote>
<p>[loggers]
keys=root,simpleExample</p>
<p>[handlers]
keys=consoleHandler</p>
<p>[formatters]
keys=simpleFormatter</p>
<p>[logger_root]
level=DEBUG
handlers=consoleHandler</p>
<p>[logger_simpleExample]
level=DEBUG
handlers=consoleHandler
qualname=simpleExample
propagate=0</p>
<p>[handler_consoleHandler]
class=StreamHandler
level=DEBUG
formatter=simpleFormatter
args=(sys.stdout,)</p>
<p>[formatter_simpleFormatter]
format=%(asctime)s - %(name)s - %(levelname)s - %(message)s
datefmt=</p>
</blockquote>
<p>The output is nearly identical to that of the non-config-file-based
example:</p>
<blockquote>
$ python simple_logging_config.py
2005-03-19 15:38:55,977 - simpleExample - DEBUG - debug message
2005-03-19 15:38:55,979 - simpleExample - INFO - info message
2005-03-19 15:38:56,054 - simpleExample - WARNING - warn message
2005-03-19 15:38:56,055 - simpleExample - ERROR - error message
2005-03-19 15:38:56,130 - simpleExample - CRITICAL - critical message</blockquote>
<p>You can see that the config file approach has a few advantages over
the Python code approach, mainly separation of configuration and code
and the ability of noncoders to easily modify the logging properties.</p>
</div>
<div class="section" id="configuring-logging-for-a-library">
<h3>15.5.1.6. Configuring Logging for a Library<a class="headerlink" href="#configuring-logging-for-a-library" title="Permalink to this headline">¶</a></h3>
<p>When developing a library which uses logging, some consideration needs
to be given to its configuration. If the using application does not
use logging, and library code makes logging calls, then a one-off
message &#8220;No handlers could be found for logger X.Y.Z&#8221; is printed to
the console. This message is intended to catch mistakes in logging
configuration, but will confuse an application developer who is not
aware of logging by the library.</p>
<p>In addition to documenting how a library uses logging, a good way to
configure library logging so that it does not cause a spurious message
is to add a handler which does nothing. This avoids the message being
printed, since a handler will be found: it just doesn&#8217;t produce any
output. If the library user configures logging for application use,
presumably that configuration will add some handlers, and if levels
are suitably configured then logging calls made in library code will
send output to those handlers, as normal.</p>
<p>A do-nothing handler can be simply defined as follows:</p>
<blockquote>
<p>import logging</p>
<dl class="docutils">
<dt>class NullHandler(logging.Handler):</dt>
<dd><dl class="first last docutils">
<dt>def emit(self, record):</dt>
<dd>pass</dd>
</dl>
</dd>
</dl>
</blockquote>
<p>An instance of this handler should be added to the top-level logger of
the logging namespace used by the library. If all logging by a library
<em>foo</em> is done using loggers with names matching &#8220;foo.x.y&#8221;, then the
code:</p>
<blockquote>
<p>import logging</p>
<p>h = NullHandler()
logging.getLogger(&#8220;foo&#8221;).addHandler(h)</p>
</blockquote>
<p>should have the desired effect. If an organisation produces a number
of libraries, then the logger name specified can be &#8220;orgname.foo&#8221;
rather than just &#8220;foo&#8221;.</p>
</div>
</div>
<div class="section" id="logging-levels">
<h2>15.5.2. Logging Levels<a class="headerlink" href="#logging-levels" title="Permalink to this headline">¶</a></h2>
<p>The numeric values of logging levels are given in the following table.
These are primarily of interest if you want to define your own levels,
and need them to have specific values relative to the predefined
levels. If you define a level with the same numeric value, it
overwrites the predefined value; the predefined name is lost.</p>
<table border="1" class="docutils">
<colgroup>
<col width="48%" />
<col width="52%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Level</th>
<th class="head">Numeric value</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal"><span class="pre">CRITICAL</span></tt></td>
<td>50</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">ERROR</span></tt></td>
<td>40</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">WARNING</span></tt></td>
<td>30</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">INFO</span></tt></td>
<td>20</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">DEBUG</span></tt></td>
<td>10</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">NOTSET</span></tt></td>
<td>0</td>
</tr>
</tbody>
</table>
<p>Levels can also be associated with loggers, being set either by the
developer or through loading a saved logging configuration. When a
logging method is called on a logger, the logger compares its own
level with the level associated with the method call. If the logger&#8217;s
level is higher than the method call&#8217;s, no logging message is actually
generated. This is the basic mechanism controlling the verbosity of
logging output.</p>
<p>Logging messages are encoded as instances of the <tt class="docutils literal"><span class="pre">LogRecord</span></tt> class.
When a logger decides to actually log an event, a <tt class="docutils literal"><span class="pre">LogRecord</span></tt>
instance is created from the logging message.</p>
<p>Logging messages are subjected to a dispatch mechanism through the use
of <em>handlers</em>, which are instances of subclasses of the <tt class="docutils literal"><span class="pre">Handler</span></tt>
class. Handlers are responsible for ensuring that a logged message (in
the form of a <tt class="docutils literal"><span class="pre">LogRecord</span></tt>) ends up in a particular location (or set
of locations) which is useful for the target audience for that message
(such as end users, support desk staff, system administrators,
developers). Handlers are passed <tt class="docutils literal"><span class="pre">LogRecord</span></tt> instances intended for
particular destinations. Each logger can have zero, one or more
handlers associated with it (via the <tt class="docutils literal"><span class="pre">addHandler()</span></tt> method of
<tt class="docutils literal"><span class="pre">Logger</span></tt>). In addition to any handlers directly associated with a
logger, <em>all handlers associated with all ancestors of the logger</em> are
called to dispatch the message.</p>
<p>Just as for loggers, handlers can have levels associated with them. A
handler&#8217;s level acts as a filter in the same way as a logger&#8217;s level
does. If a handler decides to actually dispatch an event, the
<tt class="docutils literal"><span class="pre">emit()</span></tt> method is used to send the message to its destination. Most
user-defined subclasses of <tt class="docutils literal"><span class="pre">Handler</span></tt> will need to override this
<tt class="docutils literal"><span class="pre">emit()</span></tt>.</p>
<p>In addition to the base <tt class="docutils literal"><span class="pre">Handler</span></tt> class, many useful subclasses are
provided:</p>
<ol class="arabic simple">
<li><tt class="docutils literal"><span class="pre">StreamHandler</span></tt> instances send error messages to streams (file-
like objects).</li>
<li><tt class="docutils literal"><span class="pre">FileHandler</span></tt> instances send error messages to disk files.</li>
<li><tt class="docutils literal"><span class="pre">handlers.BaseRotatingHandler</span></tt> is the base class for handlers
that rotate log files at a certain point. It is not meant to be
instantiated directly. Instead, use <tt class="docutils literal"><span class="pre">RotatingFileHandler</span></tt> or
<tt class="docutils literal"><span class="pre">TimedRotatingFileHandler</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">handlers.RotatingFileHandler</span></tt> instances send error messages to
disk files, with support for maximum log file sizes and log file
rotation.</li>
<li><tt class="docutils literal"><span class="pre">handlers.TimedRotatingFileHandler</span></tt> instances send error messages
to disk files rotating the log file at certain timed intervals.</li>
<li><tt class="docutils literal"><span class="pre">handlers.SocketHandler</span></tt> instances send error messages to TCP/IP
sockets.</li>
<li><tt class="docutils literal"><span class="pre">handlers.DatagramHandler</span></tt> instances send error messages to UDP
sockets.</li>
<li><tt class="docutils literal"><span class="pre">handlers.SMTPHandler</span></tt> instances send error messages to a
designated email address.</li>
<li><tt class="docutils literal"><span class="pre">handlers.SysLogHandler</span></tt> instances send error messages to a Unix
syslog daemon, possibly on a remote machine.</li>
<li><tt class="docutils literal"><span class="pre">handlers.NTEventLogHandler</span></tt> instances send error messages to a
Windows NT/2000/XP event log.</li>
<li><tt class="docutils literal"><span class="pre">handlers.MemoryHandler</span></tt> instances send error messages to a
buffer in memory, which is flushed whenever specific criteria are
met.</li>
<li><tt class="docutils literal"><span class="pre">handlers.HTTPHandler</span></tt> instances send error messages to an HTTP
server using either <tt class="docutils literal"><span class="pre">GET</span></tt> or <tt class="docutils literal"><span class="pre">POST</span></tt> semantics.</li>
</ol>
<p>#. <tt class="docutils literal"><span class="pre">handlers.WatchedFileHandler</span></tt> instances watch the file they are
logging to. If the file changes, it is closed and reopened using the
file name. This handler is only useful on Unix-like systems; Windows
does not support the underlying mechanism used.</p>
<p>The <tt class="docutils literal"><span class="pre">StreamHandler</span></tt> and <tt class="docutils literal"><span class="pre">FileHandler</span></tt> classes are defined in the
core logging package. The other handlers are defined in a sub- module,
<tt class="docutils literal"><span class="pre">logging.handlers</span></tt>. (There is also another sub-module,
<tt class="docutils literal"><span class="pre">logging.config</span></tt>, for configuration functionality.)</p>
<p>Logged messages are formatted for presentation through instances of
the <tt class="docutils literal"><span class="pre">Formatter</span></tt> class. They are initialized with a format string
suitable for use with the % operator and a dictionary.</p>
<p>For formatting multiple messages in a batch, instances of
<tt class="docutils literal"><span class="pre">BufferingFormatter</span></tt> can be used. In addition to the format string
(which is applied to each message in the batch), there is provision
for header and trailer format strings.</p>
<p>When filtering based on logger level and/or handler level is not
enough, instances of <tt class="docutils literal"><span class="pre">Filter</span></tt> can be added to both <tt class="docutils literal"><span class="pre">Logger</span></tt> and
<tt class="docutils literal"><span class="pre">Handler</span></tt> instances (through their <tt class="docutils literal"><span class="pre">addFilter()</span></tt> method). Before
deciding to process a message further, both loggers and handlers
consult all their filters for permission. If any filter returns a
false value, the message is not processed further.</p>
<p>The basic <tt class="docutils literal"><span class="pre">Filter</span></tt> functionality allows filtering by specific logger
name. If this feature is used, messages sent to the named logger and
its children are allowed through the filter, and all others dropped.</p>
<p>In addition to the classes described above, there are a number of
module- level functions.</p>
<p>logging.getLogger([name])</p>
<blockquote>
<p>Return a logger with the specified name or, if no name is
specified, return a logger which is the root logger of the
hierarchy. If specified, the name is typically a dot-separated
hierarchical name like <em>&#8220;a&#8221;</em>, <em>&#8220;a.b&#8221;</em> or <em>&#8220;a.b.c.d&#8221;</em>. Choice of
these names is entirely up to the developer who is using logging.</p>
<p>All calls to this function with a given name return the same logger
instance. This means that logger instances never need to be passed
between different parts of an application.</p>
</blockquote>
<p>logging.getLoggerClass()</p>
<blockquote>
<p>Return either the standard <tt class="docutils literal"><span class="pre">Logger</span></tt> class, or the last class
passed to <tt class="docutils literal"><span class="pre">setLoggerClass()</span></tt>. This function may be called from
within a new class definition, to ensure that installing a
customised <tt class="docutils literal"><span class="pre">Logger</span></tt> class will not undo customisations already
applied by other code. For example:</p>
<blockquote>
<dl class="docutils">
<dt>class MyLogger(logging.getLoggerClass()):</dt>
<dd># ... override behaviour here</dd>
</dl>
</blockquote>
</blockquote>
<p>logging.debug(msg[, <a href="#id3"><span class="problematic" id="id4">*</span></a>args[, <a href="#id5"><span class="problematic" id="id6">**</span></a>kwargs]])</p>
<blockquote>
<p>Logs a message with level <tt class="docutils literal"><span class="pre">DEBUG</span></tt> on the root logger. The <em>msg</em>
is the message format string, and the <em>args</em> are the arguments
which are merged into <em>msg</em> using the string formatting operator.
(Note that this means that you can use keywords in the format
string, together with a single dictionary argument.)</p>
<p>There are two keyword arguments in <em>kwargs</em> which are inspected:
<em>exc_info</em> which, if it does not evaluate as false, causes
exception information to be added to the logging message. If an
exception tuple (in the format returned by <tt class="docutils literal"><span class="pre">sys.exc_info()</span></tt>) is
provided, it is used; otherwise, <tt class="docutils literal"><span class="pre">sys.exc_info()</span></tt> is called to
get the exception information.</p>
<p>The other optional keyword argument is <em>extra</em> which can be used to
pass a dictionary which is used to populate the __dict__ of the
LogRecord created for the logging event with user-defined
attributes. These custom attributes can then be used as you like.
For example, they could be incorporated into logged messages. For
example:</p>
<blockquote>
FORMAT = &#8220;%(asctime)-15s %(clientip)s %(user)-8s %(message)s&#8221;
logging.basicConfig(format=FORMAT)
d = {&#8216;clientip&#8217;: &#8216;192.168.0.1&#8217;, &#8216;user&#8217;: &#8216;fbloggs&#8217;}
logging.warning(&#8220;Protocol problem: %s&#8221;, &#8220;connection reset&#8221;, extra=d)</blockquote>
<p>would print something like</p>
<blockquote>
2006-02-08 22:20:02,165 192.168.0.1 fbloggs  Protocol problem: connection reset</blockquote>
<p>The keys in the dictionary passed in <em>extra</em> should not clash with
the keys used by the logging system. (See the <tt class="docutils literal"><span class="pre">Formatter</span></tt>
documentation for more information on which keys are used by the
logging system.)</p>
<p>If you choose to use these attributes in logged messages, you need
to exercise some care. In the above example, for instance, the
<tt class="docutils literal"><span class="pre">Formatter</span></tt> has been set up with a format string which expects
&#8216;clientip&#8217; and &#8216;user&#8217; in the attribute dictionary of the LogRecord.
If these are missing, the message will not be logged because a
string formatting exception will occur. So in this case, you always
need to pass the <em>extra</em> dictionary with these keys.</p>
<p>While this might be annoying, this feature is intended for use in
specialized circumstances, such as multi-threaded servers where the
same code executes in many contexts, and interesting conditions
which arise are dependent on this context (such as remote client IP
address and authenticated user name, in the above example). In such
circumstances, it is likely that specialized <a href="#id7"><span class="problematic" id="id8">``</span></a>Formatter``s would
be used with particular <a href="#id9"><span class="problematic" id="id10">``</span></a>Handler``s.</p>
<p>Changed in version 2.5: <em>extra</em> was added.</p>
</blockquote>
<p>logging.info(msg[, <a href="#id11"><span class="problematic" id="id12">*</span></a>args[, <a href="#id13"><span class="problematic" id="id14">**</span></a>kwargs]])</p>
<blockquote>
Logs a message with level <tt class="docutils literal"><span class="pre">INFO</span></tt> on the root logger. The
arguments are interpreted as for <tt class="docutils literal"><span class="pre">debug()</span></tt>.</blockquote>
<p>logging.warning(msg[, <a href="#id15"><span class="problematic" id="id16">*</span></a>args[, <a href="#id17"><span class="problematic" id="id18">**</span></a>kwargs]])</p>
<blockquote>
Logs a message with level <tt class="docutils literal"><span class="pre">WARNING</span></tt> on the root logger. The
arguments are interpreted as for <tt class="docutils literal"><span class="pre">debug()</span></tt>.</blockquote>
<p>logging.error(msg[, <a href="#id19"><span class="problematic" id="id20">*</span></a>args[, <a href="#id21"><span class="problematic" id="id22">**</span></a>kwargs]])</p>
<blockquote>
Logs a message with level <tt class="docutils literal"><span class="pre">ERROR</span></tt> on the root logger. The
arguments are interpreted as for <tt class="docutils literal"><span class="pre">debug()</span></tt>.</blockquote>
<p>logging.critical(msg[, <a href="#id23"><span class="problematic" id="id24">*</span></a>args[, <a href="#id25"><span class="problematic" id="id26">**</span></a>kwargs]])</p>
<blockquote>
Logs a message with level <tt class="docutils literal"><span class="pre">CRITICAL</span></tt> on the root logger. The
arguments are interpreted as for <tt class="docutils literal"><span class="pre">debug()</span></tt>.</blockquote>
<p>logging.exception(msg[, <a href="#id27"><span class="problematic" id="id28">*</span></a>args])</p>
<blockquote>
Logs a message with level <tt class="docutils literal"><span class="pre">ERROR</span></tt> on the root logger. The
arguments are interpreted as for <tt class="docutils literal"><span class="pre">debug()</span></tt>. Exception info is
added to the logging message. This function should only be called
from an exception handler.</blockquote>
<p>logging.log(level, msg[, <a href="#id29"><span class="problematic" id="id30">*</span></a>args[, <a href="#id31"><span class="problematic" id="id32">**</span></a>kwargs]])</p>
<blockquote>
Logs a message with level <em>level</em> on the root logger. The other
arguments are interpreted as for <tt class="docutils literal"><span class="pre">debug()</span></tt>.</blockquote>
<p>logging.disable(lvl)</p>
<blockquote>
Provides an overriding level <em>lvl</em> for all loggers which takes
precedence over the logger&#8217;s own level. When the need arises to
temporarily throttle logging output down across the whole
application, this function can be useful.</blockquote>
<p>logging.addLevelName(lvl, levelName)</p>
<blockquote>
Associates level <em>lvl</em> with text <em>levelName</em> in an internal
dictionary, which is used to map numeric levels to a textual
representation, for example when a <tt class="docutils literal"><span class="pre">Formatter</span></tt> formats a message.
This function can also be used to define your own levels. The only
constraints are that all levels used must be registered using this
function, levels should be positive integers and they should
increase in increasing order of severity.</blockquote>
<p>logging.getLevelName(lvl)</p>
<blockquote>
Returns the textual representation of logging level <em>lvl</em>. If the
level is one of the predefined levels <tt class="docutils literal"><span class="pre">CRITICAL</span></tt>, <tt class="docutils literal"><span class="pre">ERROR</span></tt>,
<tt class="docutils literal"><span class="pre">WARNING</span></tt>, <tt class="docutils literal"><span class="pre">INFO</span></tt> or <tt class="docutils literal"><span class="pre">DEBUG</span></tt> then you get the corresponding
string. If you have associated levels with names using
<tt class="docutils literal"><span class="pre">addLevelName()</span></tt> then the name you have associated with <em>lvl</em> is
returned. If a numeric value corresponding to one of the defined
levels is passed in, the corresponding string representation is
returned. Otherwise, the string &#8220;Level %s&#8221; % lvl is returned.</blockquote>
<p>logging.makeLogRecord(attrdict)</p>
<blockquote>
Creates and returns a new <tt class="docutils literal"><span class="pre">LogRecord</span></tt> instance whose attributes
are defined by <em>attrdict</em>. This function is useful for taking a
pickled <tt class="docutils literal"><span class="pre">LogRecord</span></tt> attribute dictionary, sent over a socket, and
reconstituting it as a <tt class="docutils literal"><span class="pre">LogRecord</span></tt> instance at the receiving end.</blockquote>
<p>logging.basicConfig([<a href="#id33"><span class="problematic" id="id34">**</span></a>kwargs])</p>
<blockquote>
<p>Does basic configuration for the logging system by creating a
<tt class="docutils literal"><span class="pre">StreamHandler</span></tt> with a default <tt class="docutils literal"><span class="pre">Formatter</span></tt> and adding it to the
root logger. The function does nothing if any handlers have been
defined for the root logger. The functions <tt class="docutils literal"><span class="pre">debug()</span></tt>, <tt class="docutils literal"><span class="pre">info()</span></tt>,
<tt class="docutils literal"><span class="pre">warning()</span></tt>, <tt class="docutils literal"><span class="pre">error()</span></tt> and <tt class="docutils literal"><span class="pre">critical()</span></tt> will call
<tt class="docutils literal"><span class="pre">basicConfig()</span></tt> automatically if no handlers are defined for the
root logger.</p>
<p>This function does nothing if the root logger already has handlers
configured.</p>
<p>Changed in version 2.4: Formerly, <tt class="docutils literal"><span class="pre">basicConfig()</span></tt> did not take
any keyword arguments.</p>
<p>The following keyword arguments are supported.</p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="75%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Format</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal"><span class="pre">filename</span></tt></td>
<td>Specifies that a FileHandler be created,
using the specified filename, rather than a
StreamHandler.</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">filemode</span></tt></td>
<td>Specifies the mode to open the file, if
filename is specified (if filemode is
unspecified, it defaults to &#8216;a&#8217;).</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">format</span></tt></td>
<td>Use the specified format string for the
handler.</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">datefmt</span></tt></td>
<td>Use the specified date/time format.</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">level</span></tt></td>
<td>Set the root logger level to the specified
level.</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">stream</span></tt></td>
<td>Use the specified stream to initialize the
StreamHandler. Note that this argument is
incompatible with &#8216;filename&#8217; - if both are
present, &#8216;stream&#8217; is ignored.</td>
</tr>
</tbody>
</table>
</blockquote>
<p>logging.shutdown()</p>
<blockquote>
Informs the logging system to perform an orderly shutdown by
flushing and closing all handlers. This should be called at
application exit and no further use of the logging system should be
made after this call.</blockquote>
<p>logging.setLoggerClass(klass)</p>
<blockquote>
Tells the logging system to use the class <em>klass</em> when
instantiating a logger. The class should define <tt class="docutils literal"><span class="pre">__init__()</span></tt> such
that only a name argument is required, and the <tt class="docutils literal"><span class="pre">__init__()</span></tt>
should call <tt class="docutils literal"><span class="pre">Logger.__init__()</span></tt>. This function is typically
called before any loggers are instantiated by applications which
need to use custom logger behavior.</blockquote>
<p>See also:</p>
<blockquote>
<dl class="docutils">
<dt><strong>PEP 282</strong> - A Logging System</dt>
<dd>The proposal which described this feature for inclusion in the
Python standard library.</dd>
<dt>Original Python logging package</dt>
<dd>This is the original source for the <tt class="docutils literal"><span class="pre">logging</span></tt> package.  The
version of the package available from this site is suitable for
use with Python 1.5.2, 2.1.x and 2.2.x, which do not include the
<tt class="docutils literal"><span class="pre">logging</span></tt> package in the standard library.</dd>
</dl>
</blockquote>
</div>
<div class="section" id="logger-objects">
<h2>15.5.3. Logger Objects<a class="headerlink" href="#logger-objects" title="Permalink to this headline">¶</a></h2>
<p>Loggers have the following attributes and methods. Note that Loggers
are never instantiated directly, but always through the module-level
function <tt class="docutils literal"><span class="pre">logging.getLogger(name)</span></tt>.</p>
<p>Logger.propagate</p>
<blockquote>
If this evaluates to false, logging messages are not passed by this
logger or by child loggers to higher level (ancestor) loggers. The
constructor sets this attribute to 1.</blockquote>
<p>Logger.setLevel(lvl)</p>
<blockquote>
<p>Sets the threshold for this logger to <em>lvl</em>. Logging messages which
are less severe than <em>lvl</em> will be ignored. When a logger is
created, the level is set to <tt class="docutils literal"><span class="pre">NOTSET</span></tt> (which causes all messages
to be processed when the logger is the root logger, or delegation
to the parent when the logger is a non-root logger). Note that the
root logger is created with level <tt class="docutils literal"><span class="pre">WARNING</span></tt>.</p>
<p>The term &#8220;delegation to the parent&#8221; means that if a logger has a
level of NOTSET, its chain of ancestor loggers is traversed until
either an ancestor with a level other than NOTSET is found, or the
root is reached.</p>
<p>If an ancestor is found with a level other than NOTSET, then that
ancestor&#8217;s level is treated as the effective level of the logger
where the ancestor search began, and is used to determine how a
logging event is handled.</p>
<p>If the root is reached, and it has a level of NOTSET, then all
messages will be processed. Otherwise, the root&#8217;s level will be
used as the effective level.</p>
</blockquote>
<p>Logger.isEnabledFor(lvl)</p>
<blockquote>
Indicates if a message of severity <em>lvl</em> would be processed by this
logger. This method checks first the module-level level set by
<tt class="docutils literal"><span class="pre">logging.disable(lvl)</span></tt> and then the logger&#8217;s effective level as
determined by <tt class="docutils literal"><span class="pre">getEffectiveLevel()</span></tt>.</blockquote>
<p>Logger.getEffectiveLevel()</p>
<blockquote>
Indicates the effective level for this logger. If a value other
than <tt class="docutils literal"><span class="pre">NOTSET</span></tt> has been set using <tt class="docutils literal"><span class="pre">setLevel()</span></tt>, it is returned.
Otherwise, the hierarchy is traversed towards the root until a
value other than <tt class="docutils literal"><span class="pre">NOTSET</span></tt> is found, and that value is returned.</blockquote>
<p>Logger.debug(msg[, <a href="#id35"><span class="problematic" id="id36">*</span></a>args[, <a href="#id37"><span class="problematic" id="id38">**</span></a>kwargs]])</p>
<blockquote>
<p>Logs a message with level <tt class="docutils literal"><span class="pre">DEBUG</span></tt> on this logger. The <em>msg</em> is
the message format string, and the <em>args</em> are the arguments which
are merged into <em>msg</em> using the string formatting operator. (Note
that this means that you can use keywords in the format string,
together with a single dictionary argument.)</p>
<p>There are two keyword arguments in <em>kwargs</em> which are inspected:
<em>exc_info</em> which, if it does not evaluate as false, causes
exception information to be added to the logging message. If an
exception tuple (in the format returned by <tt class="docutils literal"><span class="pre">sys.exc_info()</span></tt>) is
provided, it is used; otherwise, <tt class="docutils literal"><span class="pre">sys.exc_info()</span></tt> is called to
get the exception information.</p>
<p>The other optional keyword argument is <em>extra</em> which can be used to
pass a dictionary which is used to populate the __dict__ of the
LogRecord created for the logging event with user-defined
attributes. These custom attributes can then be used as you like.
For example, they could be incorporated into logged messages. For
example:</p>
<blockquote>
FORMAT = &#8220;%(asctime)-15s %(clientip)s %(user)-8s %(message)s&#8221;
logging.basicConfig(format=FORMAT)
d = { &#8216;clientip&#8217; : &#8216;192.168.0.1&#8217;, &#8216;user&#8217; : &#8216;fbloggs&#8217; }
logger = logging.getLogger(&#8220;tcpserver&#8221;)
logger.warning(&#8220;Protocol problem: %s&#8221;, &#8220;connection reset&#8221;, extra=d)</blockquote>
<p>would print something like</p>
<blockquote>
2006-02-08 22:20:02,165 192.168.0.1 fbloggs  Protocol problem: connection reset</blockquote>
<p>The keys in the dictionary passed in <em>extra</em> should not clash with
the keys used by the logging system. (See the <tt class="docutils literal"><span class="pre">Formatter</span></tt>
documentation for more information on which keys are used by the
logging system.)</p>
<p>If you choose to use these attributes in logged messages, you need
to exercise some care. In the above example, for instance, the
<tt class="docutils literal"><span class="pre">Formatter</span></tt> has been set up with a format string which expects
&#8216;clientip&#8217; and &#8216;user&#8217; in the attribute dictionary of the LogRecord.
If these are missing, the message will not be logged because a
string formatting exception will occur. So in this case, you always
need to pass the <em>extra</em> dictionary with these keys.</p>
<p>While this might be annoying, this feature is intended for use in
specialized circumstances, such as multi-threaded servers where the
same code executes in many contexts, and interesting conditions
which arise are dependent on this context (such as remote client IP
address and authenticated user name, in the above example). In such
circumstances, it is likely that specialized <a href="#id39"><span class="problematic" id="id40">``</span></a>Formatter``s would
be used with particular <a href="#id41"><span class="problematic" id="id42">``</span></a>Handler``s.</p>
<p>Changed in version 2.5: <em>extra</em> was added.</p>
</blockquote>
<p>Logger.info(msg[, <a href="#id43"><span class="problematic" id="id44">*</span></a>args[, <a href="#id45"><span class="problematic" id="id46">**</span></a>kwargs]])</p>
<blockquote>
Logs a message with level <tt class="docutils literal"><span class="pre">INFO</span></tt> on this logger. The arguments
are interpreted as for <tt class="docutils literal"><span class="pre">debug()</span></tt>.</blockquote>
<p>Logger.warning(msg[, <a href="#id47"><span class="problematic" id="id48">*</span></a>args[, <a href="#id49"><span class="problematic" id="id50">**</span></a>kwargs]])</p>
<blockquote>
Logs a message with level <tt class="docutils literal"><span class="pre">WARNING</span></tt> on this logger. The arguments
are interpreted as for <tt class="docutils literal"><span class="pre">debug()</span></tt>.</blockquote>
<p>Logger.error(msg[, <a href="#id51"><span class="problematic" id="id52">*</span></a>args[, <a href="#id53"><span class="problematic" id="id54">**</span></a>kwargs]])</p>
<blockquote>
Logs a message with level <tt class="docutils literal"><span class="pre">ERROR</span></tt> on this logger. The arguments
are interpreted as for <tt class="docutils literal"><span class="pre">debug()</span></tt>.</blockquote>
<p>Logger.critical(msg[, <a href="#id55"><span class="problematic" id="id56">*</span></a>args[, <a href="#id57"><span class="problematic" id="id58">**</span></a>kwargs]])</p>
<blockquote>
Logs a message with level <tt class="docutils literal"><span class="pre">CRITICAL</span></tt> on this logger. The
arguments are interpreted as for <tt class="docutils literal"><span class="pre">debug()</span></tt>.</blockquote>
<p>Logger.log(lvl, msg[, <a href="#id59"><span class="problematic" id="id60">*</span></a>args[, <a href="#id61"><span class="problematic" id="id62">**</span></a>kwargs]])</p>
<blockquote>
Logs a message with integer level <em>lvl</em> on this logger. The other
arguments are interpreted as for <tt class="docutils literal"><span class="pre">debug()</span></tt>.</blockquote>
<p>Logger.exception(msg[, <a href="#id63"><span class="problematic" id="id64">*</span></a>args])</p>
<blockquote>
Logs a message with level <tt class="docutils literal"><span class="pre">ERROR</span></tt> on this logger. The arguments
are interpreted as for <tt class="docutils literal"><span class="pre">debug()</span></tt>. Exception info is added to the
logging message. This method should only be called from an
exception handler.</blockquote>
<p>Logger.addFilter(filt)</p>
<blockquote>
Adds the specified filter <em>filt</em> to this logger.</blockquote>
<p>Logger.removeFilter(filt)</p>
<blockquote>
Removes the specified filter <em>filt</em> from this logger.</blockquote>
<p>Logger.filter(record)</p>
<blockquote>
Applies this logger&#8217;s filters to the record and returns a true
value if the record is to be processed.</blockquote>
<p>Logger.addHandler(hdlr)</p>
<blockquote>
Adds the specified handler <em>hdlr</em> to this logger.</blockquote>
<p>Logger.removeHandler(hdlr)</p>
<blockquote>
Removes the specified handler <em>hdlr</em> from this logger.</blockquote>
<p>Logger.findCaller()</p>
<blockquote>
<p>Finds the caller&#8217;s source filename and line number. Returns the
filename, line number and function name as a 3-element tuple.</p>
<p>Changed in version 2.4: The function name was added. In earlier
versions, the filename and line number were returned as a 2-element
tuple..</p>
</blockquote>
<p>Logger.handle(record)</p>
<blockquote>
Handles a record by passing it to all handlers associated with this
logger and its ancestors (until a false value of <em>propagate</em> is
found). This method is used for unpickled records received from a
socket, as well as those created locally. Logger-level filtering is
applied using <tt class="docutils literal"><span class="pre">filter()</span></tt>.</blockquote>
<p>Logger.makeRecord(name, lvl, fn, lno, msg, args, exc_info[, func, extra])</p>
<blockquote>
<p>This is a factory method which can be overridden in subclasses to
create specialized <tt class="docutils literal"><span class="pre">LogRecord</span></tt> instances.</p>
<p>Changed in version 2.5: <em>func</em> and <em>extra</em> were added.</p>
</blockquote>
</div>
<div class="section" id="basic-example">
<h2>15.5.4. Basic example<a class="headerlink" href="#basic-example" title="Permalink to this headline">¶</a></h2>
<p>Changed in version 2.4: formerly <tt class="docutils literal"><span class="pre">basicConfig()</span></tt> did not take any
keyword arguments.</p>
<p>The <tt class="docutils literal"><span class="pre">logging</span></tt> package provides a lot of flexibility, and its
configuration can appear daunting.  This section demonstrates that
simple use of the logging package is possible.</p>
<p>The simplest example shows logging to the console:</p>
<blockquote>
<p>import logging</p>
<p>logging.debug(&#8216;A debug message&#8217;)
logging.info(&#8216;Some information&#8217;)
logging.warning(&#8216;A shot across the bows&#8217;)</p>
</blockquote>
<p>If you run the above script, you&#8217;ll see this:</p>
<blockquote>
WARNING:root:A shot across the bows</blockquote>
<p>Because no particular logger was specified, the system used the root
logger. The debug and info messages didn&#8217;t appear because by default,
the root logger is configured to only handle messages with a severity
of WARNING or above. The message format is also a configuration
default, as is the output destination of the messages -
<tt class="docutils literal"><span class="pre">sys.stderr</span></tt>. The severity level, the message format and destination
can be easily changed, as shown in the example below:</p>
<blockquote>
<p>import logging</p>
<dl class="docutils">
<dt>logging.basicConfig(level=logging.DEBUG,</dt>
<dd>format=&#8217;%(asctime)s %(levelname)s %(message)s&#8217;,
filename=&#8217;/tmp/myapp.log&#8217;,
filemode=&#8217;w&#8217;)</dd>
</dl>
<p>logging.debug(&#8216;A debug message&#8217;)
logging.info(&#8216;Some information&#8217;)
logging.warning(&#8216;A shot across the bows&#8217;)</p>
</blockquote>
<p>The <tt class="docutils literal"><span class="pre">basicConfig()</span></tt> method is used to change the configuration
defaults, which results in output (written to <tt class="docutils literal"><span class="pre">/tmp/myapp.log</span></tt>)
which should look something like the following:</p>
<blockquote>
2004-07-02 13:00:08,743 DEBUG A debug message
2004-07-02 13:00:08,743 INFO Some information
2004-07-02 13:00:08,743 WARNING A shot across the bows</blockquote>
<p>This time, all messages with a severity of DEBUG or above were
handled, and the format of the messages was also changed, and output
went to the specified file rather than the console.</p>
<p>Formatting uses standard Python string formatting - see section
<em>String Formatting Operations</em>. The format string takes the following
common specifiers. For a complete list of specifiers, consult the
<tt class="docutils literal"><span class="pre">Formatter</span></tt> documentation.</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Format</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal"><span class="pre">%(name)s</span></tt></td>
<td>Name of the logger (logging channel).</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">%(levelname)s</span></tt></td>
<td>Text logging level for the message
(<tt class="docutils literal"><span class="pre">'DEBUG'</span></tt>, <tt class="docutils literal"><span class="pre">'INFO'</span></tt>, <tt class="docutils literal"><span class="pre">'WARNING'</span></tt>,
<tt class="docutils literal"><span class="pre">'ERROR'</span></tt>, <tt class="docutils literal"><span class="pre">'CRITICAL'</span></tt>).</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">%(asctime)s</span></tt></td>
<td>Human-readable time when the <tt class="docutils literal"><span class="pre">LogRecord</span></tt> was
created.  By default this is of the form
&#8220;2003-07-08 16:49:45,896&#8221; (the numbers after
the comma are millisecond portion of the time).</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">%(message)s</span></tt></td>
<td>The logged message.</td>
</tr>
</tbody>
</table>
<p>To change the date/time format, you can pass an additional keyword
parameter, <em>datefmt</em>, as in the following:</p>
<blockquote>
<p>import logging</p>
<dl class="docutils">
<dt>logging.basicConfig(level=logging.DEBUG,</dt>
<dd>format=&#8217;%(asctime)s %(levelname)-8s %(message)s&#8217;,
datefmt=&#8217;%a, %d %b %Y %H:%M:%S&#8217;,
filename=&#8217;/temp/myapp.log&#8217;,
filemode=&#8217;w&#8217;)</dd>
</dl>
<p>logging.debug(&#8216;A debug message&#8217;)
logging.info(&#8216;Some information&#8217;)
logging.warning(&#8216;A shot across the bows&#8217;)</p>
</blockquote>
<p>which would result in output like</p>
<blockquote>
Fri, 02 Jul 2004 13:06:18 DEBUG    A debug message
Fri, 02 Jul 2004 13:06:18 INFO     Some information
Fri, 02 Jul 2004 13:06:18 WARNING  A shot across the bows</blockquote>
<p>The date format string follows the requirements of <tt class="docutils literal"><span class="pre">strftime()</span></tt> -
see the documentation for the <tt class="docutils literal"><span class="pre">time</span></tt> module.</p>
<p>If, instead of sending logging output to the console or a file, you&#8217;d
rather use a file-like object which you have created separately, you
can pass it to <tt class="docutils literal"><span class="pre">basicConfig()</span></tt> using the <em>stream</em> keyword argument.
Note that if both <em>stream</em> and <em>filename</em> keyword arguments are
passed, the <em>stream</em> argument is ignored.</p>
<p>Of course, you can put variable information in your output. To do
this, simply have the message be a format string and pass in
additional arguments containing the variable information, as in the
following example:</p>
<blockquote>
<p>import logging</p>
<dl class="docutils">
<dt>logging.basicConfig(level=logging.DEBUG,</dt>
<dd>format=&#8217;%(asctime)s %(levelname)-8s %(message)s&#8217;,
datefmt=&#8217;%a, %d %b %Y %H:%M:%S&#8217;,
filename=&#8217;/temp/myapp.log&#8217;,
filemode=&#8217;w&#8217;)</dd>
</dl>
<p>logging.error(&#8216;Pack my box with %d dozen %s&#8217;, 5, &#8216;liquor jugs&#8217;)</p>
</blockquote>
<p>which would result in</p>
<blockquote>
Wed, 21 Jul 2004 15:35:16 ERROR    Pack my box with 5 dozen liquor jugs</blockquote>
</div>
<div class="section" id="logging-to-multiple-destinations">
<h2>15.5.5. Logging to multiple destinations<a class="headerlink" href="#logging-to-multiple-destinations" title="Permalink to this headline">¶</a></h2>
<p>Let&#8217;s say you want to log to console and file with different message
formats and in differing circumstances. Say you want to log messages
with levels of DEBUG and higher to file, and those messages at level
INFO and higher to the console. Let&#8217;s also assume that the file should
contain timestamps, but the console messages should not. Here&#8217;s how
you can achieve this:</p>
<blockquote>
<p>import logging</p>
<p># set up logging to file - see previous section for more details
logging.basicConfig(level=logging.DEBUG,</p>
<blockquote>
format=&#8217;%(asctime)s %(name)-12s %(levelname)-8s %(message)s&#8217;,
datefmt=&#8217;%m-%d %H:%M&#8217;,
filename=&#8217;/temp/myapp.log&#8217;,
filemode=&#8217;w&#8217;)</blockquote>
<p># define a Handler which writes INFO messages or higher to the sys.stderr
console = logging.StreamHandler()
console.setLevel(logging.INFO)
# set a format which is simpler for console use
formatter = logging.Formatter(&#8216;%(name)-12s: %(levelname)-8s %(message)s&#8217;)
# tell the handler to use this format
console.setFormatter(formatter)
# add the handler to the root logger
logging.getLogger(&#8216;&#8217;).addHandler(console)</p>
<p># Now, we can log to the root logger, or any other logger. First the root...
logging.info(&#8216;Jackdaws love my big sphinx of quartz.&#8217;)</p>
<p># Now, define a couple of other loggers which might represent areas in your
# application:</p>
<p>logger1 = logging.getLogger(&#8216;myapp.area1&#8217;)
logger2 = logging.getLogger(&#8216;myapp.area2&#8217;)</p>
<p>logger1.debug(&#8216;Quick zephyrs blow, vexing daft Jim.&#8217;)
logger1.info(&#8216;How quickly daft jumping zebras vex.&#8217;)
logger2.warning(&#8216;Jail zesty vixen who grabbed pay from quack.&#8217;)
logger2.error(&#8216;The five boxing wizards jump quickly.&#8217;)</p>
</blockquote>
<p>When you run this, on the console you will see</p>
<blockquote>
root        : INFO     Jackdaws love my big sphinx of quartz.
myapp.area1 : INFO     How quickly daft jumping zebras vex.
myapp.area2 : WARNING  Jail zesty vixen who grabbed pay from quack.
myapp.area2 : ERROR    The five boxing wizards jump quickly.</blockquote>
<p>and in the file you will see something like</p>
<blockquote>
10-22 22:19 root         INFO     Jackdaws love my big sphinx of quartz.
10-22 22:19 myapp.area1  DEBUG    Quick zephyrs blow, vexing daft Jim.
10-22 22:19 myapp.area1  INFO     How quickly daft jumping zebras vex.
10-22 22:19 myapp.area2  WARNING  Jail zesty vixen who grabbed pay from quack.
10-22 22:19 myapp.area2  ERROR    The five boxing wizards jump quickly.</blockquote>
<p>As you can see, the DEBUG message only shows up in the file. The other
messages are sent to both destinations.</p>
<p>This example uses console and file handlers, but you can use any
number and combination of handlers you choose.</p>
</div>
<div class="section" id="adding-contextual-information-to-your-logging-output">
<h2>15.5.6. Adding contextual information to your logging output<a class="headerlink" href="#adding-contextual-information-to-your-logging-output" title="Permalink to this headline">¶</a></h2>
<p>Sometimes you want logging output to contain contextual information in
addition to the parameters passed to the logging call. For example, in
a networked application, it may be desirable to log client-specific
information in the log (e.g. remote client&#8217;s username, or IP address).
Although you could use the <em>extra</em> parameter to achieve this, it&#8217;s not
always convenient to pass the information in this way. While it might
be tempting to create <tt class="docutils literal"><span class="pre">Logger</span></tt> instances on a per-connection basis,
this is not a good idea because these instances are not garbage
collected. While this is not a problem in practice, when the number of
<tt class="docutils literal"><span class="pre">Logger</span></tt> instances is dependent on the level of granularity you want
to use in logging an application, it could be hard to manage if the
number of <tt class="docutils literal"><span class="pre">Logger</span></tt> instances becomes effectively unbounded.</p>
<p>An easy way in which you can pass contextual information to be output
along with logging event information is to use the <tt class="docutils literal"><span class="pre">LoggerAdapter</span></tt>
class. This class is designed to look like a <tt class="docutils literal"><span class="pre">Logger</span></tt>, so that you
can call <tt class="docutils literal"><span class="pre">debug()</span></tt>, <tt class="docutils literal"><span class="pre">info()</span></tt>, <tt class="docutils literal"><span class="pre">warning()</span></tt>, <tt class="docutils literal"><span class="pre">error()</span></tt>,
<tt class="docutils literal"><span class="pre">exception()</span></tt>, <tt class="docutils literal"><span class="pre">critical()</span></tt> and <tt class="docutils literal"><span class="pre">log()</span></tt>. These methods have the
same signatures as their counterparts in <tt class="docutils literal"><span class="pre">Logger</span></tt>, so you can use
the two types of instances interchangeably.</p>
<p>When you create an instance of <tt class="docutils literal"><span class="pre">LoggerAdapter</span></tt>, you pass it a
<tt class="docutils literal"><span class="pre">Logger</span></tt> instance and a dict-like object which contains your
contextual information. When you call one of the logging methods on an
instance of <tt class="docutils literal"><span class="pre">LoggerAdapter</span></tt>, it delegates the call to the underlying
instance of <tt class="docutils literal"><span class="pre">Logger</span></tt> passed to its constructor, and arranges to pass
the contextual information in the delegated call. Here&#8217;s a snippet
from the code of <tt class="docutils literal"><span class="pre">LoggerAdapter</span></tt>:</p>
<blockquote>
<dl class="docutils">
<dt>def debug(self, msg, <a href="#id65"><span class="problematic" id="id66">*</span></a>args, <a href="#id67"><span class="problematic" id="id68">**</span></a>kwargs):</dt>
<dd>&#8220;&#8221;&#8221;
Delegate a debug call to the underlying logger, after adding
contextual information from this adapter instance.
&#8220;&#8221;&#8221;
msg, kwargs = self.process(msg, kwargs)
self.logger.debug(msg, <a href="#id69"><span class="problematic" id="id70">*</span></a>args, <a href="#id71"><span class="problematic" id="id72">**</span></a>kwargs)</dd>
</dl>
</blockquote>
<p>The <tt class="docutils literal"><span class="pre">process()</span></tt> method of <tt class="docutils literal"><span class="pre">LoggerAdapter</span></tt> is where the contextual
information is added to the logging output. It&#8217;s passed the message
and keyword arguments of the logging call, and it passes back
(potentially) modified versions of these to use in the call to the
underlying logger. The default implementation of this method leaves
the message alone, but inserts an &#8220;extra&#8221; key in the keyword argument
whose value is the dict-like object passed to the constructor. Of
course, if you had passed an &#8220;extra&#8221; keyword argument in the call to
the adapter, it will be silently overwritten.</p>
<p>The advantage of using &#8220;extra&#8221; is that the values in the dict-like
object are merged into the <tt class="docutils literal"><span class="pre">LogRecord</span></tt> instance&#8217;s __dict__, allowing
you to use customized strings with your <tt class="docutils literal"><span class="pre">Formatter</span></tt> instances which
know about the keys of the dict-like object. If you need a different
method, e.g. if you want to prepend or append the contextual
information to the message string, you just need to subclass
<tt class="docutils literal"><span class="pre">LoggerAdapter</span></tt> and override <tt class="docutils literal"><span class="pre">process()</span></tt> to do what you need.
Here&#8217;s an example script which uses this class, which also illustrates
what dict-like behaviour is needed from an arbitrary &#8220;dict-like&#8221;
object for use in the constructor:</p>
<blockquote>
<p>import logging</p>
<dl class="docutils">
<dt>class ConnInfo:</dt>
<dd><p class="first">&#8220;&#8221;&#8221;
An example class which shows how an arbitrary class can be used as
the &#8216;extra&#8217; context information repository passed to a LoggerAdapter.
&#8220;&#8221;&#8220;</p>
<dl class="last docutils">
<dt>def __getitem__(self, name):</dt>
<dd><p class="first">&#8220;&#8221;&#8221;
To allow this instance to look like a dict.
&#8220;&#8221;&#8221;
from random import choice
if name == &#8220;ip&#8221;:</p>
<blockquote>
result = choice([&#8220;127.0.0.1&#8221;, &#8220;192.168.0.1&#8221;])</blockquote>
<dl class="docutils">
<dt>elif name == &#8220;user&#8221;:</dt>
<dd>result = choice([&#8220;jim&#8221;, &#8220;fred&#8221;, &#8220;sheila&#8221;])</dd>
<dt>else:</dt>
<dd>result = self.__dict__.get(name, &#8220;?&#8221;)</dd>
</dl>
<p class="last">return result</p>
</dd>
<dt>def __iter__(self):</dt>
<dd>&#8220;&#8221;&#8221;
To allow iteration over keys, which will be merged into
the LogRecord dict before formatting and output.
&#8220;&#8221;&#8221;
keys = [&#8220;ip&#8221;, &#8220;user&#8221;]
keys.extend(self.__dict__.keys())
return keys.__iter__()</dd>
</dl>
</dd>
<dt>if __name__ == &#8220;__main__&#8221;:</dt>
<dd><p class="first">from random import choice
levels = (logging.DEBUG, logging.INFO, logging.WARNING, logging.ERROR, logging.CRITICAL)
a1 = logging.LoggerAdapter(logging.getLogger(&#8220;a.b.c&#8221;),</p>
<blockquote>
{ &#8220;ip&#8221; : &#8220;123.231.231.123&#8221;, &#8220;user&#8221; : &#8220;sheila&#8221; })</blockquote>
<dl class="docutils">
<dt>logging.basicConfig(level=logging.DEBUG,</dt>
<dd>format=&#8221;%(asctime)-15s %(name)-5s %(levelname)-8s IP: %(ip)-15s User: %(user)-8s %(message)s&#8221;)</dd>
</dl>
<p>a1.debug(&#8220;A debug message&#8221;)
a1.info(&#8220;An info message with %s&#8221;, &#8220;some parameters&#8221;)
a2 = logging.LoggerAdapter(logging.getLogger(&#8220;d.e.f&#8221;), ConnInfo())
for x in range(10):</p>
<blockquote class="last">
lvl = choice(levels)
lvlname = logging.getLevelName(lvl)
a2.log(lvl, &#8220;A message at %s level with %d %s&#8221;, lvlname, 2, &#8220;parameters&#8221;)</blockquote>
</dd>
</dl>
</blockquote>
<p>When this script is run, the output should look something like this:</p>
<blockquote>
2008-01-18 14:49:54,023 a.b.c DEBUG    IP: 123.231.231.123 User: sheila   A debug message
2008-01-18 14:49:54,023 a.b.c INFO     IP: 123.231.231.123 User: sheila   An info message with some parameters
2008-01-18 14:49:54,023 d.e.f CRITICAL IP: 192.168.0.1     User: jim      A message at CRITICAL level with 2 parameters
2008-01-18 14:49:54,033 d.e.f INFO     IP: 192.168.0.1     User: jim      A message at INFO level with 2 parameters
2008-01-18 14:49:54,033 d.e.f WARNING  IP: 192.168.0.1     User: sheila   A message at WARNING level with 2 parameters
2008-01-18 14:49:54,033 d.e.f ERROR    IP: 127.0.0.1       User: fred     A message at ERROR level with 2 parameters
2008-01-18 14:49:54,033 d.e.f ERROR    IP: 127.0.0.1       User: sheila   A message at ERROR level with 2 parameters
2008-01-18 14:49:54,033 d.e.f WARNING  IP: 192.168.0.1     User: sheila   A message at WARNING level with 2 parameters
2008-01-18 14:49:54,033 d.e.f WARNING  IP: 192.168.0.1     User: jim      A message at WARNING level with 2 parameters
2008-01-18 14:49:54,033 d.e.f INFO     IP: 192.168.0.1     User: fred     A message at INFO level with 2 parameters
2008-01-18 14:49:54,033 d.e.f WARNING  IP: 192.168.0.1     User: sheila   A message at WARNING level with 2 parameters
2008-01-18 14:49:54,033 d.e.f WARNING  IP: 127.0.0.1       User: jim      A message at WARNING level with 2 parameters</blockquote>
<p>New in version 2.6.</p>
<p>The <tt class="docutils literal"><span class="pre">LoggerAdapter</span></tt> class was not present in previous versions.</p>
</div>
<div class="section" id="sending-and-receiving-logging-events-across-a-network">
<h2>15.5.7. Sending and receiving logging events across a network<a class="headerlink" href="#sending-and-receiving-logging-events-across-a-network" title="Permalink to this headline">¶</a></h2>
<p>Let&#8217;s say you want to send logging events across a network, and handle
them at the receiving end. A simple way of doing this is attaching a
<tt class="docutils literal"><span class="pre">SocketHandler</span></tt> instance to the root logger at the sending end:</p>
<blockquote>
<p>import logging, logging.handlers</p>
<p>rootLogger = logging.getLogger(&#8216;&#8217;)
rootLogger.setLevel(logging.DEBUG)
socketHandler = logging.handlers.SocketHandler(&#8216;localhost&#8217;,</p>
<blockquote>
logging.handlers.DEFAULT_TCP_LOGGING_PORT)</blockquote>
<p># don&#8217;t bother with a formatter, since a socket handler sends the event as
# an unformatted pickle
rootLogger.addHandler(socketHandler)</p>
<p># Now, we can log to the root logger, or any other logger. First the root...
logging.info(&#8216;Jackdaws love my big sphinx of quartz.&#8217;)</p>
<p># Now, define a couple of other loggers which might represent areas in your
# application:</p>
<p>logger1 = logging.getLogger(&#8216;myapp.area1&#8217;)
logger2 = logging.getLogger(&#8216;myapp.area2&#8217;)</p>
<p>logger1.debug(&#8216;Quick zephyrs blow, vexing daft Jim.&#8217;)
logger1.info(&#8216;How quickly daft jumping zebras vex.&#8217;)
logger2.warning(&#8216;Jail zesty vixen who grabbed pay from quack.&#8217;)
logger2.error(&#8216;The five boxing wizards jump quickly.&#8217;)</p>
</blockquote>
<p>At the receiving end, you can set up a receiver using the
<tt class="docutils literal"><span class="pre">SocketServer</span></tt> module. Here is a basic working example:</p>
<blockquote>
<p>import cPickle
import logging
import logging.handlers
import SocketServer
import struct</p>
<dl class="docutils">
<dt>class LogRecordStreamHandler(SocketServer.StreamRequestHandler):</dt>
<dd><p class="first">&#8220;&#8221;&#8220;Handler for a streaming logging request.</p>
<p>This basically logs the record using whatever logging policy is
configured locally.
&#8220;&#8221;&#8220;</p>
<dl class="last docutils">
<dt>def handle(self):</dt>
<dd><p class="first">&#8220;&#8221;&#8221;
Handle multiple requests - each expected to be a 4-byte length,
followed by the LogRecord in pickle format. Logs the record
according to whatever policy is configured locally.
&#8220;&#8221;&#8221;
while 1:</p>
<blockquote class="last">
<p>chunk = self.connection.recv(4)
if len(chunk) &lt; 4:</p>
<blockquote>
break</blockquote>
<p>slen = struct.unpack(&#8220;&gt;L&#8221;, chunk)[0]
chunk = self.connection.recv(slen)
while len(chunk) &lt; slen:</p>
<blockquote>
chunk = chunk + self.connection.recv(slen - len(chunk))</blockquote>
<p>obj = self.unPickle(chunk)
record = logging.makeLogRecord(obj)
self.handleLogRecord(record)</p>
</blockquote>
</dd>
<dt>def unPickle(self, data):</dt>
<dd>return cPickle.loads(data)</dd>
<dt>def handleLogRecord(self, record):</dt>
<dd><p class="first"># if a name is specified, we use the named logger rather than the one
# implied by the record.
if self.server.logname is not None:</p>
<blockquote>
name = self.server.logname</blockquote>
<dl class="docutils">
<dt>else:</dt>
<dd>name = record.name</dd>
</dl>
<p class="last">logger = logging.getLogger(name)
# N.B. EVERY record gets logged. This is because Logger.handle
# is normally called AFTER logger-level filtering. If you want
# to do filtering, do it at the client end to save wasting
# cycles and network bandwidth!
logger.handle(record)</p>
</dd>
</dl>
</dd>
<dt>class LogRecordSocketReceiver(SocketServer.ThreadingTCPServer):</dt>
<dd><p class="first">&#8220;&#8221;&#8220;simple TCP socket-based logging receiver suitable for testing.
&#8220;&#8221;&#8220;</p>
<p>allow_reuse_address = 1</p>
<dl class="last docutils">
<dt>def __init__(self, host=&#8217;localhost&#8217;,</dt>
<dd><blockquote class="first">
port=logging.handlers.DEFAULT_TCP_LOGGING_PORT,
handler=LogRecordStreamHandler):</blockquote>
<p class="last">SocketServer.ThreadingTCPServer.__init__(self, (host, port), handler)
self.abort = 0
self.timeout = 1
self.logname = None</p>
</dd>
<dt>def serve_until_stopped(self):</dt>
<dd><p class="first">import select
abort = 0
while not abort:</p>
<blockquote class="last">
<dl class="docutils">
<dt>rd, wr, ex = select.select([self.socket.fileno()],</dt>
<dd>[], [],
self.timeout)</dd>
<dt>if rd:</dt>
<dd>self.handle_request()</dd>
</dl>
<p>abort = self.abort</p>
</blockquote>
</dd>
</dl>
</dd>
<dt>def main():</dt>
<dd><dl class="first docutils">
<dt>logging.basicConfig(</dt>
<dd>format=&#8221;%(relativeCreated)5d %(name)-15s %(levelname)-8s %(message)s&#8221;)</dd>
</dl>
<p class="last">tcpserver = LogRecordSocketReceiver()
print &#8220;About to start TCP server...&#8221;
tcpserver.serve_until_stopped()</p>
</dd>
<dt>if __name__ == &#8220;__main__&#8221;:</dt>
<dd>main()</dd>
</dl>
</blockquote>
<p>First run the server, and then the client. On the client side, nothing
is printed on the console; on the server side, you should see
something like:</p>
<blockquote>
<dl class="docutils">
<dt>About to start TCP server...</dt>
<dd>59 root            INFO     Jackdaws love my big sphinx of quartz.
59 myapp.area1     DEBUG    Quick zephyrs blow, vexing daft Jim.
69 myapp.area1     INFO     How quickly daft jumping zebras vex.
69 myapp.area2     WARNING  Jail zesty vixen who grabbed pay from quack.
69 myapp.area2     ERROR    The five boxing wizards jump quickly.</dd>
</dl>
</blockquote>
</div>
<div class="section" id="handler-objects">
<h2>15.5.8. Handler Objects<a class="headerlink" href="#handler-objects" title="Permalink to this headline">¶</a></h2>
<p>Handlers have the following attributes and methods. Note that
<tt class="docutils literal"><span class="pre">Handler</span></tt> is never instantiated directly; this class acts as a base
for more useful subclasses. However, the <tt class="docutils literal"><span class="pre">__init__()</span></tt> method in
subclasses needs to call <tt class="docutils literal"><span class="pre">Handler.__init__()</span></tt>.</p>
<p>Handler.__init__(level=NOTSET)</p>
<blockquote>
Initializes the <tt class="docutils literal"><span class="pre">Handler</span></tt> instance by setting its level, setting
the list of filters to the empty list and creating a lock (using
<tt class="docutils literal"><span class="pre">createLock()</span></tt>) for serializing access to an I/O mechanism.</blockquote>
<p>Handler.createLock()</p>
<blockquote>
Initializes a thread lock which can be used to serialize access to
underlying I/O functionality which may not be threadsafe.</blockquote>
<p>Handler.acquire()</p>
<blockquote>
Acquires the thread lock created with <tt class="docutils literal"><span class="pre">createLock()</span></tt>.</blockquote>
<p>Handler.release()</p>
<blockquote>
Releases the thread lock acquired with <tt class="docutils literal"><span class="pre">acquire()</span></tt>.</blockquote>
<p>Handler.setLevel(lvl)</p>
<blockquote>
Sets the threshold for this handler to <em>lvl</em>. Logging messages
which are less severe than <em>lvl</em> will be ignored. When a handler is
created, the level is set to <tt class="docutils literal"><span class="pre">NOTSET</span></tt> (which causes all messages
to be processed).</blockquote>
<p>Handler.setFormatter(form)</p>
<blockquote>
Sets the <tt class="docutils literal"><span class="pre">Formatter</span></tt> for this handler to <em>form</em>.</blockquote>
<p>Handler.addFilter(filt)</p>
<blockquote>
Adds the specified filter <em>filt</em> to this handler.</blockquote>
<p>Handler.removeFilter(filt)</p>
<blockquote>
Removes the specified filter <em>filt</em> from this handler.</blockquote>
<p>Handler.filter(record)</p>
<blockquote>
Applies this handler&#8217;s filters to the record and returns a true
value if the record is to be processed.</blockquote>
<p>Handler.flush()</p>
<blockquote>
Ensure all logging output has been flushed. This version does
nothing and is intended to be implemented by subclasses.</blockquote>
<p>Handler.close()</p>
<blockquote>
Tidy up any resources used by the handler. This version does no
output but removes the handler from an internal list of handlers
which is closed when <tt class="docutils literal"><span class="pre">shutdown()</span></tt> is called. Subclasses should
ensure that this gets called from overridden <tt class="docutils literal"><span class="pre">close()</span></tt> methods.</blockquote>
<p>Handler.handle(record)</p>
<blockquote>
Conditionally emits the specified logging record, depending on
filters which may have been added to the handler. Wraps the actual
emission of the record with acquisition/release of the I/O thread
lock.</blockquote>
<p>Handler.handleError(record)</p>
<blockquote>
This method should be called from handlers when an exception is
encountered during an <tt class="docutils literal"><span class="pre">emit()</span></tt> call. By default it does nothing,
which means that exceptions get silently ignored. This is what is
mostly wanted for a logging system - most users will not care about
errors in the logging system, they are more interested in
application errors. You could, however, replace this with a custom
handler if you wish. The specified record is the one which was
being processed when the exception occurred.</blockquote>
<p>Handler.format(record)</p>
<blockquote>
Do formatting for a record - if a formatter is set, use it.
Otherwise, use the default formatter for the module.</blockquote>
<p>Handler.emit(record)</p>
<blockquote>
Do whatever it takes to actually log the specified logging record.
This version is intended to be implemented by subclasses and so
raises a <tt class="docutils literal"><span class="pre">NotImplementedError</span></tt>.</blockquote>
<div class="section" id="streamhandler">
<h3>15.5.8.1. StreamHandler<a class="headerlink" href="#streamhandler" title="Permalink to this headline">¶</a></h3>
<p>The <tt class="docutils literal"><span class="pre">StreamHandler</span></tt> class, located in the core <tt class="docutils literal"><span class="pre">logging</span></tt> package,
sends logging output to streams such as <em>sys.stdout</em>, <em>sys.stderr</em> or
any file-like object (or, more precisely, any object which supports
<tt class="docutils literal"><span class="pre">write()</span></tt> and <tt class="docutils literal"><span class="pre">flush()</span></tt> methods).</p>
<p>class class logging.handlers.StreamHandler([strm])</p>
<blockquote>
<p>Returns a new instance of the <tt class="docutils literal"><span class="pre">StreamHandler</span></tt> class. If <em>strm</em> is
specified, the instance will use it for logging output; otherwise,
<em>sys.stderr</em> will be used.</p>
<p>emit(record)</p>
<blockquote>
If a formatter is specified, it is used to format the record.
The record is then written to the stream with a trailing
newline. If exception information is present, it is formatted
using <tt class="docutils literal"><span class="pre">traceback.print_exception()</span></tt> and appended to the
stream.</blockquote>
<p>flush()</p>
<blockquote>
Flushes the stream by calling its <tt class="docutils literal"><span class="pre">flush()</span></tt> method. Note that
the <tt class="docutils literal"><span class="pre">close()</span></tt> method is inherited from <tt class="docutils literal"><span class="pre">Handler</span></tt> and so does
no output, so an explicit <tt class="docutils literal"><span class="pre">flush()</span></tt> call may be needed at
times.</blockquote>
</blockquote>
</div>
<div class="section" id="filehandler">
<h3>15.5.8.2. FileHandler<a class="headerlink" href="#filehandler" title="Permalink to this headline">¶</a></h3>
<p>The <tt class="docutils literal"><span class="pre">FileHandler</span></tt> class, located in the core <tt class="docutils literal"><span class="pre">logging</span></tt> package,
sends logging output to a disk file.  It inherits the output
functionality from <tt class="docutils literal"><span class="pre">StreamHandler</span></tt>.</p>
<p>class class logging.handlers.FileHandler(filename[, mode[, encoding[, delay]]])</p>
<blockquote>
<p>Returns a new instance of the <tt class="docutils literal"><span class="pre">FileHandler</span></tt> class. The specified
file is opened and used as the stream for logging. If <em>mode</em> is not
specified, <tt class="docutils literal"><span class="pre">'a'</span></tt> is used.  If <em>encoding</em> is not <em>None</em>, it is
used to open the file with that encoding.  If <em>delay</em> is true, then
file opening is deferred until the first call to <tt class="docutils literal"><span class="pre">emit()</span></tt>. By
default, the file grows indefinitely.</p>
<p>close()</p>
<blockquote>
Closes the file.</blockquote>
<p>emit(record)</p>
<blockquote>
Outputs the record to the file.</blockquote>
</blockquote>
<p>See <em>Configuring Logging for a Library</em> for more information on how to
use <tt class="docutils literal"><span class="pre">NullHandler</span></tt>.</p>
</div>
<div class="section" id="watchedfilehandler">
<h3>15.5.8.3. WatchedFileHandler<a class="headerlink" href="#watchedfilehandler" title="Permalink to this headline">¶</a></h3>
<p>New in version 2.6.</p>
<p>The <tt class="docutils literal"><span class="pre">WatchedFileHandler</span></tt> class, located in the <tt class="docutils literal"><span class="pre">logging.handlers</span></tt>
module, is a <tt class="docutils literal"><span class="pre">FileHandler</span></tt> which watches the file it is logging to.
If the file changes, it is closed and reopened using the file name.</p>
<p>A file change can happen because of usage of programs such as
<em>newsyslog</em> and <em>logrotate</em> which perform log file rotation. This
handler, intended for use under Unix/Linux, watches the file to see if
it has changed since the last emit. (A file is deemed to have changed
if its device or inode have changed.) If the file has changed, the old
file stream is closed, and the file opened to get a new stream.</p>
<p>This handler is not appropriate for use under Windows, because under
Windows open log files cannot be moved or renamed - logging opens the
files with exclusive locks - and so there is no need for such a
handler. Furthermore, <em>ST_INO</em> is not supported under Windows;
<tt class="docutils literal"><span class="pre">stat()</span></tt> always returns zero for this value.</p>
<p>class class logging.handlers.WatchedFileHandler(filename[, mode[, encoding[, delay]]])</p>
<blockquote>
<p>Returns a new instance of the <tt class="docutils literal"><span class="pre">WatchedFileHandler</span></tt> class. The
specified file is opened and used as the stream for logging. If
<em>mode</em> is not specified, <tt class="docutils literal"><span class="pre">'a'</span></tt> is used.  If <em>encoding</em> is not
<em>None</em>, it is used to open the file with that encoding.  If <em>delay</em>
is true, then file opening is deferred until the first call to
<tt class="docutils literal"><span class="pre">emit()</span></tt>.  By default, the file grows indefinitely.</p>
<p>emit(record)</p>
<blockquote>
Outputs the record to the file, but first checks to see if the
file has changed.  If it has, the existing stream is flushed and
closed and the file opened again, before outputting the record
to the file.</blockquote>
</blockquote>
</div>
<div class="section" id="rotatingfilehandler">
<h3>15.5.8.4. RotatingFileHandler<a class="headerlink" href="#rotatingfilehandler" title="Permalink to this headline">¶</a></h3>
<p>The <tt class="docutils literal"><span class="pre">RotatingFileHandler</span></tt> class, located in the <tt class="docutils literal"><span class="pre">logging.handlers</span></tt>
module, supports rotation of disk log files.</p>
<p>class class logging.handlers.RotatingFileHandler(filename[, mode[, maxBytes[, backupCount[, encoding[, delay]]]]])</p>
<blockquote>
<p>Returns a new instance of the <tt class="docutils literal"><span class="pre">RotatingFileHandler</span></tt> class. The
specified file is opened and used as the stream for logging. If
<em>mode</em> is not specified, <tt class="docutils literal"><span class="pre">'a'</span></tt> is used.  If <em>encoding</em> is not
<em>None</em>, it is used to open the file with that encoding.  If <em>delay</em>
is true, then file opening is deferred until the first call to
<tt class="docutils literal"><span class="pre">emit()</span></tt>.  By default, the file grows indefinitely.</p>
<p>You can use the <em>maxBytes</em> and <em>backupCount</em> values to allow the
file to <em>rollover</em> at a predetermined size. When the size is about
to be exceeded, the file is closed and a new file is silently
opened for output. Rollover occurs whenever the current log file is
nearly <em>maxBytes</em> in length; if <em>maxBytes</em> is zero, rollover never
occurs.  If <em>backupCount</em> is non-zero, the system will save old log
files by appending the extensions &#8220;.1&#8221;, &#8220;.2&#8221; etc., to the filename.
For example, with a <em>backupCount</em> of 5 and a base file name of
<tt class="docutils literal"><span class="pre">app.log</span></tt>, you would get <tt class="docutils literal"><span class="pre">app.log</span></tt>, <tt class="docutils literal"><span class="pre">app.log.1</span></tt>,
<tt class="docutils literal"><span class="pre">app.log.2</span></tt>, up to <tt class="docutils literal"><span class="pre">app.log.5</span></tt>. The file being written to is
always <tt class="docutils literal"><span class="pre">app.log</span></tt>.  When this file is filled, it is closed and
renamed to <tt class="docutils literal"><span class="pre">app.log.1</span></tt>, and if files <tt class="docutils literal"><span class="pre">app.log.1</span></tt>,
<tt class="docutils literal"><span class="pre">app.log.2</span></tt>, etc.  exist, then they are renamed to <tt class="docutils literal"><span class="pre">app.log.2</span></tt>,
<tt class="docutils literal"><span class="pre">app.log.3</span></tt> etc.  respectively.</p>
<p>doRollover()</p>
<blockquote>
Does a rollover, as described above.</blockquote>
<p>emit(record)</p>
<blockquote>
Outputs the record to the file, catering for rollover as
described previously.</blockquote>
</blockquote>
</div>
<div class="section" id="timedrotatingfilehandler">
<h3>15.5.8.5. TimedRotatingFileHandler<a class="headerlink" href="#timedrotatingfilehandler" title="Permalink to this headline">¶</a></h3>
<p>The <tt class="docutils literal"><span class="pre">TimedRotatingFileHandler</span></tt> class, located in the
<tt class="docutils literal"><span class="pre">logging.handlers</span></tt> module, supports rotation of disk log files at
certain timed intervals.</p>
<p>class class logging.handlers.TimedRotatingFileHandler(filename[, when[, interval[, backupCount[, encoding[, delay[, utc]]]]]])</p>
<blockquote>
<p>Returns a new instance of the <tt class="docutils literal"><span class="pre">TimedRotatingFileHandler</span></tt> class.
The specified file is opened and used as the stream for logging. On
rotating it also sets the filename suffix. Rotating happens based
on the product of <em>when</em> and <em>interval</em>.</p>
<p>You can use the <em>when</em> to specify the type of <em>interval</em>. The list
of possible values is below.  Note that they are not case
sensitive.</p>
<table border="1" class="docutils">
<colgroup>
<col width="42%" />
<col width="58%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Value</th>
<th class="head">Type of interval</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal"><span class="pre">'S'</span></tt></td>
<td>Seconds</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">'M'</span></tt></td>
<td>Minutes</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">'H'</span></tt></td>
<td>Hours</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">'D'</span></tt></td>
<td>Days</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">'W'</span></tt></td>
<td>Week day (0=Monday)</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">'midnight'</span></tt></td>
<td>Roll over at midnight</td>
</tr>
</tbody>
</table>
<p>The system will save old log files by appending extensions to the
filename. The extensions are date-and-time based, using the
strftime format <tt class="docutils literal"><span class="pre">%Y-%m-%d_%H-%M-%S</span></tt> or a leading portion thereof,
depending on the rollover interval. If the <em>utc</em> argument is true,
times in UTC will be used; otherwise local time is used.</p>
<p>If <em>backupCount</em> is nonzero, at most <em>backupCount</em> files will be
kept, and if more would be created when rollover occurs, the oldest
one is deleted. The deletion logic uses the interval to determine
which files to delete, so changing the interval may leave old files
lying around.</p>
<p>doRollover()</p>
<blockquote>
Does a rollover, as described above.</blockquote>
<p>emit(record)</p>
<blockquote>
Outputs the record to the file, catering for rollover as
described above.</blockquote>
</blockquote>
</div>
<div class="section" id="sockethandler">
<h3>15.5.8.6. SocketHandler<a class="headerlink" href="#sockethandler" title="Permalink to this headline">¶</a></h3>
<p>The <tt class="docutils literal"><span class="pre">SocketHandler</span></tt> class, located in the <tt class="docutils literal"><span class="pre">logging.handlers</span></tt>
module, sends logging output to a network socket. The base class uses
a TCP socket.</p>
<p>class class logging.handlers.SocketHandler(host, port)</p>
<blockquote>
<p>Returns a new instance of the <tt class="docutils literal"><span class="pre">SocketHandler</span></tt> class intended to
communicate with a remote machine whose address is given by <em>host</em>
and <em>port</em>.</p>
<p>close()</p>
<blockquote>
Closes the socket.</blockquote>
<p>emit()</p>
<blockquote>
Pickles the record&#8217;s attribute dictionary and writes it to the
socket in binary format. If there is an error with the socket,
silently drops the packet. If the connection was previously
lost, re-establishes the connection. To unpickle the record at
the receiving end into a <tt class="docutils literal"><span class="pre">LogRecord</span></tt>, use the
<tt class="docutils literal"><span class="pre">makeLogRecord()</span></tt> function.</blockquote>
<p>handleError()</p>
<blockquote>
Handles an error which has occurred during <tt class="docutils literal"><span class="pre">emit()</span></tt>. The most
likely cause is a lost connection. Closes the socket so that we
can retry on the next event.</blockquote>
<p>makeSocket()</p>
<blockquote>
This is a factory method which allows subclasses to define the
precise type of socket they want. The default implementation
creates a TCP socket (<tt class="docutils literal"><span class="pre">socket.SOCK_STREAM</span></tt>).</blockquote>
<p>makePickle(record)</p>
<blockquote>
Pickles the record&#8217;s attribute dictionary in binary format with
a length prefix, and returns it ready for transmission across
the socket.</blockquote>
<p>send(packet)</p>
<blockquote>
Send a pickled string <em>packet</em> to the socket. This function
allows for partial sends which can happen when the network is
busy.</blockquote>
</blockquote>
</div>
<div class="section" id="datagramhandler">
<h3>15.5.8.7. DatagramHandler<a class="headerlink" href="#datagramhandler" title="Permalink to this headline">¶</a></h3>
<p>The <tt class="docutils literal"><span class="pre">DatagramHandler</span></tt> class, located in the <tt class="docutils literal"><span class="pre">logging.handlers</span></tt>
module, inherits from <tt class="docutils literal"><span class="pre">SocketHandler</span></tt> to support sending logging
messages over UDP sockets.</p>
<p>class class logging.handlers.DatagramHandler(host, port)</p>
<blockquote>
<p>Returns a new instance of the <tt class="docutils literal"><span class="pre">DatagramHandler</span></tt> class intended to
communicate with a remote machine whose address is given by <em>host</em>
and <em>port</em>.</p>
<p>emit()</p>
<blockquote>
Pickles the record&#8217;s attribute dictionary and writes it to the
socket in binary format. If there is an error with the socket,
silently drops the packet. To unpickle the record at the
receiving end into a <tt class="docutils literal"><span class="pre">LogRecord</span></tt>, use the <tt class="docutils literal"><span class="pre">makeLogRecord()</span></tt>
function.</blockquote>
<p>makeSocket()</p>
<blockquote>
The factory method of <tt class="docutils literal"><span class="pre">SocketHandler</span></tt> is here overridden to
create a UDP socket (<tt class="docutils literal"><span class="pre">socket.SOCK_DGRAM</span></tt>).</blockquote>
<p>send(s)</p>
<blockquote>
Send a pickled string to a socket.</blockquote>
</blockquote>
</div>
<div class="section" id="sysloghandler">
<h3>15.5.8.8. SysLogHandler<a class="headerlink" href="#sysloghandler" title="Permalink to this headline">¶</a></h3>
<p>The <tt class="docutils literal"><span class="pre">SysLogHandler</span></tt> class, located in the <tt class="docutils literal"><span class="pre">logging.handlers</span></tt>
module, supports sending logging messages to a remote or local Unix
syslog.</p>
<p>class class logging.handlers.SysLogHandler([address[, facility]])</p>
<blockquote>
<p>Returns a new instance of the <tt class="docutils literal"><span class="pre">SysLogHandler</span></tt> class intended to
communicate with a remote Unix machine whose address is given by
<em>address</em> in the form of a <tt class="docutils literal"><span class="pre">(host,</span> <span class="pre">port)</span></tt> tuple.  If <em>address</em> is
not specified, <tt class="docutils literal"><span class="pre">('localhost',</span> <span class="pre">514)</span></tt> is used.  The address is used
to open a UDP socket.  An alternative to providing a <tt class="docutils literal"><span class="pre">(host,</span>
<span class="pre">port)</span></tt> tuple is providing an address as a string, for example
&#8220;/dev/log&#8221;. In this case, a Unix domain socket is used to send the
message to the syslog. If <em>facility</em> is not specified, <tt class="docutils literal"><span class="pre">LOG_USER</span></tt>
is used.</p>
<p>close()</p>
<blockquote>
Closes the socket to the remote host.</blockquote>
<p>emit(record)</p>
<blockquote>
The record is formatted, and then sent to the syslog server. If
exception information is present, it is <em>not</em> sent to the
server.</blockquote>
<p>encodePriority(facility, priority)</p>
<blockquote>
Encodes the facility and priority into an integer. You can pass
in strings or integers - if strings are passed, internal mapping
dictionaries are used to convert them to integers.</blockquote>
</blockquote>
</div>
<div class="section" id="nteventloghandler">
<h3>15.5.8.9. NTEventLogHandler<a class="headerlink" href="#nteventloghandler" title="Permalink to this headline">¶</a></h3>
<p>The <tt class="docutils literal"><span class="pre">NTEventLogHandler</span></tt> class, located in the <tt class="docutils literal"><span class="pre">logging.handlers</span></tt>
module, supports sending logging messages to a local Windows NT,
Windows 2000 or Windows XP event log. Before you can use it, you need
Mark Hammond&#8217;s Win32 extensions for Python installed.</p>
<p>class class logging.handlers.NTEventLogHandler(appname[, dllname[, logtype]])</p>
<blockquote>
<p>Returns a new instance of the <tt class="docutils literal"><span class="pre">NTEventLogHandler</span></tt> class. The
<em>appname</em> is used to define the application name as it appears in
the event log. An appropriate registry entry is created using this
name. The <em>dllname</em> should give the fully qualified pathname of a
.dll or .exe which contains message definitions to hold in the log
(if not specified, <tt class="docutils literal"><span class="pre">'win32service.pyd'</span></tt> is used - this is
installed with the Win32 extensions and contains some basic
placeholder message definitions. Note that use of these
placeholders will make your event logs big, as the entire message
source is held in the log. If you want slimmer logs, you have to
pass in the name of your own .dll or .exe which contains the
message definitions you want to use in the event log). The
<em>logtype</em> is one of <tt class="docutils literal"><span class="pre">'Application'</span></tt>, <tt class="docutils literal"><span class="pre">'System'</span></tt> or
<tt class="docutils literal"><span class="pre">'Security'</span></tt>, and defaults to <tt class="docutils literal"><span class="pre">'Application'</span></tt>.</p>
<p>close()</p>
<blockquote>
At this point, you can remove the application name from the
registry as a source of event log entries. However, if you do
this, you will not be able to see the events as you intended in
the Event Log Viewer - it needs to be able to access the
registry to get the .dll name. The current version does not do
this.</blockquote>
<p>emit(record)</p>
<blockquote>
Determines the message ID, event category and event type, and
then logs the message in the NT event log.</blockquote>
<p>getEventCategory(record)</p>
<blockquote>
Returns the event category for the record. Override this if you
want to specify your own categories. This version returns 0.</blockquote>
<p>getEventType(record)</p>
<blockquote>
Returns the event type for the record. Override this if you want
to specify your own types. This version does a mapping using the
handler&#8217;s typemap attribute, which is set up in <tt class="docutils literal"><span class="pre">__init__()</span></tt>
to a dictionary which contains mappings for <tt class="docutils literal"><span class="pre">DEBUG</span></tt>, <tt class="docutils literal"><span class="pre">INFO</span></tt>,
<tt class="docutils literal"><span class="pre">WARNING</span></tt>, <tt class="docutils literal"><span class="pre">ERROR</span></tt> and <tt class="docutils literal"><span class="pre">CRITICAL</span></tt>. If you are using your
own levels, you will either need to override this method or
place a suitable dictionary in the handler&#8217;s <em>typemap</em>
attribute.</blockquote>
<p>getMessageID(record)</p>
<blockquote>
Returns the message ID for the record. If you are using your own
messages, you could do this by having the <em>msg</em> passed to the
logger being an ID rather than a format string. Then, in here,
you could use a dictionary lookup to get the message ID. This
version returns 1, which is the base message ID in
<tt class="docutils literal"><span class="pre">win32service.pyd</span></tt>.</blockquote>
</blockquote>
</div>
<div class="section" id="smtphandler">
<h3>15.5.8.10. SMTPHandler<a class="headerlink" href="#smtphandler" title="Permalink to this headline">¶</a></h3>
<p>The <tt class="docutils literal"><span class="pre">SMTPHandler</span></tt> class, located in the <tt class="docutils literal"><span class="pre">logging.handlers</span></tt> module,
supports sending logging messages to an email address via SMTP.</p>
<p>class class logging.handlers.SMTPHandler(mailhost, fromaddr, toaddrs, subject[, credentials])</p>
<blockquote>
<p>Returns a new instance of the <tt class="docutils literal"><span class="pre">SMTPHandler</span></tt> class. The instance
is initialized with the from and to addresses and subject line of
the email. The <em>toaddrs</em> should be a list of strings. To specify a
non-standard SMTP port, use the (host, port) tuple format for the
<em>mailhost</em> argument. If you use a string, the standard SMTP port is
used. If your SMTP server requires authentication, you can specify
a (username, password) tuple for the <em>credentials</em> argument.</p>
<p>Changed in version 2.6: <em>credentials</em> was added.</p>
<p>emit(record)</p>
<blockquote>
Formats the record and sends it to the specified addressees.</blockquote>
<p>getSubject(record)</p>
<blockquote>
If you want to specify a subject line which is record-dependent,
override this method.</blockquote>
</blockquote>
</div>
<div class="section" id="memoryhandler">
<h3>15.5.8.11. MemoryHandler<a class="headerlink" href="#memoryhandler" title="Permalink to this headline">¶</a></h3>
<p>The <tt class="docutils literal"><span class="pre">MemoryHandler</span></tt> class, located in the <tt class="docutils literal"><span class="pre">logging.handlers</span></tt>
module, supports buffering of logging records in memory, periodically
flushing them to a <em>target</em> handler. Flushing occurs whenever the
buffer is full, or when an event of a certain severity or greater is
seen.</p>
<p><tt class="docutils literal"><span class="pre">MemoryHandler</span></tt> is a subclass of the more general
<tt class="docutils literal"><span class="pre">BufferingHandler</span></tt>, which is an abstract class. This buffers logging
records in memory. Whenever each record is added to the buffer, a
check is made by calling <tt class="docutils literal"><span class="pre">shouldFlush()</span></tt> to see if the buffer should
be flushed.  If it should, then <tt class="docutils literal"><span class="pre">flush()</span></tt> is expected to do the
needful.</p>
<p>class class logging.handlers.BufferingHandler(capacity)</p>
<blockquote>
<p>Initializes the handler with a buffer of the specified capacity.</p>
<p>emit(record)</p>
<blockquote>
Appends the record to the buffer. If <tt class="docutils literal"><span class="pre">shouldFlush()</span></tt> returns
true, calls <tt class="docutils literal"><span class="pre">flush()</span></tt> to process the buffer.</blockquote>
<p>flush()</p>
<blockquote>
You can override this to implement custom flushing behavior.
This version just zaps the buffer to empty.</blockquote>
<p>shouldFlush(record)</p>
<blockquote>
Returns true if the buffer is up to capacity. This method can be
overridden to implement custom flushing strategies.</blockquote>
</blockquote>
<p>class class logging.handlers.MemoryHandler(capacity[, flushLevel[, target]])</p>
<blockquote>
<p>Returns a new instance of the <tt class="docutils literal"><span class="pre">MemoryHandler</span></tt> class. The instance
is initialized with a buffer size of <em>capacity</em>. If <em>flushLevel</em> is
not specified, <tt class="docutils literal"><span class="pre">ERROR</span></tt> is used. If no <em>target</em> is specified, the
target will need to be set using <tt class="docutils literal"><span class="pre">setTarget()</span></tt> before this
handler does anything useful.</p>
<p>close()</p>
<blockquote>
Calls <tt class="docutils literal"><span class="pre">flush()</span></tt>, sets the target to <tt class="xref docutils literal"><span class="pre">None</span></tt> and clears the
buffer.</blockquote>
<p>flush()</p>
<blockquote>
For a <tt class="docutils literal"><span class="pre">MemoryHandler</span></tt>, flushing means just sending the
buffered records to the target, if there is one. Override if you
want different behavior.</blockquote>
<p>setTarget(target)</p>
<blockquote>
Sets the target handler for this handler.</blockquote>
<p>shouldFlush(record)</p>
<blockquote>
Checks for buffer full or a record at the <em>flushLevel</em> or
higher.</blockquote>
</blockquote>
</div>
<div class="section" id="httphandler">
<h3>15.5.8.12. HTTPHandler<a class="headerlink" href="#httphandler" title="Permalink to this headline">¶</a></h3>
<p>The <tt class="docutils literal"><span class="pre">HTTPHandler</span></tt> class, located in the <tt class="docutils literal"><span class="pre">logging.handlers</span></tt> module,
supports sending logging messages to a Web server, using either
<tt class="docutils literal"><span class="pre">GET</span></tt> or <tt class="docutils literal"><span class="pre">POST</span></tt> semantics.</p>
<p>class class logging.handlers.HTTPHandler(host, url[, method])</p>
<blockquote>
<p>Returns a new instance of the <tt class="docutils literal"><span class="pre">HTTPHandler</span></tt> class. The instance
is initialized with a host address, url and HTTP method. The <em>host</em>
can be of the form <tt class="docutils literal"><span class="pre">host:port</span></tt>, should you need to use a specific
port number. If no <em>method</em> is specified, <tt class="docutils literal"><span class="pre">GET</span></tt> is used.</p>
<p>emit(record)</p>
<blockquote>
Sends the record to the Web server as an URL-encoded dictionary.</blockquote>
</blockquote>
</div>
</div>
<div class="section" id="formatter-objects">
<h2>15.5.9. Formatter Objects<a class="headerlink" href="#formatter-objects" title="Permalink to this headline">¶</a></h2>
<p><tt class="docutils literal"><span class="pre">Formatter``s</span> <span class="pre">have</span> <span class="pre">the</span> <span class="pre">following</span> <span class="pre">attributes</span> <span class="pre">and</span> <span class="pre">methods.</span> <span class="pre">They</span> <span class="pre">are</span>
<span class="pre">responsible</span> <span class="pre">for</span> <span class="pre">converting</span> <span class="pre">a</span> <span class="pre">``LogRecord</span></tt> to (usually) a string which
can be interpreted by either a human or an external system. The base
<tt class="docutils literal"><span class="pre">Formatter</span></tt> allows a formatting string to be specified. If none is
supplied, the default value of <tt class="docutils literal"><span class="pre">'%(message)s'</span></tt> is used.</p>
<p>A Formatter can be initialized with a format string which makes use of
knowledge of the <tt class="docutils literal"><span class="pre">LogRecord</span></tt> attributes - such as the default value
mentioned above making use of the fact that the user&#8217;s message and
arguments are pre-formatted into a <tt class="docutils literal"><span class="pre">LogRecord</span></tt>&#8216;s <em>message</em>
attribute.  This format string contains standard python %-style
mapping keys. See section <em>String Formatting Operations</em> for more
information on string formatting.</p>
<p>Currently, the useful mapping keys in a <tt class="docutils literal"><span class="pre">LogRecord</span></tt> are:</p>
<table border="1" class="docutils">
<colgroup>
<col width="36%" />
<col width="64%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Format</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal"><span class="pre">%(name)s</span></tt></td>
<td>Name of the logger (logging channel).</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">%(levelno)s</span></tt></td>
<td>Numeric logging level for the message
(<tt class="docutils literal"><span class="pre">DEBUG</span></tt>, <tt class="docutils literal"><span class="pre">INFO</span></tt>, <tt class="docutils literal"><span class="pre">WARNING</span></tt>, <tt class="docutils literal"><span class="pre">ERROR</span></tt>,
<tt class="docutils literal"><span class="pre">CRITICAL</span></tt>).</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">%(levelname)s</span></tt></td>
<td>Text logging level for the message
(<tt class="docutils literal"><span class="pre">'DEBUG'</span></tt>, <tt class="docutils literal"><span class="pre">'INFO'</span></tt>, <tt class="docutils literal"><span class="pre">'WARNING'</span></tt>,
<tt class="docutils literal"><span class="pre">'ERROR'</span></tt>, <tt class="docutils literal"><span class="pre">'CRITICAL'</span></tt>).</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">%(pathname)s</span></tt></td>
<td>Full pathname of the source file where the
logging call was issued (if available).</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">%(filename)s</span></tt></td>
<td>Filename portion of pathname.</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">%(module)s</span></tt></td>
<td>Module (name portion of filename).</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">%(funcName)s</span></tt></td>
<td>Name of function containing the logging call.</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">%(lineno)d</span></tt></td>
<td>Source line number where the logging call was
issued (if available).</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">%(created)f</span></tt></td>
<td>Time when the <tt class="docutils literal"><span class="pre">LogRecord</span></tt> was created (as
returned by <tt class="docutils literal"><span class="pre">time.time()</span></tt>).</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">%(relativeCreated)d</span></tt></td>
<td>Time in milliseconds when the LogRecord was
created, relative to the time the logging
module was loaded.</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">%(asctime)s</span></tt></td>
<td>Human-readable time when the <tt class="docutils literal"><span class="pre">LogRecord</span></tt> was
created.  By default this is of the form
&#8220;2003-07-08 16:49:45,896&#8221; (the numbers after
the comma are millisecond portion of the time).</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">%(msecs)d</span></tt></td>
<td>Millisecond portion of the time when the
<tt class="docutils literal"><span class="pre">LogRecord</span></tt> was created.</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">%(thread)d</span></tt></td>
<td>Thread ID (if available).</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">%(threadName)s</span></tt></td>
<td>Thread name (if available).</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">%(process)d</span></tt></td>
<td>Process ID (if available).</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">%(message)s</span></tt></td>
<td>The logged message, computed as <tt class="docutils literal"><span class="pre">msg</span> <span class="pre">%</span> <span class="pre">args</span></tt>.</td>
</tr>
</tbody>
</table>
<p>Changed in version 2.5: <em>funcName</em> was added.</p>
<p>class class logging.Formatter([fmt[, datefmt]])</p>
<blockquote>
<p>Returns a new instance of the <tt class="docutils literal"><span class="pre">Formatter</span></tt> class. The instance is
initialized with a format string for the message as a whole, as
well as a format string for the date/time portion of a message. If
no <em>fmt</em> is specified, <tt class="docutils literal"><span class="pre">'%(message)s'</span></tt> is used. If no <em>datefmt</em>
is specified, the ISO8601 date format is used.</p>
<p>format(record)</p>
<blockquote>
The record&#8217;s attribute dictionary is used as the operand to a
string formatting operation. Returns the resulting string.
Before formatting the dictionary, a couple of preparatory steps
are carried out. The <em>message</em> attribute of the record is
computed using <em>msg</em> % <em>args</em>. If the formatting string contains
<tt class="docutils literal"><span class="pre">'(asctime)'</span></tt>, <tt class="docutils literal"><span class="pre">formatTime()</span></tt> is called to format the event
time. If there is exception information, it is formatted using
<tt class="docutils literal"><span class="pre">formatException()</span></tt> and appended to the message. Note that the
formatted exception information is cached in attribute
<em>exc_text</em>. This is useful because the exception information can
be pickled and sent across the wire, but you should be careful
if you have more than one <tt class="docutils literal"><span class="pre">Formatter</span></tt> subclass which
customizes the formatting of exception information. In this
case, you will have to clear the cached value after a formatter
has done its formatting, so that the next formatter to handle
the event doesn&#8217;t use the cached value but recalculates it
afresh.</blockquote>
<p>formatTime(record[, datefmt])</p>
<blockquote>
This method should be called from <tt class="docutils literal"><span class="pre">format()</span></tt> by a formatter
which wants to make use of a formatted time. This method can be
overridden in formatters to provide for any specific
requirement, but the basic behavior is as follows: if <em>datefmt</em>
(a string) is specified, it is used with <tt class="docutils literal"><span class="pre">time.strftime()</span></tt> to
format the creation time of the record. Otherwise, the ISO8601
format is used.  The resulting string is returned.</blockquote>
<p>formatException(exc_info)</p>
<blockquote>
Formats the specified exception information (a standard
exception tuple as returned by <tt class="docutils literal"><span class="pre">sys.exc_info()</span></tt>) as a string.
This default implementation just uses
<tt class="docutils literal"><span class="pre">traceback.print_exception()</span></tt>. The resulting string is
returned.</blockquote>
</blockquote>
</div>
<div class="section" id="filter-objects">
<h2>15.5.10. Filter Objects<a class="headerlink" href="#filter-objects" title="Permalink to this headline">¶</a></h2>
<p><a href="#id73"><span class="problematic" id="id74">``</span></a>Filter``s can be used by <a href="#id75"><span class="problematic" id="id76">``</span></a>Handler``s and <a href="#id77"><span class="problematic" id="id78">``</span></a>Logger``s for more
sophisticated filtering than is provided by levels. The base filter
class only allows events which are below a certain point in the logger
hierarchy. For example, a filter initialized with &#8220;A.B&#8221; will allow
events logged by loggers &#8220;A.B&#8221;, &#8220;A.B.C&#8221;, &#8220;A.B.C.D&#8221;, &#8220;A.B.D&#8221; etc. but
not &#8220;A.BB&#8221;, &#8220;B.A.B&#8221; etc. If initialized with the empty string, all
events are passed.</p>
<p>class class logging.Filter([name])</p>
<blockquote>
<p>Returns an instance of the <tt class="docutils literal"><span class="pre">Filter</span></tt> class. If <em>name</em> is
specified, it names a logger which, together with its children,
will have its events allowed through the filter. If no name is
specified, allows every event.</p>
<p>filter(record)</p>
<blockquote>
Is the specified record to be logged? Returns zero for no,
nonzero for yes. If deemed appropriate, the record may be
modified in-place by this method.</blockquote>
</blockquote>
</div>
<div class="section" id="logrecord-objects">
<h2>15.5.11. LogRecord Objects<a class="headerlink" href="#logrecord-objects" title="Permalink to this headline">¶</a></h2>
<p><tt class="docutils literal"><span class="pre">LogRecord</span></tt> instances are created every time something is logged.
They contain all the information pertinent to the event being logged.
The main information passed in is in msg and args, which are combined
using msg % args to create the message field of the record. The record
also includes information such as when the record was created, the
source line where the logging call was made, and any exception
information to be logged.</p>
<p>class class logging.LogRecord(name, lvl, pathname, lineno, msg, args, exc_info[, func])</p>
<blockquote>
<p>Returns an instance of <tt class="docutils literal"><span class="pre">LogRecord</span></tt> initialized with interesting
information. The <em>name</em> is the logger name; <em>lvl</em> is the numeric
level; <em>pathname</em> is the absolute pathname of the source file in
which the logging call was made; <em>lineno</em> is the line number in
that file where the logging call is found; <em>msg</em> is the user-
supplied message (a format string); <em>args</em> is the tuple which,
together with <em>msg</em>, makes up the user message; and <em>exc_info</em> is
the exception tuple obtained by calling <tt class="docutils literal"><span class="pre">sys.exc_info()</span></tt> (or
<tt class="xref docutils literal"><span class="pre">None</span></tt>, if no exception information is available). The <em>func</em> is
the name of the function from which the logging call was made. If
not specified, it defaults to <tt class="xref docutils literal"><span class="pre">None</span></tt>.</p>
<p>Changed in version 2.5: <em>func</em> was added.</p>
<p>getMessage()</p>
<blockquote>
Returns the message for this <tt class="docutils literal"><span class="pre">LogRecord</span></tt> instance after
merging any user-supplied arguments with the message.</blockquote>
</blockquote>
</div>
<div class="section" id="loggeradapter-objects">
<h2>15.5.12. LoggerAdapter Objects<a class="headerlink" href="#loggeradapter-objects" title="Permalink to this headline">¶</a></h2>
<p>New in version 2.6.</p>
<p><tt class="docutils literal"><span class="pre">LoggerAdapter</span></tt> instances are used to conveniently pass contextual
information into logging calls. For a usage example , see the section
on adding contextual information to your logging output.</p>
<p>class class logging.LoggerAdapter(logger, extra)</p>
<blockquote>
<p>Returns an instance of <tt class="docutils literal"><span class="pre">LoggerAdapter</span></tt> initialized with an
underlying <tt class="docutils literal"><span class="pre">Logger</span></tt> instance and a dict-like object.</p>
<p>process(msg, kwargs)</p>
<blockquote>
Modifies the message and/or keyword arguments passed to a
logging call in order to insert contextual information. This
implementation takes the object passed as <em>extra</em> to the
constructor and adds it to <em>kwargs</em> using key &#8216;extra&#8217;. The
return value is a (<em>msg</em>, <em>kwargs</em>) tuple which has the
(possibly modified) versions of the arguments passed in.</blockquote>
</blockquote>
<p>In addition to the above, <tt class="docutils literal"><span class="pre">LoggerAdapter</span></tt> supports all the logging
methods of <tt class="docutils literal"><span class="pre">Logger</span></tt>, i.e. <tt class="docutils literal"><span class="pre">debug()</span></tt>, <tt class="docutils literal"><span class="pre">info()</span></tt>, <tt class="docutils literal"><span class="pre">warning()</span></tt>,
<tt class="docutils literal"><span class="pre">error()</span></tt>, <tt class="docutils literal"><span class="pre">exception()</span></tt>, <tt class="docutils literal"><span class="pre">critical()</span></tt> and <tt class="docutils literal"><span class="pre">log()</span></tt>. These
methods have the same signatures as their counterparts in <tt class="docutils literal"><span class="pre">Logger</span></tt>,
so you can use the two types of instances interchangeably.</p>
</div>
<div class="section" id="thread-safety">
<h2>15.5.13. Thread Safety<a class="headerlink" href="#thread-safety" title="Permalink to this headline">¶</a></h2>
<p>The logging module is intended to be thread-safe without any special
work needing to be done by its clients. It achieves this though using
threading locks; there is one lock to serialize access to the module&#8217;s
shared data, and each handler also creates a lock to serialize access
to its underlying I/O.</p>
</div>
<div class="section" id="configuration">
<h2>15.5.14. Configuration<a class="headerlink" href="#configuration" title="Permalink to this headline">¶</a></h2>
<div class="section" id="configuration-functions">
<h3>15.5.14.1. Configuration functions<a class="headerlink" href="#configuration-functions" title="Permalink to this headline">¶</a></h3>
<p>The following functions configure the logging module. They are located
in the <tt class="docutils literal"><span class="pre">logging.config</span></tt> module.  Their use is optional &#8212; you can
configure the logging module using these functions or by making calls
to the main API (defined in <tt class="docutils literal"><span class="pre">logging</span></tt> itself) and defining handlers
which are declared either in <tt class="docutils literal"><span class="pre">logging</span></tt> or <tt class="docutils literal"><span class="pre">logging.handlers</span></tt>.</p>
<p>logging.fileConfig(fname[, defaults])</p>
<blockquote>
Reads the logging configuration from a ConfigParser-format file
named <em>fname</em>. This function can be called several times from an
application, allowing an end user the ability to select from
various pre-canned configurations (if the developer provides a
mechanism to present the choices and load the chosen
configuration). Defaults to be passed to ConfigParser can be
specified in the <em>defaults</em> argument.</blockquote>
<p>logging.listen([port])</p>
<blockquote>
<p>Starts up a socket server on the specified port, and listens for
new configurations. If no port is specified, the module&#8217;s default
<tt class="docutils literal"><span class="pre">DEFAULT_LOGGING_CONFIG_PORT</span></tt> is used. Logging configurations
will be sent as a file suitable for processing by <tt class="docutils literal"><span class="pre">fileConfig()</span></tt>.
Returns a <tt class="docutils literal"><span class="pre">Thread</span></tt> instance on which you can call <tt class="docutils literal"><span class="pre">start()</span></tt> to
start the server, and which you can <tt class="docutils literal"><span class="pre">join()</span></tt> when appropriate. To
stop the server, call <tt class="docutils literal"><span class="pre">stopListening()</span></tt>.</p>
<p>To send a configuration to the socket, read in the configuration
file and send it to the socket as a string of bytes preceded by a
four-byte length string packed in binary using <tt class="docutils literal"><span class="pre">struct.pack('&gt;L',</span>
<span class="pre">n)</span></tt>.</p>
</blockquote>
<p>logging.stopListening()</p>
<blockquote>
Stops the listening server which was created with a call to
<tt class="docutils literal"><span class="pre">listen()</span></tt>. This is typically called before calling <tt class="docutils literal"><span class="pre">join()</span></tt> on
the return value from <tt class="docutils literal"><span class="pre">listen()</span></tt>.</blockquote>
</div>
<div class="section" id="configuration-file-format">
<h3>15.5.14.2. Configuration file format<a class="headerlink" href="#configuration-file-format" title="Permalink to this headline">¶</a></h3>
<p>The configuration file format understood by <tt class="docutils literal"><span class="pre">fileConfig()</span></tt> is based
on ConfigParser functionality. The file must contain sections called
<tt class="docutils literal"><span class="pre">[loggers]</span></tt>, <tt class="docutils literal"><span class="pre">[handlers]</span></tt> and <tt class="docutils literal"><span class="pre">[formatters]</span></tt> which identify by
name the entities of each type which are defined in the file. For each
such entity, there is a separate section which identified how that
entity is configured. Thus, for a logger named <tt class="docutils literal"><span class="pre">log01</span></tt> in the
<tt class="docutils literal"><span class="pre">[loggers]</span></tt> section, the relevant configuration details are held in
a section <tt class="docutils literal"><span class="pre">[logger_log01]</span></tt>. Similarly, a handler called <tt class="docutils literal"><span class="pre">hand01</span></tt>
in the <tt class="docutils literal"><span class="pre">[handlers]</span></tt> section will have its configuration held in a
section called <tt class="docutils literal"><span class="pre">[handler_hand01]</span></tt>, while a formatter called
<tt class="docutils literal"><span class="pre">form01</span></tt> in the <tt class="docutils literal"><span class="pre">[formatters]</span></tt> section will have its configuration
specified in a section called <tt class="docutils literal"><span class="pre">[formatter_form01]</span></tt>. The root logger
configuration must be specified in a section called <tt class="docutils literal"><span class="pre">[logger_root]</span></tt>.</p>
<p>Examples of these sections in the file are given below.</p>
<blockquote>
<p>[loggers]
keys=root,log02,log03,log04,log05,log06,log07</p>
<p>[handlers]
keys=hand01,hand02,hand03,hand04,hand05,hand06,hand07,hand08,hand09</p>
<p>[formatters]
keys=form01,form02,form03,form04,form05,form06,form07,form08,form09</p>
</blockquote>
<p>The root logger must specify a level and a list of handlers. An
example of a root logger section is given below.</p>
<blockquote>
[logger_root]
level=NOTSET
handlers=hand01</blockquote>
<p>The <tt class="docutils literal"><span class="pre">level</span></tt> entry can be one of <tt class="docutils literal"><span class="pre">DEBUG,</span> <span class="pre">INFO,</span> <span class="pre">WARNING,</span> <span class="pre">ERROR,</span>
<span class="pre">CRITICAL</span></tt> or <tt class="docutils literal"><span class="pre">NOTSET</span></tt>. For the root logger only, <tt class="docutils literal"><span class="pre">NOTSET</span></tt> means
that all messages will be logged. Level values are <tt class="docutils literal"><span class="pre">eval()``uated</span> <span class="pre">in</span>
<span class="pre">the</span> <span class="pre">context</span> <span class="pre">of</span> <span class="pre">the</span> <span class="pre">``logging</span></tt> package&#8217;s namespace.</p>
<p>The <tt class="docutils literal"><span class="pre">handlers</span></tt> entry is a comma-separated list of handler names,
which must appear in the <tt class="docutils literal"><span class="pre">[handlers]</span></tt> section. These names must
appear in the <tt class="docutils literal"><span class="pre">[handlers]</span></tt> section and have corresponding sections
in the configuration file.</p>
<p>For loggers other than the root logger, some additional information is
required. This is illustrated by the following example.</p>
<blockquote>
[logger_parser]
level=DEBUG
handlers=hand01
propagate=1
qualname=compiler.parser</blockquote>
<p>The <tt class="docutils literal"><span class="pre">level</span></tt> and <tt class="docutils literal"><span class="pre">handlers</span></tt> entries are interpreted as for the root
logger, except that if a non-root logger&#8217;s level is specified as
<tt class="docutils literal"><span class="pre">NOTSET</span></tt>, the system consults loggers higher up the hierarchy to
determine the effective level of the logger. The <tt class="docutils literal"><span class="pre">propagate</span></tt> entry
is set to 1 to indicate that messages must propagate to handlers
higher up the logger hierarchy from this logger, or 0 to indicate that
messages are <strong>not</strong> propagated to handlers up the hierarchy. The
<tt class="docutils literal"><span class="pre">qualname</span></tt> entry is the hierarchical channel name of the logger,
that is to say the name used by the application to get the logger.</p>
<p>Sections which specify handler configuration are exemplified by the
following.</p>
<blockquote>
[handler_hand01]
class=StreamHandler
level=NOTSET
formatter=form01
args=(sys.stdout,)</blockquote>
<p>The <tt class="docutils literal"><span class="pre">class</span></tt> entry indicates the handler&#8217;s class (as determined by
<tt class="docutils literal"><span class="pre">eval()</span></tt> in the <tt class="docutils literal"><span class="pre">logging</span></tt> package&#8217;s namespace). The <tt class="docutils literal"><span class="pre">level</span></tt> is
interpreted as for loggers, and <tt class="docutils literal"><span class="pre">NOTSET</span></tt> is taken to mean &#8220;log
everything&#8221;.</p>
<p>Changed in version 2.6: Added support for resolving the handler&#8217;s
class as a dotted module and class name.</p>
<p>The <tt class="docutils literal"><span class="pre">formatter</span></tt> entry indicates the key name of the formatter for
this handler. If blank, a default formatter
(<tt class="docutils literal"><span class="pre">logging._defaultFormatter</span></tt>) is used. If a name is specified, it
must appear in the <tt class="docutils literal"><span class="pre">[formatters]</span></tt> section and have a corresponding
section in the configuration file.</p>
<p>The <tt class="docutils literal"><span class="pre">args</span></tt> entry, when <tt class="docutils literal"><span class="pre">eval()``uated</span> <span class="pre">in</span> <span class="pre">the</span> <span class="pre">context</span> <span class="pre">of</span> <span class="pre">the</span>
<span class="pre">``logging</span></tt> package&#8217;s namespace, is the list of arguments to the
constructor for the handler class. Refer to the constructors for the
relevant handlers, or to the examples below, to see how typical
entries are constructed.</p>
<blockquote>
<p>[handler_hand02]
class=FileHandler
level=DEBUG
formatter=form02
args=(&#8216;python.log&#8217;, &#8216;w&#8217;)</p>
<p>[handler_hand03]
class=handlers.SocketHandler
level=INFO
formatter=form03
args=(&#8216;localhost&#8217;, handlers.DEFAULT_TCP_LOGGING_PORT)</p>
<p>[handler_hand04]
class=handlers.DatagramHandler
level=WARN
formatter=form04
args=(&#8216;localhost&#8217;, handlers.DEFAULT_UDP_LOGGING_PORT)</p>
<p>[handler_hand05]
class=handlers.SysLogHandler
level=ERROR
formatter=form05
args=((&#8216;localhost&#8217;, handlers.SYSLOG_UDP_PORT), handlers.SysLogHandler.LOG_USER)</p>
<p>[handler_hand06]
class=handlers.NTEventLogHandler
level=CRITICAL
formatter=form06
args=(&#8216;Python Application&#8217;, &#8216;&#8217;, &#8216;Application&#8217;)</p>
<p>[handler_hand07]
class=handlers.SMTPHandler
level=WARN
formatter=form07
args=(&#8216;localhost&#8217;, <a class="reference external" href="mailto:'from&#37;&#52;&#48;abc">'from<span>&#64;</span>abc</a>&#8216;, [<a class="reference external" href="mailto:'user1&#37;&#52;&#48;abc">'user1<span>&#64;</span>abc</a>&#8216;, <a class="reference external" href="mailto:'user2&#37;&#52;&#48;xyz">'user2<span>&#64;</span>xyz</a>&#8216;], &#8216;Logger Subject&#8217;)</p>
<p>[handler_hand08]
class=handlers.MemoryHandler
level=NOTSET
formatter=form08
target=
args=(10, ERROR)</p>
<p>[handler_hand09]
class=handlers.HTTPHandler
level=NOTSET
formatter=form09
args=(&#8216;localhost:9022&#8217;, &#8216;/log&#8217;, &#8216;GET&#8217;)</p>
</blockquote>
<p>Sections which specify formatter configuration are typified by the
following.</p>
<blockquote>
[formatter_form01]
format=F1 %(asctime)s %(levelname)s %(message)s
datefmt=
class=logging.Formatter</blockquote>
<p>The <tt class="docutils literal"><span class="pre">format</span></tt> entry is the overall format string, and the <tt class="docutils literal"><span class="pre">datefmt</span></tt>
entry is the <tt class="docutils literal"><span class="pre">strftime()</span></tt>-compatible date/time format string.  If
empty, the package substitutes ISO8601 format date/times, which is
almost equivalent to specifying the date format string <tt class="docutils literal"><span class="pre">&quot;%Y-%m-%d</span>
<span class="pre">%H:%M:%S&quot;</span></tt>.  The ISO8601 format also specifies milliseconds, which
are appended to the result of using the above format string, with a
comma separator.  An example time in ISO8601 format is <tt class="docutils literal"><span class="pre">2003-01-23</span>
<span class="pre">00:29:50,411</span></tt>.</p>
<p>The <tt class="docutils literal"><span class="pre">class</span></tt> entry is optional.  It indicates the name of the
formatter&#8217;s class (as a dotted module and class name.)  This option is
useful for instantiating a <tt class="docutils literal"><span class="pre">Formatter</span></tt> subclass.  Subclasses of
<tt class="docutils literal"><span class="pre">Formatter</span></tt> can present exception tracebacks in an expanded or
condensed format.</p>
</div>
<div class="section" id="configuration-server-example">
<h3>15.5.14.3. Configuration server example<a class="headerlink" href="#configuration-server-example" title="Permalink to this headline">¶</a></h3>
<p>Here is an example of a module using the logging configuration server:</p>
<blockquote>
<p>import logging
import logging.config
import time
import os</p>
<p># read initial config file
logging.config.fileConfig(&#8220;logging.conf&#8221;)</p>
<p># create and start listener on port 9999
t = logging.config.listen(9999)
t.start()</p>
<p>logger = logging.getLogger(&#8220;simpleExample&#8221;)</p>
<dl class="docutils">
<dt>try:</dt>
<dd><p class="first"># loop through logging calls to see the difference
# new configurations make, until Ctrl+C is pressed
while True:</p>
<blockquote class="last">
logger.debug(&#8220;debug message&#8221;)
logger.info(&#8220;info message&#8221;)
logger.warn(&#8220;warn message&#8221;)
logger.error(&#8220;error message&#8221;)
logger.critical(&#8220;critical message&#8221;)
time.sleep(5)</blockquote>
</dd>
<dt>except KeyboardInterrupt:</dt>
<dd># cleanup
logging.config.stopListening()
t.join()</dd>
</dl>
</blockquote>
<p>And here is a script that takes a filename and sends that file to the
server, properly preceded with the binary-encoded length, as the new
logging configuration:</p>
<blockquote>
<p>#!/usr/bin/env python
import socket, sys, struct</p>
<p>data_to_send = open(sys.argv[1], &#8220;r&#8221;).read()</p>
<p>HOST = &#8216;localhost&#8217;
PORT = 9999
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
print &#8220;connecting...&#8221;
s.connect((HOST, PORT))
print &#8220;sending config...&#8221;
s.send(struct.pack(&#8220;&gt;L&#8221;, len(data_to_send)))
s.send(data_to_send)
s.close()
print &#8220;complete&#8221;</p>
</blockquote>
</div>
</div>
<div class="section" id="more-examples">
<h2>15.5.15. More examples<a class="headerlink" href="#more-examples" title="Permalink to this headline">¶</a></h2>
<div class="section" id="multiple-handlers-and-formatters">
<h3>15.5.15.1. Multiple handlers and formatters<a class="headerlink" href="#multiple-handlers-and-formatters" title="Permalink to this headline">¶</a></h3>
<p>Loggers are plain Python objects.  The <tt class="docutils literal"><span class="pre">addHandler()</span></tt> method has no
minimum or maximum quota for the number of handlers you may add.
Sometimes it will be beneficial for an application to log all messages
of all severities to a text file while simultaneously logging errors
or above to the console.  To set this up, simply configure the
appropriate handlers.  The logging calls in the application code will
remain unchanged.  Here is a slight modification to the previous
simple module-based configuration example:</p>
<blockquote>
<p>import logging</p>
<p>logger = logging.getLogger(&#8220;simple_example&#8221;)
logger.setLevel(logging.DEBUG)
# create file handler which logs even debug messages
fh = logging.FileHandler(&#8220;spam.log&#8221;)
fh.setLevel(logging.DEBUG)
# create console handler with a higher log level
ch = logging.StreamHandler()
ch.setLevel(logging.ERROR)
# create formatter and add it to the handlers
formatter = logging.Formatter(&#8220;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#8221;)
ch.setFormatter(formatter)
fh.setFormatter(formatter)
# add the handlers to logger
logger.addHandler(ch)
logger.addHandler(fh)</p>
<p># &#8220;application&#8221; code
logger.debug(&#8220;debug message&#8221;)
logger.info(&#8220;info message&#8221;)
logger.warn(&#8220;warn message&#8221;)
logger.error(&#8220;error message&#8221;)
logger.critical(&#8220;critical message&#8221;)</p>
</blockquote>
<p>Notice that the &#8220;application&#8221; code does not care about multiple
handlers.  All that changed was the addition and configuration of a
new handler named <em>fh</em>.</p>
<p>The ability to create new handlers with higher- or lower-severity
filters can be very helpful when writing and testing an application.
Instead of using many <tt class="docutils literal"><span class="pre">print</span></tt> statements for debugging, use
<tt class="docutils literal"><span class="pre">logger.debug</span></tt>: Unlike the print statements, which you will have to
delete or comment out later, the logger.debug statements can remain
intact in the source code and remain dormant until you need them
again.  At that time, the only change that needs to happen is to
modify the severity level of the logger and/or handler to debug.</p>
</div>
<div class="section" id="using-logging-in-multiple-modules">
<h3>15.5.15.2. Using logging in multiple modules<a class="headerlink" href="#using-logging-in-multiple-modules" title="Permalink to this headline">¶</a></h3>
<p>It was mentioned above that multiple calls to
<tt class="docutils literal"><span class="pre">logging.getLogger('someLogger')</span></tt> return a reference to the same
logger object.  This is true not only within the same module, but also
across modules as long as it is in the same Python interpreter
process.  It is true for references to the same object; additionally,
application code can define and configure a parent logger in one
module and create (but not configure) a child logger in a separate
module, and all logger calls to the child will pass up to the parent.
Here is a main module:</p>
<blockquote>
<p>import logging
import auxiliary_module</p>
<p># create logger with &#8220;spam_application&#8221;
logger = logging.getLogger(&#8220;spam_application&#8221;)
logger.setLevel(logging.DEBUG)
# create file handler which logs even debug messages
fh = logging.FileHandler(&#8220;spam.log&#8221;)
fh.setLevel(logging.DEBUG)
# create console handler with a higher log level
ch = logging.StreamHandler()
ch.setLevel(logging.ERROR)
# create formatter and add it to the handlers
formatter = logging.Formatter(&#8220;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#8221;)
fh.setFormatter(formatter)
ch.setFormatter(formatter)
# add the handlers to the logger
logger.addHandler(fh)
logger.addHandler(ch)</p>
<p>logger.info(&#8220;creating an instance of auxiliary_module.Auxiliary&#8221;)
a = auxiliary_module.Auxiliary()
logger.info(&#8220;created an instance of auxiliary_module.Auxiliary&#8221;)
logger.info(&#8220;calling auxiliary_module.Auxiliary.do_something&#8221;)
a.do_something()
logger.info(&#8220;finished auxiliary_module.Auxiliary.do_something&#8221;)
logger.info(&#8220;calling auxiliary_module.some_function()&#8221;)
auxiliary_module.some_function()
logger.info(&#8220;done with auxiliary_module.some_function()&#8221;)</p>
</blockquote>
<p>Here is the auxiliary module:</p>
<blockquote>
<p>import logging</p>
<p># create logger
module_logger = logging.getLogger(&#8220;spam_application.auxiliary&#8221;)</p>
<dl class="docutils">
<dt>class Auxiliary:</dt>
<dd><dl class="first last docutils">
<dt>def __init__(self):</dt>
<dd>self.logger = logging.getLogger(&#8220;spam_application.auxiliary.Auxiliary&#8221;)
self.logger.info(&#8220;creating an instance of Auxiliary&#8221;)</dd>
<dt>def do_something(self):</dt>
<dd>self.logger.info(&#8220;doing something&#8221;)
a = 1 + 1
self.logger.info(&#8220;done doing something&#8221;)</dd>
</dl>
</dd>
<dt>def some_function():</dt>
<dd>module_logger.info(&#8220;received a call to &#8220;some_function&#8221;&#8220;)</dd>
</dl>
</blockquote>
<p>The output looks like this:</p>
<blockquote>
<dl class="docutils">
<dt>2005-03-23 23:47:11,663 - spam_application - INFO -</dt>
<dd>creating an instance of auxiliary_module.Auxiliary</dd>
<dt>2005-03-23 23:47:11,665 - spam_application.auxiliary.Auxiliary - INFO -</dt>
<dd>creating an instance of Auxiliary</dd>
<dt>2005-03-23 23:47:11,665 - spam_application - INFO -</dt>
<dd>created an instance of auxiliary_module.Auxiliary</dd>
<dt>2005-03-23 23:47:11,668 - spam_application - INFO -</dt>
<dd>calling auxiliary_module.Auxiliary.do_something</dd>
<dt>2005-03-23 23:47:11,668 - spam_application.auxiliary.Auxiliary - INFO -</dt>
<dd>doing something</dd>
<dt>2005-03-23 23:47:11,669 - spam_application.auxiliary.Auxiliary - INFO -</dt>
<dd>done doing something</dd>
<dt>2005-03-23 23:47:11,670 - spam_application - INFO -</dt>
<dd>finished auxiliary_module.Auxiliary.do_something</dd>
<dt>2005-03-23 23:47:11,671 - spam_application - INFO -</dt>
<dd>calling auxiliary_module.some_function()</dd>
<dt>2005-03-23 23:47:11,672 - spam_application.auxiliary - INFO -</dt>
<dd>received a call to &#8220;some_function&#8221;</dd>
<dt>2005-03-23 23:47:11,673 - spam_application - INFO -</dt>
<dd>done with auxiliary_module.some_function()</dd>
</dl>
</blockquote>
</div>
</div>
</div>


          </div>
        </div>
      </div>


      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../modindex.html" title="Global Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="getpass.html" title="15.6. getpass — Portable password input"
             >next</a> |</li>
        <li class="right" >
          <a href="getopt.html" title="15.4. getopt — Parser for command line options"
             >previous</a> |</li>
        <li><a href="../index.html">Jython v2.5.2 documentation</a> &raquo;</li>
          <li><a href="indexprogress.html" >The Python Standard Library and What Comes with Jython</a> &raquo;</li>
          <li><a href="allos.html" >15. Generic Operating System Services</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
      &copy; <a href="../copyright.html">Copyright</a> 2011, Jython Project.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 0.6.4.
    </div>
  </body>
</html>