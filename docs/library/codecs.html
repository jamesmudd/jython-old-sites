<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>7.8. codecs — Codec registry and base classes &mdash; Jython v2.5.2 documentation</title>
    <link rel="stylesheet" href="../_static/green-theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.5.2',
        COLLAPSE_MODINDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Jython v2.5.2 documentation" href="../index.html" />
    <link rel="up" title="7. String Services" href="strings.html" />
    <link rel="next" title="7.9. unicodedata — Unicode Database" href="unicodedata.html" />
    <link rel="prev" title="7.7. textwrap — Text wrapping and filling" href="textwrap.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../modindex.html" title="Global Module Index"
             accesskey="M">modules</a> |</li>
        <li class="right" >
          <a href="unicodedata.html" title="7.9. unicodedata — Unicode Database"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="textwrap.html" title="7.7. textwrap — Text wrapping and filling"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Jython v2.5.2 documentation</a> &raquo;</li>
          <li><a href="indexprogress.html" >The Python Standard Library and What Comes with Jython</a> &raquo;</li>
          <li><a href="strings.html" accesskey="U">7. String Services</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/jython.png" alt="Logo"/>
            </a></p>
            <h3><a href="../index.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference external" href="#">7.8. <tt class="docutils literal"><span class="pre">codecs</span></tt> &#8212; Codec registry and base classes</a><ul>
<li><a class="reference external" href="#codec-base-classes">7.8.1. Codec Base Classes</a><ul>
<li><a class="reference external" href="#codec-objects">7.8.1.1. Codec Objects</a></li>
<li><a class="reference external" href="#incrementalencoder-objects">7.8.1.2. IncrementalEncoder Objects</a></li>
<li><a class="reference external" href="#incrementaldecoder-objects">7.8.1.3. IncrementalDecoder Objects</a></li>
<li><a class="reference external" href="#streamwriter-objects">7.8.1.4. StreamWriter Objects</a></li>
<li><a class="reference external" href="#streamreader-objects">7.8.1.5. StreamReader Objects</a></li>
<li><a class="reference external" href="#streamreaderwriter-objects">7.8.1.6. StreamReaderWriter Objects</a></li>
<li><a class="reference external" href="#streamrecoder-objects">7.8.1.7. StreamRecoder Objects</a></li>
</ul>
</li>
<li><a class="reference external" href="#encodings-and-unicode">7.8.2. Encodings and Unicode</a></li>
<li><a class="reference external" href="#standard-encodings">7.8.3. Standard Encodings</a></li>
<li><a class="reference external" href="#encodings-idna-internationalized-domain-names-in-applications">7.8.4. <tt class="docutils literal"><span class="pre">encodings.idna</span></tt> &#8212; Internationalized Domain Names in Applications</a></li>
<li><a class="reference external" href="#encodings-utf-8-sig-utf-8-codec-with-bom-signature">7.8.5. <tt class="docutils literal"><span class="pre">encodings.utf_8_sig</span></tt> &#8212; UTF-8 codec with BOM signature</a></li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="textwrap.html"
                                  title="previous chapter">7.7. <tt class="docutils literal"><span class="pre">textwrap</span></tt> &#8212; Text wrapping and filling</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="unicodedata.html"
                                  title="next chapter">7.9. <tt class="docutils literal"><span class="pre">unicodedata</span></tt> &#8212; Unicode Database</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../_sources/library/codecs.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="../search.html" method="get">
                <input type="text" name="q" size="18" />
                <input type="submit" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="codecs-codec-registry-and-base-classes">
<h1>7.8. <tt class="docutils literal"><span class="pre">codecs</span></tt> &#8212; Codec registry and base classes<a class="headerlink" href="#codecs-codec-registry-and-base-classes" title="Permalink to this headline">¶</a></h1>
<p>This module defines base classes for standard Python codecs (encoders
and decoders) and provides access to the internal Python codec
registry which manages the codec and error handling lookup process.</p>
<p>It defines the following functions:</p>
<p>codecs.register(search_function)</p>
<blockquote>
<p>Register a codec search function. Search functions are expected to
take one argument, the encoding name in all lower case letters, and
return a <tt class="docutils literal"><span class="pre">CodecInfo</span></tt> object having the following attributes:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">name</span></tt> The name of the encoding;</li>
<li><tt class="docutils literal"><span class="pre">encode</span></tt> The stateless encoding function;</li>
<li><tt class="docutils literal"><span class="pre">decode</span></tt> The stateless decoding function;</li>
<li><tt class="docutils literal"><span class="pre">incrementalencoder</span></tt> An incremental encoder class or factory
function;</li>
<li><tt class="docutils literal"><span class="pre">incrementaldecoder</span></tt> An incremental decoder class or factory
function;</li>
<li><tt class="docutils literal"><span class="pre">streamwriter</span></tt> A stream writer class or factory function;</li>
<li><tt class="docutils literal"><span class="pre">streamreader</span></tt> A stream reader class or factory function.</li>
</ul>
<p>The various functions or classes take the following arguments:</p>
<p><em>encode</em> and <em>decode</em>: These must be functions or methods which
have the same interface as the <tt class="docutils literal"><span class="pre">encode()</span></tt>/<tt class="docutils literal"><span class="pre">decode()</span></tt> methods of
Codec instances (see Codec Interface). The functions/methods are
expected to work in a stateless mode.</p>
<p><em>incrementalencoder</em> and <em>incrementaldecoder</em>: These have to be
factory functions providing the following interface:</p>
<p><tt class="docutils literal"><span class="pre">factory(errors='strict')</span></tt></p>
<p>The factory functions must return objects providing the interfaces
defined by the base classes <tt class="docutils literal"><span class="pre">IncrementalEncoder</span></tt> and
<tt class="docutils literal"><span class="pre">IncrementalDecoder</span></tt>, respectively. Incremental codecs can
maintain state.</p>
<p><em>streamreader</em> and <em>streamwriter</em>: These have to be factory
functions providing the following interface:</p>
<p><tt class="docutils literal"><span class="pre">factory(stream,</span> <span class="pre">errors='strict')</span></tt></p>
<p>The factory functions must return objects providing the interfaces
defined by the base classes <tt class="docutils literal"><span class="pre">StreamWriter</span></tt> and <tt class="docutils literal"><span class="pre">StreamReader</span></tt>,
respectively. Stream codecs can maintain state.</p>
<p>Possible values for errors are <tt class="docutils literal"><span class="pre">'strict'</span></tt> (raise an exception in
case of an encoding error), <tt class="docutils literal"><span class="pre">'replace'</span></tt> (replace malformed data
with a suitable replacement marker, such as <tt class="docutils literal"><span class="pre">'?'</span></tt>), <tt class="docutils literal"><span class="pre">'ignore'</span></tt>
(ignore malformed data and continue without further notice),
<tt class="docutils literal"><span class="pre">'xmlcharrefreplace'</span></tt> (replace with the appropriate XML character
reference (for encoding only)) and <tt class="docutils literal"><span class="pre">'backslashreplace'</span></tt> (replace
with backslashed escape sequences (for encoding only)) as well as
any other error handling name defined via <tt class="docutils literal"><span class="pre">register_error()</span></tt>.</p>
<p>In case a search function cannot find a given encoding, it should
return <tt class="xref docutils literal"><span class="pre">None</span></tt>.</p>
</blockquote>
<p>codecs.lookup(encoding)</p>
<blockquote>
<p>Looks up the codec info in the Python codec registry and returns a
<tt class="docutils literal"><span class="pre">CodecInfo</span></tt> object as defined above.</p>
<p>Encodings are first looked up in the registry&#8217;s cache. If not
found, the list of registered search functions is scanned. If no
<tt class="docutils literal"><span class="pre">CodecInfo</span></tt> object is found, a <tt class="docutils literal"><span class="pre">LookupError</span></tt> is raised.
Otherwise, the <tt class="docutils literal"><span class="pre">CodecInfo</span></tt> object is stored in the cache and
returned to the caller.</p>
</blockquote>
<p>To simplify access to the various codecs, the module provides these
additional functions which use <tt class="docutils literal"><span class="pre">lookup()</span></tt> for the codec lookup:</p>
<p>codecs.getencoder(encoding)</p>
<blockquote>
<p>Look up the codec for the given encoding and return its encoder
function.</p>
<p>Raises a <tt class="docutils literal"><span class="pre">LookupError</span></tt> in case the encoding cannot be found.</p>
</blockquote>
<p>codecs.getdecoder(encoding)</p>
<blockquote>
<p>Look up the codec for the given encoding and return its decoder
function.</p>
<p>Raises a <tt class="docutils literal"><span class="pre">LookupError</span></tt> in case the encoding cannot be found.</p>
</blockquote>
<p>codecs.getincrementalencoder(encoding)</p>
<blockquote>
<p>Look up the codec for the given encoding and return its incremental
encoder class or factory function.</p>
<p>Raises a <tt class="docutils literal"><span class="pre">LookupError</span></tt> in case the encoding cannot be found or
the codec doesn&#8217;t support an incremental encoder.</p>
<p>New in version 2.5.</p>
</blockquote>
<p>codecs.getincrementaldecoder(encoding)</p>
<blockquote>
<p>Look up the codec for the given encoding and return its incremental
decoder class or factory function.</p>
<p>Raises a <tt class="docutils literal"><span class="pre">LookupError</span></tt> in case the encoding cannot be found or
the codec doesn&#8217;t support an incremental decoder.</p>
<p>New in version 2.5.</p>
</blockquote>
<p>codecs.getreader(encoding)</p>
<blockquote>
<p>Look up the codec for the given encoding and return its
StreamReader class or factory function.</p>
<p>Raises a <tt class="docutils literal"><span class="pre">LookupError</span></tt> in case the encoding cannot be found.</p>
</blockquote>
<p>codecs.getwriter(encoding)</p>
<blockquote>
<p>Look up the codec for the given encoding and return its
StreamWriter class or factory function.</p>
<p>Raises a <tt class="docutils literal"><span class="pre">LookupError</span></tt> in case the encoding cannot be found.</p>
</blockquote>
<p>codecs.register_error(name, error_handler)</p>
<blockquote>
<p>Register the error handling function <em>error_handler</em> under the name
<em>name</em>. <em>error_handler</em> will be called during encoding and decoding
in case of an error, when <em>name</em> is specified as the errors
parameter.</p>
<p>For encoding <em>error_handler</em> will be called with a
<tt class="docutils literal"><span class="pre">UnicodeEncodeError</span></tt> instance, which contains information about
the location of the error. The error handler must either raise this
or a different exception or return a tuple with a replacement for
the unencodable part of the input and a position where encoding
should continue. The encoder will encode the replacement and
continue encoding the original input at the specified position.
Negative position values will be treated as being relative to the
end of the input string. If the resulting position is out of bound
an <tt class="docutils literal"><span class="pre">IndexError</span></tt> will be raised.</p>
<p>Decoding and translating works similar, except
<tt class="docutils literal"><span class="pre">UnicodeDecodeError</span></tt> or <tt class="docutils literal"><span class="pre">UnicodeTranslateError</span></tt> will be passed
to the handler and that the replacement from the error handler will
be put into the output directly.</p>
</blockquote>
<p>codecs.lookup_error(name)</p>
<blockquote>
<p>Return the error handler previously registered under the name
<em>name</em>.</p>
<p>Raises a <tt class="docutils literal"><span class="pre">LookupError</span></tt> in case the handler cannot be found.</p>
</blockquote>
<p>codecs.strict_errors(exception)</p>
<blockquote>
Implements the <tt class="docutils literal"><span class="pre">strict</span></tt> error handling.</blockquote>
<p>codecs.replace_errors(exception)</p>
<blockquote>
Implements the <tt class="docutils literal"><span class="pre">replace</span></tt> error handling.</blockquote>
<p>codecs.ignore_errors(exception)</p>
<blockquote>
Implements the <tt class="docutils literal"><span class="pre">ignore</span></tt> error handling.</blockquote>
<p>codecs.xmlcharrefreplace_errors(exception)</p>
<blockquote>
Implements the <tt class="docutils literal"><span class="pre">xmlcharrefreplace</span></tt> error handling.</blockquote>
<p>codecs.backslashreplace_errors(exception)</p>
<blockquote>
Implements the <tt class="docutils literal"><span class="pre">backslashreplace</span></tt> error handling.</blockquote>
<p>To simplify working with encoded files or stream, the module also
defines these utility functions:</p>
<p>codecs.open(filename, mode[, encoding[, errors[, buffering]]])</p>
<blockquote>
<p>Open an encoded file using the given <em>mode</em> and return a wrapped
version providing transparent encoding/decoding.  The default file
mode is <tt class="docutils literal"><span class="pre">'r'</span></tt> meaning to open the file in read mode.</p>
<dl class="docutils">
<dt>Note: The wrapped version will only accept the object format defined by</dt>
<dd>the codecs, i.e. Unicode objects for most built-in codecs.
Output is also codec-dependent and will usually be Unicode as
well.</dd>
<dt>Note: Files are always opened in binary mode, even if no binary mode</dt>
<dd>was specified.  This is done to avoid data loss due to encodings
using 8-bit values.  This means that no automatic conversion of
<tt class="docutils literal"><span class="pre">'\n'</span></tt> is done on reading and writing.</dd>
</dl>
<p><em>encoding</em> specifies the encoding which is to be used for the file.</p>
<p><em>errors</em> may be given to define the error handling. It defaults to
<tt class="docutils literal"><span class="pre">'strict'</span></tt> which causes a <tt class="docutils literal"><span class="pre">ValueError</span></tt> to be raised in case an
encoding error occurs.</p>
<p><em>buffering</em> has the same meaning as for the built-in <tt class="docutils literal"><span class="pre">open()</span></tt>
function.  It defaults to line buffered.</p>
</blockquote>
<p>codecs.EncodedFile(file, input[, output[, errors]])</p>
<blockquote>
<p>Return a wrapped version of file which provides transparent
encoding translation.</p>
<p>Strings written to the wrapped file are interpreted according to
the given <em>input</em> encoding and then written to the original file as
strings using the <em>output</em> encoding. The intermediate encoding will
usually be Unicode but depends on the specified codecs.</p>
<p>If <em>output</em> is not given, it defaults to <em>input</em>.</p>
<p><em>errors</em> may be given to define the error handling. It defaults to
<tt class="docutils literal"><span class="pre">'strict'</span></tt>, which causes <tt class="docutils literal"><span class="pre">ValueError</span></tt> to be raised in case an
encoding error occurs.</p>
</blockquote>
<p>codecs.iterencode(iterable, encoding[, errors])</p>
<blockquote>
<p>Uses an incremental encoder to iteratively encode the input
provided by <em>iterable</em>. This function is a <em>generator</em>.  <em>errors</em>
(as well as any other keyword argument) is passed through to the
incremental encoder.</p>
<p>New in version 2.5.</p>
</blockquote>
<p>codecs.iterdecode(iterable, encoding[, errors])</p>
<blockquote>
<p>Uses an incremental decoder to iteratively decode the input
provided by <em>iterable</em>. This function is a <em>generator</em>.  <em>errors</em>
(as well as any other keyword argument) is passed through to the
incremental decoder.</p>
<p>New in version 2.5.</p>
</blockquote>
<p>The module also provides the following constants which are useful for
reading and writing to platform dependent files:</p>
<p>codecs.BOM
codecs.BOM_BE
codecs.BOM_LE
codecs.BOM_UTF8
codecs.BOM_UTF16
codecs.BOM_UTF16_BE
codecs.BOM_UTF16_LE
codecs.BOM_UTF32
codecs.BOM_UTF32_BE
codecs.BOM_UTF32_LE</p>
<blockquote>
These constants define various encodings of the Unicode byte order
mark (BOM) used in UTF-16 and UTF-32 data streams to indicate the
byte order used in the stream or file and in UTF-8 as a Unicode
signature. <tt class="docutils literal"><span class="pre">BOM_UTF16</span></tt> is either <tt class="docutils literal"><span class="pre">BOM_UTF16_BE</span></tt> or
<tt class="docutils literal"><span class="pre">BOM_UTF16_LE</span></tt> depending on the platform&#8217;s native byte order,
<tt class="docutils literal"><span class="pre">BOM</span></tt> is an alias for <tt class="docutils literal"><span class="pre">BOM_UTF16</span></tt>, <tt class="docutils literal"><span class="pre">BOM_LE</span></tt> for
<tt class="docutils literal"><span class="pre">BOM_UTF16_LE</span></tt> and <tt class="docutils literal"><span class="pre">BOM_BE</span></tt> for <tt class="docutils literal"><span class="pre">BOM_UTF16_BE</span></tt>. The others
represent the BOM in UTF-8 and UTF-32 encodings.</blockquote>
<div class="section" id="codec-base-classes">
<h2>7.8.1. Codec Base Classes<a class="headerlink" href="#codec-base-classes" title="Permalink to this headline">¶</a></h2>
<p>The <tt class="docutils literal"><span class="pre">codecs</span></tt> module defines a set of base classes which define the
interface and can also be used to easily write your own codecs for use
in Python.</p>
<p>Each codec has to define four interfaces to make it usable as codec in
Python: stateless encoder, stateless decoder, stream reader and stream
writer. The stream reader and writers typically reuse the stateless
encoder/decoder to implement the file protocols.</p>
<p>The <tt class="docutils literal"><span class="pre">Codec</span></tt> class defines the interface for stateless
encoders/decoders.</p>
<p>To simplify and standardize error handling, the <tt class="docutils literal"><span class="pre">encode()</span></tt> and
<tt class="docutils literal"><span class="pre">decode()</span></tt> methods may implement different error handling schemes by
providing the <em>errors</em> string argument.  The following string values
are defined and implemented by all standard Python codecs:</p>
<table border="1" class="docutils">
<colgroup>
<col width="36%" />
<col width="64%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Value</th>
<th class="head">Meaning</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal"><span class="pre">'strict'</span></tt></td>
<td>Raise <tt class="docutils literal"><span class="pre">UnicodeError</span></tt> (or a subclass); this is
the default.</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">'ignore'</span></tt></td>
<td>Ignore the character and continue with the
next.</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">'replace'</span></tt></td>
<td>Replace with a suitable replacement character;
Python will use the official U+FFFD REPLACEMENT
CHARACTER for the built-in Unicode codecs on
decoding and &#8216;?&#8217; on encoding.</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">'xmlcharrefreplace'</span></tt></td>
<td>Replace with the appropriate XML character
reference (only for encoding).</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">'backslashreplace'</span></tt></td>
<td>Replace with backslashed escape sequences (only
for encoding).</td>
</tr>
</tbody>
</table>
<p>The set of allowed values can be extended via <tt class="docutils literal"><span class="pre">register_error()</span></tt>.</p>
<div class="section" id="codec-objects">
<h3>7.8.1.1. Codec Objects<a class="headerlink" href="#codec-objects" title="Permalink to this headline">¶</a></h3>
<p>The <tt class="docutils literal"><span class="pre">Codec</span></tt> class defines these methods which also define the
function interfaces of the stateless encoder and decoder:</p>
<p>Codec.encode(input[, errors])</p>
<blockquote>
<p>Encodes the object <em>input</em> and returns a tuple (output object,
length consumed). While codecs are not restricted to use with
Unicode, in a Unicode context, encoding converts a Unicode object
to a plain string using a particular character set encoding (e.g.,
<tt class="docutils literal"><span class="pre">cp1252</span></tt> or <tt class="docutils literal"><span class="pre">iso-8859-1</span></tt>).</p>
<p><em>errors</em> defines the error handling to apply. It defaults to
<tt class="docutils literal"><span class="pre">'strict'</span></tt> handling.</p>
<p>The method may not store state in the <tt class="docutils literal"><span class="pre">Codec</span></tt> instance. Use
<tt class="docutils literal"><span class="pre">StreamCodec</span></tt> for codecs which have to keep state in order to
make encoding/decoding efficient.</p>
<p>The encoder must be able to handle zero length input and return an
empty object of the output object type in this situation.</p>
</blockquote>
<p>Codec.decode(input[, errors])</p>
<blockquote>
<p>Decodes the object <em>input</em> and returns a tuple (output object,
length consumed). In a Unicode context, decoding converts a plain
string encoded using a particular character set encoding to a
Unicode object.</p>
<p><em>input</em> must be an object which provides the <tt class="docutils literal"><span class="pre">bf_getreadbuf</span></tt>
buffer slot. Python strings, buffer objects and memory mapped files
are examples of objects providing this slot.</p>
<p><em>errors</em> defines the error handling to apply. It defaults to
<tt class="docutils literal"><span class="pre">'strict'</span></tt> handling.</p>
<p>The method may not store state in the <tt class="docutils literal"><span class="pre">Codec</span></tt> instance. Use
<tt class="docutils literal"><span class="pre">StreamCodec</span></tt> for codecs which have to keep state in order to
make encoding/decoding efficient.</p>
<p>The decoder must be able to handle zero length input and return an
empty object of the output object type in this situation.</p>
</blockquote>
<p>The <tt class="docutils literal"><span class="pre">IncrementalEncoder</span></tt> and <tt class="docutils literal"><span class="pre">IncrementalDecoder</span></tt> classes provide
the basic interface for incremental encoding and decoding.
Encoding/decoding the input isn&#8217;t done with one call to the stateless
encoder/decoder function, but with multiple calls to the
<tt class="docutils literal"><span class="pre">encode()</span></tt>/<tt class="docutils literal"><span class="pre">decode()</span></tt> method of the incremental encoder/decoder.
The incremental encoder/decoder keeps track of the encoding/decoding
process during method calls.</p>
<p>The joined output of calls to the <tt class="docutils literal"><span class="pre">encode()</span></tt>/<tt class="docutils literal"><span class="pre">decode()</span></tt> method is
the same as if all the single inputs were joined into one, and this
input was encoded/decoded with the stateless encoder/decoder.</p>
</div>
<div class="section" id="incrementalencoder-objects">
<h3>7.8.1.2. IncrementalEncoder Objects<a class="headerlink" href="#incrementalencoder-objects" title="Permalink to this headline">¶</a></h3>
<p>New in version 2.5.</p>
<p>The <tt class="docutils literal"><span class="pre">IncrementalEncoder</span></tt> class is used for encoding an input in
multiple steps. It defines the following methods which every
incremental encoder must define in order to be compatible with the
Python codec registry.</p>
<p>class class codecs.IncrementalEncoder([errors])</p>
<blockquote>
<p>Constructor for an <tt class="docutils literal"><span class="pre">IncrementalEncoder</span></tt> instance.</p>
<p>All incremental encoders must provide this constructor interface.
They are free to add additional keyword arguments, but only the
ones defined here are used by the Python codec registry.</p>
<p>The <tt class="docutils literal"><span class="pre">IncrementalEncoder</span></tt> may implement different error handling
schemes by providing the <em>errors</em> keyword argument. These
parameters are predefined:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">'strict'</span></tt> Raise <tt class="docutils literal"><span class="pre">ValueError</span></tt> (or a subclass); this is the
default.</li>
<li><tt class="docutils literal"><span class="pre">'ignore'</span></tt> Ignore the character and continue with the next.</li>
<li><tt class="docutils literal"><span class="pre">'replace'</span></tt> Replace with a suitable replacement character</li>
<li><tt class="docutils literal"><span class="pre">'xmlcharrefreplace'</span></tt> Replace with the appropriate XML
character reference</li>
<li><tt class="docutils literal"><span class="pre">'backslashreplace'</span></tt> Replace with backslashed escape sequences.</li>
</ul>
<p>The <em>errors</em> argument will be assigned to an attribute of the same
name. Assigning to this attribute makes it possible to switch
between different error handling strategies during the lifetime of
the <tt class="docutils literal"><span class="pre">IncrementalEncoder</span></tt> object.</p>
<p>The set of allowed values for the <em>errors</em> argument can be extended
with <tt class="docutils literal"><span class="pre">register_error()</span></tt>.</p>
<p>encode(object[, final])</p>
<blockquote>
Encodes <em>object</em> (taking the current state of the encoder into
account) and returns the resulting encoded object. If this is
the last call to <tt class="docutils literal"><span class="pre">encode()</span></tt> <em>final</em> must be true (the default
is false).</blockquote>
<p>reset()</p>
<blockquote>
Reset the encoder to the initial state.</blockquote>
</blockquote>
</div>
<div class="section" id="incrementaldecoder-objects">
<h3>7.8.1.3. IncrementalDecoder Objects<a class="headerlink" href="#incrementaldecoder-objects" title="Permalink to this headline">¶</a></h3>
<p>The <tt class="docutils literal"><span class="pre">IncrementalDecoder</span></tt> class is used for decoding an input in
multiple steps. It defines the following methods which every
incremental decoder must define in order to be compatible with the
Python codec registry.</p>
<p>class class codecs.IncrementalDecoder([errors])</p>
<blockquote>
<p>Constructor for an <tt class="docutils literal"><span class="pre">IncrementalDecoder</span></tt> instance.</p>
<p>All incremental decoders must provide this constructor interface.
They are free to add additional keyword arguments, but only the
ones defined here are used by the Python codec registry.</p>
<p>The <tt class="docutils literal"><span class="pre">IncrementalDecoder</span></tt> may implement different error handling
schemes by providing the <em>errors</em> keyword argument. These
parameters are predefined:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">'strict'</span></tt> Raise <tt class="docutils literal"><span class="pre">ValueError</span></tt> (or a subclass); this is the
default.</li>
<li><tt class="docutils literal"><span class="pre">'ignore'</span></tt> Ignore the character and continue with the next.</li>
<li><tt class="docutils literal"><span class="pre">'replace'</span></tt> Replace with a suitable replacement character.</li>
</ul>
<p>The <em>errors</em> argument will be assigned to an attribute of the same
name. Assigning to this attribute makes it possible to switch
between different error handling strategies during the lifetime of
the <tt class="docutils literal"><span class="pre">IncrementalDecoder</span></tt> object.</p>
<p>The set of allowed values for the <em>errors</em> argument can be extended
with <tt class="docutils literal"><span class="pre">register_error()</span></tt>.</p>
<p>decode(object[, final])</p>
<blockquote>
Decodes <em>object</em> (taking the current state of the decoder into
account) and returns the resulting decoded object. If this is
the last call to <tt class="docutils literal"><span class="pre">decode()</span></tt> <em>final</em> must be true (the default
is false). If <em>final</em> is true the decoder must decode the input
completely and must flush all buffers. If this isn&#8217;t possible
(e.g. because of incomplete byte sequences at the end of the
input) it must initiate error handling just like in the
stateless case (which might raise an exception).</blockquote>
<p>reset()</p>
<blockquote>
Reset the decoder to the initial state.</blockquote>
</blockquote>
<p>The <tt class="docutils literal"><span class="pre">StreamWriter</span></tt> and <tt class="docutils literal"><span class="pre">StreamReader</span></tt> classes provide generic
working interfaces which can be used to implement new encoding
submodules very easily. See <tt class="docutils literal"><span class="pre">encodings.utf_8</span></tt> for an example of how
this is done.</p>
</div>
<div class="section" id="streamwriter-objects">
<h3>7.8.1.4. StreamWriter Objects<a class="headerlink" href="#streamwriter-objects" title="Permalink to this headline">¶</a></h3>
<p>The <tt class="docutils literal"><span class="pre">StreamWriter</span></tt> class is a subclass of <tt class="docutils literal"><span class="pre">Codec</span></tt> and defines the
following methods which every stream writer must define in order to be
compatible with the Python codec registry.</p>
<p>class class codecs.StreamWriter(stream[, errors])</p>
<blockquote>
<p>Constructor for a <tt class="docutils literal"><span class="pre">StreamWriter</span></tt> instance.</p>
<p>All stream writers must provide this constructor interface. They
are free to add additional keyword arguments, but only the ones
defined here are used by the Python codec registry.</p>
<p><em>stream</em> must be a file-like object open for writing binary data.</p>
<p>The <tt class="docutils literal"><span class="pre">StreamWriter</span></tt> may implement different error handling schemes
by providing the <em>errors</em> keyword argument. These parameters are
predefined:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">'strict'</span></tt> Raise <tt class="docutils literal"><span class="pre">ValueError</span></tt> (or a subclass); this is the
default.</li>
<li><tt class="docutils literal"><span class="pre">'ignore'</span></tt> Ignore the character and continue with the next.</li>
<li><tt class="docutils literal"><span class="pre">'replace'</span></tt> Replace with a suitable replacement character</li>
<li><tt class="docutils literal"><span class="pre">'xmlcharrefreplace'</span></tt> Replace with the appropriate XML
character reference</li>
<li><tt class="docutils literal"><span class="pre">'backslashreplace'</span></tt> Replace with backslashed escape sequences.</li>
</ul>
<p>The <em>errors</em> argument will be assigned to an attribute of the same
name. Assigning to this attribute makes it possible to switch
between different error handling strategies during the lifetime of
the <tt class="docutils literal"><span class="pre">StreamWriter</span></tt> object.</p>
<p>The set of allowed values for the <em>errors</em> argument can be extended
with <tt class="docutils literal"><span class="pre">register_error()</span></tt>.</p>
<p>write(object)</p>
<blockquote>
Writes the object&#8217;s contents encoded to the stream.</blockquote>
<p>writelines(list)</p>
<blockquote>
Writes the concatenated list of strings to the stream (possibly
by reusing the <tt class="docutils literal"><span class="pre">write()</span></tt> method).</blockquote>
<p>reset()</p>
<blockquote>
<p>Flushes and resets the codec buffers used for keeping state.</p>
<p>Calling this method should ensure that the data on the output is
put into a clean state that allows appending of new fresh data
without having to rescan the whole stream to recover state.</p>
</blockquote>
</blockquote>
<p>In addition to the above methods, the <tt class="docutils literal"><span class="pre">StreamWriter</span></tt> must also
inherit all other methods and attributes from the underlying stream.</p>
</div>
<div class="section" id="streamreader-objects">
<h3>7.8.1.5. StreamReader Objects<a class="headerlink" href="#streamreader-objects" title="Permalink to this headline">¶</a></h3>
<p>The <tt class="docutils literal"><span class="pre">StreamReader</span></tt> class is a subclass of <tt class="docutils literal"><span class="pre">Codec</span></tt> and defines the
following methods which every stream reader must define in order to be
compatible with the Python codec registry.</p>
<p>class class codecs.StreamReader(stream[, errors])</p>
<blockquote>
<p>Constructor for a <tt class="docutils literal"><span class="pre">StreamReader</span></tt> instance.</p>
<p>All stream readers must provide this constructor interface. They
are free to add additional keyword arguments, but only the ones
defined here are used by the Python codec registry.</p>
<p><em>stream</em> must be a file-like object open for reading (binary) data.</p>
<p>The <tt class="docutils literal"><span class="pre">StreamReader</span></tt> may implement different error handling schemes
by providing the <em>errors</em> keyword argument. These parameters are
defined:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">'strict'</span></tt> Raise <tt class="docutils literal"><span class="pre">ValueError</span></tt> (or a subclass); this is the
default.</li>
<li><tt class="docutils literal"><span class="pre">'ignore'</span></tt> Ignore the character and continue with the next.</li>
<li><tt class="docutils literal"><span class="pre">'replace'</span></tt> Replace with a suitable replacement character.</li>
</ul>
<p>The <em>errors</em> argument will be assigned to an attribute of the same
name. Assigning to this attribute makes it possible to switch
between different error handling strategies during the lifetime of
the <tt class="docutils literal"><span class="pre">StreamReader</span></tt> object.</p>
<p>The set of allowed values for the <em>errors</em> argument can be extended
with <tt class="docutils literal"><span class="pre">register_error()</span></tt>.</p>
<p>read([size[, chars[, firstline]]])</p>
<blockquote>
<p>Decodes data from the stream and returns the resulting object.</p>
<p><em>chars</em> indicates the number of characters to read from the
stream. <tt class="docutils literal"><span class="pre">read()</span></tt> will never return more than <em>chars</em>
characters, but it might return less, if there are not enough
characters available.</p>
<p><em>size</em> indicates the approximate maximum number of bytes to read
from the stream for decoding purposes. The decoder can modify
this setting as appropriate. The default value -1 indicates to
read and decode as much as possible.  <em>size</em> is intended to
prevent having to decode huge files in one step.</p>
<p><em>firstline</em> indicates that it would be sufficient to only return
the first line, if there are decoding errors on later lines.</p>
<p>The method should use a greedy read strategy meaning that it
should read as much data as is allowed within the definition of
the encoding and the given size, e.g.  if optional encoding
endings or state markers are available on the stream, these
should be read too.</p>
<p>Changed in version 2.4: <em>chars</em> argument added.</p>
<p>Changed in version 2.4.2: <em>firstline</em> argument added.</p>
</blockquote>
<p>readline([size[, keepends]])</p>
<blockquote>
<p>Read one line from the input stream and return the decoded data.</p>
<p><em>size</em>, if given, is passed as size argument to the stream&#8217;s
<tt class="docutils literal"><span class="pre">readline()</span></tt> method.</p>
<p>If <em>keepends</em> is false line-endings will be stripped from the
lines returned.</p>
<p>Changed in version 2.4: <em>keepends</em> argument added.</p>
</blockquote>
<p>readlines([sizehint[, keepends]])</p>
<blockquote>
<p>Read all lines available on the input stream and return them as
a list of lines.</p>
<p>Line-endings are implemented using the codec&#8217;s decoder method
and are included in the list entries if <em>keepends</em> is true.</p>
<p><em>sizehint</em>, if given, is passed as the <em>size</em> argument to the
stream&#8217;s <tt class="docutils literal"><span class="pre">read()</span></tt> method.</p>
</blockquote>
<p>reset()</p>
<blockquote>
<p>Resets the codec buffers used for keeping state.</p>
<p>Note that no stream repositioning should take place.  This
method is primarily intended to be able to recover from decoding
errors.</p>
</blockquote>
</blockquote>
<p>In addition to the above methods, the <tt class="docutils literal"><span class="pre">StreamReader</span></tt> must also
inherit all other methods and attributes from the underlying stream.</p>
<p>The next two base classes are included for convenience. They are not
needed by the codec registry, but may provide useful in practice.</p>
</div>
<div class="section" id="streamreaderwriter-objects">
<h3>7.8.1.6. StreamReaderWriter Objects<a class="headerlink" href="#streamreaderwriter-objects" title="Permalink to this headline">¶</a></h3>
<p>The <tt class="docutils literal"><span class="pre">StreamReaderWriter</span></tt> allows wrapping streams which work in both
read and write modes.</p>
<p>The design is such that one can use the factory functions returned by
the <tt class="docutils literal"><span class="pre">lookup()</span></tt> function to construct the instance.</p>
<p>class class codecs.StreamReaderWriter(stream, Reader, Writer, errors)</p>
<blockquote>
Creates a <tt class="docutils literal"><span class="pre">StreamReaderWriter</span></tt> instance. <em>stream</em> must be a file-
like object. <em>Reader</em> and <em>Writer</em> must be factory functions or
classes providing the <tt class="docutils literal"><span class="pre">StreamReader</span></tt> and <tt class="docutils literal"><span class="pre">StreamWriter</span></tt>
interface resp. Error handling is done in the same way as defined
for the stream readers and writers.</blockquote>
<p><tt class="docutils literal"><span class="pre">StreamReaderWriter</span></tt> instances define the combined interfaces of
<tt class="docutils literal"><span class="pre">StreamReader</span></tt> and <tt class="docutils literal"><span class="pre">StreamWriter</span></tt> classes. They inherit all other
methods and attributes from the underlying stream.</p>
</div>
<div class="section" id="streamrecoder-objects">
<h3>7.8.1.7. StreamRecoder Objects<a class="headerlink" href="#streamrecoder-objects" title="Permalink to this headline">¶</a></h3>
<p>The <tt class="docutils literal"><span class="pre">StreamRecoder</span></tt> provide a frontend - backend view of encoding
data which is sometimes useful when dealing with different encoding
environments.</p>
<p>The design is such that one can use the factory functions returned by
the <tt class="docutils literal"><span class="pre">lookup()</span></tt> function to construct the instance.</p>
<p>class class codecs.StreamRecoder(stream, encode, decode, Reader, Writer, errors)</p>
<blockquote>
<p>Creates a <tt class="docutils literal"><span class="pre">StreamRecoder</span></tt> instance which implements a two-way
conversion: <em>encode</em> and <em>decode</em> work on the frontend (the input
to <tt class="docutils literal"><span class="pre">read()</span></tt> and output of <tt class="docutils literal"><span class="pre">write()</span></tt>) while <em>Reader</em> and
<em>Writer</em> work on the backend (reading and writing to the stream).</p>
<p>You can use these objects to do transparent direct recodings from
e.g. Latin-1 to UTF-8 and back.</p>
<p><em>stream</em> must be a file-like object.</p>
<p><em>encode</em>, <em>decode</em> must adhere to the <tt class="docutils literal"><span class="pre">Codec</span></tt> interface.
<em>Reader</em>, <em>Writer</em> must be factory functions or classes providing
objects of the <tt class="docutils literal"><span class="pre">StreamReader</span></tt> and <tt class="docutils literal"><span class="pre">StreamWriter</span></tt> interface
respectively.</p>
<p><em>encode</em> and <em>decode</em> are needed for the frontend translation,
<em>Reader</em> and <em>Writer</em> for the backend translation.  The
intermediate format used is determined by the two sets of codecs,
e.g. the Unicode codecs will use Unicode as the intermediate
encoding.</p>
<p>Error handling is done in the same way as defined for the stream
readers and writers.</p>
</blockquote>
<p><tt class="docutils literal"><span class="pre">StreamRecoder</span></tt> instances define the combined interfaces of
<tt class="docutils literal"><span class="pre">StreamReader</span></tt> and <tt class="docutils literal"><span class="pre">StreamWriter</span></tt> classes. They inherit all other
methods and attributes from the underlying stream.</p>
</div>
</div>
<div class="section" id="encodings-and-unicode">
<h2>7.8.2. Encodings and Unicode<a class="headerlink" href="#encodings-and-unicode" title="Permalink to this headline">¶</a></h2>
<p>Unicode strings are stored internally as sequences of codepoints (to
be precise as <tt class="docutils literal"><span class="pre">Py_UNICODE</span></tt> arrays). Depending on the way Python is
compiled (either via <em>&#8211;enable-unicode=ucs2</em> or <em>&#8211;enable-
unicode=ucs4</em>, with the former being the default) <tt class="docutils literal"><span class="pre">Py_UNICODE</span></tt> is
either a 16-bit or 32-bit data type. Once a Unicode object is used
outside of CPU and memory, CPU endianness and how these arrays are
stored as bytes become an issue.  Transforming a unicode object into a
sequence of bytes is called encoding and recreating the unicode object
from the sequence of bytes is known as decoding.  There are many
different methods for how this transformation can be done (these
methods are also called encodings). The simplest method is to map the
codepoints 0-255 to the bytes <tt class="docutils literal"><span class="pre">0x0</span></tt>-<tt class="docutils literal"><span class="pre">0xff</span></tt>. This means that a
unicode object that contains codepoints above <tt class="docutils literal"><span class="pre">U+00FF</span></tt> can&#8217;t be
encoded with this method (which is called <tt class="docutils literal"><span class="pre">'latin-1'</span></tt> or
<tt class="docutils literal"><span class="pre">'iso-8859-1'</span></tt>). <tt class="docutils literal"><span class="pre">unicode.encode()</span></tt> will raise a
<tt class="docutils literal"><span class="pre">UnicodeEncodeError</span></tt> that looks like this: <tt class="docutils literal"><span class="pre">UnicodeEncodeError:</span>
<span class="pre">'latin-1'</span> <span class="pre">codec</span> <span class="pre">can't</span> <span class="pre">encode</span> <span class="pre">character</span> <span class="pre">u'\u1234'</span> <span class="pre">in</span> <span class="pre">position</span> <span class="pre">3:</span>
<span class="pre">ordinal</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">range(256)</span></tt>.</p>
<p>There&#8217;s another group of encodings (the so called charmap encodings)
that choose a different subset of all unicode code points and how
these codepoints are mapped to the bytes <tt class="docutils literal"><span class="pre">0x0</span></tt>-<tt class="docutils literal"><span class="pre">0xff</span></tt>. To see how
this is done simply open e.g. <tt class="docutils literal"><span class="pre">encodings/cp1252.py</span></tt> (which is an
encoding that is used primarily on Windows). There&#8217;s a string constant
with 256 characters that shows you which character is mapped to which
byte value.</p>
<p>All of these encodings can only encode 256 of the 65536 (or 1114111)
codepoints defined in unicode. A simple and straightforward way that
can store each Unicode code point, is to store each codepoint as two
consecutive bytes. There are two possibilities: Store the bytes in big
endian or in little endian order. These two encodings are called
UTF-16-BE and UTF-16-LE respectively. Their disadvantage is that if
e.g. you use UTF-16-BE on a little endian machine you will always have
to swap bytes on encoding and decoding. UTF-16 avoids this problem:
Bytes will always be in natural endianness. When these bytes are read
by a CPU with a different endianness, then bytes have to be swapped
though. To be able to detect the endianness of a UTF-16 byte sequence,
there&#8217;s the so called BOM (the &#8220;Byte Order Mark&#8221;). This is the Unicode
character <tt class="docutils literal"><span class="pre">U+FEFF</span></tt>. This character will be prepended to every UTF-16
byte sequence. The byte swapped version of this character (<tt class="docutils literal"><span class="pre">0xFFFE</span></tt>)
is an illegal character that may not appear in a Unicode text. So when
the first character in an UTF-16 byte sequence appears to be a
<tt class="docutils literal"><span class="pre">U+FFFE</span></tt> the bytes have to be swapped on decoding. Unfortunately
upto Unicode 4.0 the character <tt class="docutils literal"><span class="pre">U+FEFF</span></tt> had a second purpose as a
<tt class="docutils literal"><span class="pre">ZERO</span> <span class="pre">WIDTH</span> <span class="pre">NO-BREAK</span> <span class="pre">SPACE</span></tt>: A character that has no width and
doesn&#8217;t allow a word to be split. It can e.g. be used to give hints to
a ligature algorithm. With Unicode 4.0 using <tt class="docutils literal"><span class="pre">U+FEFF</span></tt> as a <tt class="docutils literal"><span class="pre">ZERO</span>
<span class="pre">WIDTH</span> <span class="pre">NO-BREAK</span> <span class="pre">SPACE</span></tt> has been deprecated (with <tt class="docutils literal"><span class="pre">U+2060</span></tt> (<tt class="docutils literal"><span class="pre">WORD</span>
<span class="pre">JOINER</span></tt>) assuming this role). Nevertheless Unicode software still
must be able to handle <tt class="docutils literal"><span class="pre">U+FEFF</span></tt> in both roles: As a BOM it&#8217;s a
device to determine the storage layout of the encoded bytes, and
vanishes once the byte sequence has been decoded into a Unicode
string; as a <tt class="docutils literal"><span class="pre">ZERO</span> <span class="pre">WIDTH</span> <span class="pre">NO-BREAK</span> <span class="pre">SPACE</span></tt> it&#8217;s a normal character
that will be decoded like any other.</p>
<p>There&#8217;s another encoding that is able to encoding the full range of
Unicode characters: UTF-8. UTF-8 is an 8-bit encoding, which means
there are no issues with byte order in UTF-8. Each byte in a UTF-8
byte sequence consists of two parts: Marker bits (the most significant
bits) and payload bits. The marker bits are a sequence of zero to six
1 bits followed by a 0 bit. Unicode characters are encoded like this
(with x being payload bits, which when concatenated give the Unicode
character):</p>
<table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="56%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Range</th>
<th class="head">Encoding</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal"><span class="pre">U-00000000</span></tt> ... <tt class="docutils literal"><span class="pre">U-0000007F</span></tt></td>
<td>0xxxxxxx</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">U-00000080</span></tt> ... <tt class="docutils literal"><span class="pre">U-000007FF</span></tt></td>
<td>110xxxxx 10xxxxxx</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">U-00000800</span></tt> ... <tt class="docutils literal"><span class="pre">U-0000FFFF</span></tt></td>
<td>1110xxxx 10xxxxxx 10xxxxxx</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">U-00010000</span></tt> ... <tt class="docutils literal"><span class="pre">U-001FFFFF</span></tt></td>
<td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">U-00200000</span></tt> ... <tt class="docutils literal"><span class="pre">U-03FFFFFF</span></tt></td>
<td>111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">U-04000000</span></tt> ... <tt class="docutils literal"><span class="pre">U-7FFFFFFF</span></tt></td>
<td>1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
10xxxxxx</td>
</tr>
</tbody>
</table>
<p>The least significant bit of the Unicode character is the rightmost x
bit.</p>
<p>As UTF-8 is an 8-bit encoding no BOM is required and any <tt class="docutils literal"><span class="pre">U+FEFF</span></tt>
character in the decoded Unicode string (even if it&#8217;s the first
character) is treated as a <tt class="docutils literal"><span class="pre">ZERO</span> <span class="pre">WIDTH</span> <span class="pre">NO-BREAK</span> <span class="pre">SPACE</span></tt>.</p>
<p>Without external information it&#8217;s impossible to reliably determine
which encoding was used for encoding a Unicode string. Each charmap
encoding can decode any random byte sequence. However that&#8217;s not
possible with UTF-8, as UTF-8 byte sequences have a structure that
doesn&#8217;t allow arbitrary byte sequences. To increase the reliability
with which a UTF-8 encoding can be detected, Microsoft invented a
variant of UTF-8 (that Python 2.5 calls <tt class="docutils literal"><span class="pre">&quot;utf-8-sig&quot;</span></tt>) for its
Notepad program: Before any of the Unicode characters is written to
the file, a UTF-8 encoded BOM (which looks like this as a byte
sequence: <tt class="docutils literal"><span class="pre">0xef</span></tt>, <tt class="docutils literal"><span class="pre">0xbb</span></tt>, <tt class="docutils literal"><span class="pre">0xbf</span></tt>) is written. As it&#8217;s rather
improbable that any charmap encoded file starts with these byte values
(which would e.g. map to</p>
<blockquote>
LATIN SMALL LETTER I WITH DIAERESISRIGHT-POINTING DOUBLE ANGLE QUOTATION MARKINVERTED QUESTION MARK</blockquote>
<p>in iso-8859-1), this increases the probability that a utf-8-sig
encoding can be correctly guessed from the byte sequence. So here the
BOM is not used to be able to determine the byte order used for
generating the byte sequence, but as a signature that helps in
guessing the encoding. On encoding the utf-8-sig codec will write
<tt class="docutils literal"><span class="pre">0xef</span></tt>, <tt class="docutils literal"><span class="pre">0xbb</span></tt>, <tt class="docutils literal"><span class="pre">0xbf</span></tt> as the first three bytes to the file. On
decoding utf-8-sig will skip those three bytes if they appear as the
first three bytes in the file.</p>
</div>
<div class="section" id="standard-encodings">
<h2>7.8.3. Standard Encodings<a class="headerlink" href="#standard-encodings" title="Permalink to this headline">¶</a></h2>
<p>Python comes with a number of codecs built-in, either implemented as C
functions or with dictionaries as mapping tables. The following table
lists the codecs by name, together with a few common aliases, and the
languages for which the encoding is likely used. Neither the list of
aliases nor the list of languages is meant to be exhaustive. Notice
that spelling alternatives that only differ in case or use a hyphen
instead of an underscore are also valid aliases.</p>
<p>Many of the character sets support the same languages. They vary in
individual characters (e.g. whether the EURO SIGN is supported or
not), and in the assignment of characters to code positions. For the
European languages in particular, the following variants typically
exist:</p>
<ul class="simple">
<li>an ISO 8859 codeset</li>
<li>a Microsoft Windows code page, which is typically derived from a
8859 codeset, but replaces control characters with additional
graphic characters</li>
<li>an IBM EBCDIC code page</li>
<li>an IBM PC code page, which is ASCII compatible</li>
</ul>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="39%" />
<col width="39%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Codec</th>
<th class="head">Aliases</th>
<th class="head">Languages</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>ascii</td>
<td>646, us-ascii</td>
<td>English</td>
</tr>
<tr><td>big5</td>
<td>big5-tw, csbig5</td>
<td>Traditional Chinese</td>
</tr>
<tr><td>big5hkscs</td>
<td>big5-hkscs, hkscs</td>
<td>Traditional Chinese</td>
</tr>
<tr><td>cp037</td>
<td>IBM037, IBM039</td>
<td>English</td>
</tr>
<tr><td>cp424</td>
<td>EBCDIC-CP-HE, IBM424</td>
<td>Hebrew</td>
</tr>
<tr><td>cp437</td>
<td>437, IBM437</td>
<td>English</td>
</tr>
<tr><td>cp500</td>
<td>EBCDIC-CP-BE, EBCDIC-CP-CH,
IBM500</td>
<td>Western Europe</td>
</tr>
<tr><td>cp737</td>
<td>&nbsp;</td>
<td>Greek</td>
</tr>
<tr><td>cp775</td>
<td>IBM775</td>
<td>Baltic languages</td>
</tr>
<tr><td>cp850</td>
<td>850, IBM850</td>
<td>Western Europe</td>
</tr>
<tr><td>cp852</td>
<td>852, IBM852</td>
<td>Central and Eastern Europe</td>
</tr>
<tr><td>cp855</td>
<td>855, IBM855</td>
<td>Bulgarian, Byelorussian,
Macedonian, Russian, Serbian</td>
</tr>
<tr><td>cp856</td>
<td>&nbsp;</td>
<td>Hebrew</td>
</tr>
<tr><td>cp857</td>
<td>857, IBM857</td>
<td>Turkish</td>
</tr>
<tr><td>cp860</td>
<td>860, IBM860</td>
<td>Portuguese</td>
</tr>
<tr><td>cp861</td>
<td>861, CP-IS, IBM861</td>
<td>Icelandic</td>
</tr>
<tr><td>cp862</td>
<td>862, IBM862</td>
<td>Hebrew</td>
</tr>
<tr><td>cp863</td>
<td>863, IBM863</td>
<td>Canadian</td>
</tr>
<tr><td>cp864</td>
<td>IBM864</td>
<td>Arabic</td>
</tr>
<tr><td>cp865</td>
<td>865, IBM865</td>
<td>Danish, Norwegian</td>
</tr>
<tr><td>cp866</td>
<td>866, IBM866</td>
<td>Russian</td>
</tr>
<tr><td>cp869</td>
<td>869, CP-GR, IBM869</td>
<td>Greek</td>
</tr>
<tr><td>cp874</td>
<td>&nbsp;</td>
<td>Thai</td>
</tr>
<tr><td>cp875</td>
<td>&nbsp;</td>
<td>Greek</td>
</tr>
<tr><td>cp932</td>
<td>932, ms932, mskanji, ms-kanji</td>
<td>Japanese</td>
</tr>
<tr><td>cp949</td>
<td>949, ms949, uhc</td>
<td>Korean</td>
</tr>
<tr><td>cp950</td>
<td>950, ms950</td>
<td>Traditional Chinese</td>
</tr>
<tr><td>cp1006</td>
<td>&nbsp;</td>
<td>Urdu</td>
</tr>
<tr><td>cp1026</td>
<td>ibm1026</td>
<td>Turkish</td>
</tr>
<tr><td>cp1140</td>
<td>ibm1140</td>
<td>Western Europe</td>
</tr>
<tr><td>cp1250</td>
<td>windows-1250</td>
<td>Central and Eastern Europe</td>
</tr>
<tr><td>cp1251</td>
<td>windows-1251</td>
<td>Bulgarian, Byelorussian,
Macedonian, Russian, Serbian</td>
</tr>
<tr><td>cp1252</td>
<td>windows-1252</td>
<td>Western Europe</td>
</tr>
<tr><td>cp1253</td>
<td>windows-1253</td>
<td>Greek</td>
</tr>
<tr><td>cp1254</td>
<td>windows-1254</td>
<td>Turkish</td>
</tr>
<tr><td>cp1255</td>
<td>windows-1255</td>
<td>Hebrew</td>
</tr>
<tr><td>cp1256</td>
<td>windows1256</td>
<td>Arabic</td>
</tr>
<tr><td>cp1257</td>
<td>windows-1257</td>
<td>Baltic languages</td>
</tr>
<tr><td>cp1258</td>
<td>windows-1258</td>
<td>Vietnamese</td>
</tr>
<tr><td>euc_jp</td>
<td>eucjp, ujis, u-jis</td>
<td>Japanese</td>
</tr>
<tr><td>euc_jis_2004</td>
<td>jisx0213, eucjis2004</td>
<td>Japanese</td>
</tr>
<tr><td>euc_jisx0213</td>
<td>eucjisx0213</td>
<td>Japanese</td>
</tr>
<tr><td>euc_kr</td>
<td>euckr, korean, ksc5601,
ks_c-5601, ks_c-5601-1987,
ksx1001, ks_x-1001</td>
<td>Korean</td>
</tr>
<tr><td>gb2312</td>
<td>chinese, csiso58gb231280, euc-
cn, euccn, eucgb2312-cn,
gb2312-1980, gb2312-80, iso-
ir-58</td>
<td>Simplified Chinese</td>
</tr>
<tr><td>gbk</td>
<td>936, cp936, ms936</td>
<td>Unified Chinese</td>
</tr>
<tr><td>gb18030</td>
<td>gb18030-2000</td>
<td>Unified Chinese</td>
</tr>
<tr><td>hz</td>
<td>hzgb, hz-gb, hz-gb-2312</td>
<td>Simplified Chinese</td>
</tr>
<tr><td>iso2022_jp</td>
<td>csiso2022jp, iso2022jp,
iso-2022-jp</td>
<td>Japanese</td>
</tr>
<tr><td>iso2022_jp_1</td>
<td>iso2022jp-1, iso-2022-jp-1</td>
<td>Japanese</td>
</tr>
<tr><td>iso2022_jp_2</td>
<td>iso2022jp-2, iso-2022-jp-2</td>
<td>Japanese, Korean, Simplified
Chinese, Western Europe, Greek</td>
</tr>
<tr><td>iso2022_jp_2004</td>
<td>iso2022jp-2004, iso-2022-jp-2004</td>
<td>Japanese</td>
</tr>
<tr><td>iso2022_jp_3</td>
<td>iso2022jp-3, iso-2022-jp-3</td>
<td>Japanese</td>
</tr>
<tr><td>iso2022_jp_ext</td>
<td>iso2022jp-ext, iso-2022-jp-ext</td>
<td>Japanese</td>
</tr>
<tr><td>iso2022_kr</td>
<td>csiso2022kr, iso2022kr,
iso-2022-kr</td>
<td>Korean</td>
</tr>
<tr><td>latin_1</td>
<td>iso-8859-1, iso8859-1, 8859,
cp819, latin, latin1, L1</td>
<td>West Europe</td>
</tr>
<tr><td>iso8859_2</td>
<td>iso-8859-2, latin2, L2</td>
<td>Central and Eastern Europe</td>
</tr>
<tr><td>iso8859_3</td>
<td>iso-8859-3, latin3, L3</td>
<td>Esperanto, Maltese</td>
</tr>
<tr><td>iso8859_4</td>
<td>iso-8859-4, latin4, L4</td>
<td>Baltic languages</td>
</tr>
<tr><td>iso8859_5</td>
<td>iso-8859-5, cyrillic</td>
<td>Bulgarian, Byelorussian,
Macedonian, Russian, Serbian</td>
</tr>
<tr><td>iso8859_6</td>
<td>iso-8859-6, arabic</td>
<td>Arabic</td>
</tr>
<tr><td>iso8859_7</td>
<td>iso-8859-7, greek, greek8</td>
<td>Greek</td>
</tr>
<tr><td>iso8859_8</td>
<td>iso-8859-8, hebrew</td>
<td>Hebrew</td>
</tr>
<tr><td>iso8859_9</td>
<td>iso-8859-9, latin5, L5</td>
<td>Turkish</td>
</tr>
<tr><td>iso8859_10</td>
<td>iso-8859-10, latin6, L6</td>
<td>Nordic languages</td>
</tr>
<tr><td>iso8859_13</td>
<td>iso-8859-13</td>
<td>Baltic languages</td>
</tr>
<tr><td>iso8859_14</td>
<td>iso-8859-14, latin8, L8</td>
<td>Celtic languages</td>
</tr>
<tr><td>iso8859_15</td>
<td>iso-8859-15</td>
<td>Western Europe</td>
</tr>
<tr><td>johab</td>
<td>cp1361, ms1361</td>
<td>Korean</td>
</tr>
<tr><td>koi8_r</td>
<td>&nbsp;</td>
<td>Russian</td>
</tr>
<tr><td>koi8_u</td>
<td>&nbsp;</td>
<td>Ukrainian</td>
</tr>
<tr><td>mac_cyrillic</td>
<td>maccyrillic</td>
<td>Bulgarian, Byelorussian,
Macedonian, Russian, Serbian</td>
</tr>
<tr><td>mac_greek</td>
<td>macgreek</td>
<td>Greek</td>
</tr>
<tr><td>mac_iceland</td>
<td>maciceland</td>
<td>Icelandic</td>
</tr>
<tr><td>mac_latin2</td>
<td>maclatin2, maccentraleurope</td>
<td>Central and Eastern Europe</td>
</tr>
<tr><td>mac_roman</td>
<td>macroman</td>
<td>Western Europe</td>
</tr>
<tr><td>mac_turkish</td>
<td>macturkish</td>
<td>Turkish</td>
</tr>
<tr><td>ptcp154</td>
<td>csptcp154, pt154, cp154,
cyrillic-asian</td>
<td>Kazakh</td>
</tr>
<tr><td>shift_jis</td>
<td>csshiftjis, shiftjis, sjis,
s_jis</td>
<td>Japanese</td>
</tr>
<tr><td>shift_jis_2004</td>
<td>shiftjis2004, sjis_2004,
sjis2004</td>
<td>Japanese</td>
</tr>
<tr><td>shift_jisx0213</td>
<td>shiftjisx0213, sjisx0213,
s_jisx0213</td>
<td>Japanese</td>
</tr>
<tr><td>utf_32</td>
<td>U32, utf32</td>
<td>all languages</td>
</tr>
<tr><td>utf_32_be</td>
<td>UTF-32BE</td>
<td>all languages</td>
</tr>
<tr><td>utf_32_le</td>
<td>UTF-32LE</td>
<td>all languages</td>
</tr>
<tr><td>utf_16</td>
<td>U16, utf16</td>
<td>all languages</td>
</tr>
<tr><td>utf_16_be</td>
<td>UTF-16BE</td>
<td>all languages (BMP only)</td>
</tr>
<tr><td>utf_16_le</td>
<td>UTF-16LE</td>
<td>all languages (BMP only)</td>
</tr>
<tr><td>utf_7</td>
<td>U7, unicode-1-1-utf-7</td>
<td>all languages</td>
</tr>
<tr><td>utf_8</td>
<td>U8, UTF, utf8</td>
<td>all languages</td>
</tr>
<tr><td>utf_8_sig</td>
<td>&nbsp;</td>
<td>all languages</td>
</tr>
</tbody>
</table>
<p>A number of codecs are specific to Python, so their codec names have
no meaning outside Python. Some of them don&#8217;t convert from Unicode
strings to byte strings, but instead use the property of the Python
codecs machinery that any bijective function with one argument can be
considered as an encoding.</p>
<p>For the codecs listed below, the result in the &#8220;encoding&#8221; direction is
always a byte string. The result of the &#8220;decoding&#8221; direction is listed
as operand type in the table.</p>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="30%" />
<col width="18%" />
<col width="30%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Codec</th>
<th class="head">Aliases</th>
<th class="head">Operand type</th>
<th class="head">Purpose</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>base64_codec</td>
<td>base64, base-64</td>
<td>byte string</td>
<td>Convert operand to MIME
base64</td>
</tr>
<tr><td>bz2_codec</td>
<td>bz2</td>
<td>byte string</td>
<td>Compress the operand using
bz2</td>
</tr>
<tr><td>hex_codec</td>
<td>hex</td>
<td>byte string</td>
<td>Convert operand to
hexadecimal representation,
with two digits per byte</td>
</tr>
<tr><td>idna</td>
<td>&nbsp;</td>
<td>Unicode string</td>
<td>Implements <strong>RFC 3490</strong>,
see also <tt class="docutils literal"><span class="pre">encodings.idna</span></tt></td>
</tr>
<tr><td>mbcs</td>
<td>dbcs</td>
<td>Unicode string</td>
<td>Windows only: Encode
operand according to the
ANSI codepage (CP_ACP)</td>
</tr>
<tr><td>palmos</td>
<td>&nbsp;</td>
<td>Unicode string</td>
<td>Encoding of PalmOS 3.5</td>
</tr>
<tr><td>punycode</td>
<td>&nbsp;</td>
<td>Unicode string</td>
<td>Implements <strong>RFC 3492</strong></td>
</tr>
<tr><td>quopri_codec</td>
<td>quopri, quoted-printable,
quotedprintable</td>
<td>byte string</td>
<td>Convert operand to MIME
quoted printable</td>
</tr>
<tr><td>raw_unicode_escape</td>
<td>&nbsp;</td>
<td>Unicode string</td>
<td>Produce a string that is
suitable as raw Unicode
literal in Python source
code</td>
</tr>
<tr><td>rot_13</td>
<td>rot13</td>
<td>Unicode string</td>
<td>Returns the Caesar-cypher
encryption of the operand</td>
</tr>
<tr><td>string_escape</td>
<td>&nbsp;</td>
<td>byte string</td>
<td>Produce a string that is
suitable as string literal
in Python source code</td>
</tr>
<tr><td>undefined</td>
<td>&nbsp;</td>
<td>any</td>
<td>Raise an exception for all
conversions. Can be used as
the system encoding if no
automatic <em>coercion</em>
between byte and Unicode
strings is desired.</td>
</tr>
<tr><td>unicode_escape</td>
<td>&nbsp;</td>
<td>Unicode string</td>
<td>Produce a string that is
suitable as Unicode literal
in Python source code</td>
</tr>
<tr><td>unicode_internal</td>
<td>&nbsp;</td>
<td>Unicode string</td>
<td>Return the internal
representation of the
operand</td>
</tr>
<tr><td>uu_codec</td>
<td>uu</td>
<td>byte string</td>
<td>Convert the operand using
uuencode</td>
</tr>
<tr><td>zlib_codec</td>
<td>zip, zlib</td>
<td>byte string</td>
<td>Compress the operand using
gzip</td>
</tr>
</tbody>
</table>
<p>New in version 2.3: The <tt class="docutils literal"><span class="pre">idna</span></tt> and <tt class="docutils literal"><span class="pre">punycode</span></tt> encodings.</p>
</div>
<div class="section" id="encodings-idna-internationalized-domain-names-in-applications">
<h2>7.8.4. <tt class="docutils literal"><span class="pre">encodings.idna</span></tt> &#8212; Internationalized Domain Names in Applications<a class="headerlink" href="#encodings-idna-internationalized-domain-names-in-applications" title="Permalink to this headline">¶</a></h2>
<p>New in version 2.3.</p>
<p>This module implements <strong>RFC 3490</strong> (Internationalized Domain Names in
Applications) and <strong>RFC 3492</strong> (Nameprep: A Stringprep Profile for
Internationalized Domain Names (IDN)). It builds upon the <tt class="docutils literal"><span class="pre">punycode</span></tt>
encoding and <tt class="docutils literal"><span class="pre">stringprep</span></tt>.</p>
<p>These RFCs together define a protocol to support non-ASCII characters
in domain names. A domain name containing non-ASCII characters (such
as <tt class="docutils literal"><span class="pre">www.Alliancefrançaise.nu</span></tt>) is converted into an ASCII-compatible
encoding (ACE, such as <tt class="docutils literal"><span class="pre">www.xn--alliancefranaise-npb.nu</span></tt>). The ACE
form of the domain name is then used in all places where arbitrary
characters are not allowed by the protocol, such as DNS queries, HTTP
<em>Host</em> fields, and so on. This conversion is carried out in the
application; if possible invisible to the user: The application should
transparently convert Unicode domain labels to IDNA on the wire, and
convert back ACE labels to Unicode before presenting them to the user.</p>
<p>Python supports this conversion in several ways: The <tt class="docutils literal"><span class="pre">idna</span></tt> codec
allows to convert between Unicode and the ACE. Furthermore, the
<tt class="docutils literal"><span class="pre">socket</span></tt> module transparently converts Unicode host names to ACE, so
that applications need not be concerned about converting host names
themselves when they pass them to the socket module. On top of that,
modules that have host names as function parameters, such as
<tt class="docutils literal"><span class="pre">httplib</span></tt> and <tt class="docutils literal"><span class="pre">ftplib</span></tt>, accept Unicode host names (<tt class="docutils literal"><span class="pre">httplib</span></tt>
then also transparently sends an IDNA hostname in the <em>Host</em> field if
it sends that field at all).</p>
<p>When receiving host names from the wire (such as in reverse name
lookup), no automatic conversion to Unicode is performed: Applications
wishing to present such host names to the user should decode them to
Unicode.</p>
<p>The module <tt class="docutils literal"><span class="pre">encodings.idna</span></tt> also implements the nameprep procedure,
which performs certain normalizations on host names, to achieve case-
insensitivity of international domain names, and to unify similar
characters. The nameprep functions can be used directly if desired.</p>
<p>encodings.idna.nameprep(label)</p>
<blockquote>
Return the nameprepped version of <em>label</em>. The implementation
currently assumes query strings, so <tt class="docutils literal"><span class="pre">AllowUnassigned</span></tt> is true.</blockquote>
<p>encodings.idna.ToASCII(label)</p>
<blockquote>
Convert a label to ASCII, as specified in <strong>RFC 3490</strong>.
<tt class="docutils literal"><span class="pre">UseSTD3ASCIIRules</span></tt> is assumed to be false.</blockquote>
<p>encodings.idna.ToUnicode(label)</p>
<blockquote>
Convert a label to Unicode, as specified in <strong>RFC 3490</strong>.</blockquote>
</div>
<div class="section" id="encodings-utf-8-sig-utf-8-codec-with-bom-signature">
<h2>7.8.5. <tt class="docutils literal"><span class="pre">encodings.utf_8_sig</span></tt> &#8212; UTF-8 codec with BOM signature<a class="headerlink" href="#encodings-utf-8-sig-utf-8-codec-with-bom-signature" title="Permalink to this headline">¶</a></h2>
<p>New in version 2.5.</p>
<p>This module implements a variant of the UTF-8 codec: On encoding a
UTF-8 encoded BOM will be prepended to the UTF-8 encoded bytes. For
the stateful encoder this is only done once (on the first write to the
byte stream).  For decoding an optional UTF-8 encoded BOM at the start
of the data will be skipped.</p>
</div>
</div>


          </div>
        </div>
      </div>


      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../modindex.html" title="Global Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="unicodedata.html" title="7.9. unicodedata — Unicode Database"
             >next</a> |</li>
        <li class="right" >
          <a href="textwrap.html" title="7.7. textwrap — Text wrapping and filling"
             >previous</a> |</li>
        <li><a href="../index.html">Jython v2.5.2 documentation</a> &raquo;</li>
          <li><a href="indexprogress.html" >The Python Standard Library and What Comes with Jython</a> &raquo;</li>
          <li><a href="strings.html" >7. String Services</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
      &copy; <a href="../copyright.html">Copyright</a> 2011, Jython Project.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 0.6.4.
    </div>
  </body>
</html>