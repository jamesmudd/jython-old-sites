<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>25.4. The Python Profilers &mdash; Jython v2.5.2 documentation</title>
    <link rel="stylesheet" href="../_static/green-theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.5.2',
        COLLAPSE_MODINDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Jython v2.5.2 documentation" href="../index.html" />
    <link rel="up" title="25. Debugging and Profiling" href="debug.html" />
    <link rel="next" title="25.5. timeit — Measure execution time of small code snippets" href="timeit.html" />
    <link rel="prev" title="25.2. pdb — The Python Debugger" href="pdb.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../modindex.html" title="Global Module Index"
             accesskey="M">modules</a> |</li>
        <li class="right" >
          <a href="timeit.html" title="25.5. timeit — Measure execution time of small code snippets"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="pdb.html" title="25.2. pdb — The Python Debugger"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Jython v2.5.2 documentation</a> &raquo;</li>
          <li><a href="indexprogress.html" >The Python Standard Library and What Comes with Jython</a> &raquo;</li>
          <li><a href="debug.html" accesskey="U">25. Debugging and Profiling</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/jython.png" alt="Logo"/>
            </a></p>
            <h3><a href="../index.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference external" href="#">25.4. The Python Profilers</a><ul>
<li><a class="reference external" href="#introduction-to-the-profilers">25.4.1. Introduction to the profilers</a></li>
<li><a class="reference external" href="#instant-user-s-manual">25.4.2. Instant User&#8217;s Manual</a></li>
<li><a class="reference external" href="#what-is-deterministic-profiling">25.4.3. What Is Deterministic Profiling?</a></li>
<li><a class="reference external" href="#reference-manual-profile-and-cprofile">25.4.4. Reference Manual &#8211; <tt class="docutils literal"><span class="pre">profile</span></tt> and <tt class="docutils literal"><span class="pre">cProfile</span></tt></a><ul>
<li><a class="reference external" href="#the-stats-class">25.4.4.1. The <tt class="docutils literal"><span class="pre">Stats</span></tt> Class</a></li>
</ul>
</li>
<li><a class="reference external" href="#limitations">25.4.5. Limitations</a></li>
<li><a class="reference external" href="#calibration">25.4.6. Calibration</a></li>
<li><a class="reference external" href="#extensions-deriving-better-profilers">25.4.7. Extensions &#8212; Deriving Better Profilers</a></li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="pdb.html"
                                  title="previous chapter">25.2. <tt class="docutils literal docutils literal docutils literal"><span class="pre">pdb</span></tt> &#8212; The Python Debugger</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="timeit.html"
                                  title="next chapter">25.5. <tt class="docutils literal"><span class="pre">timeit</span></tt> &#8212; Measure execution time of small code snippets</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../_sources/library/profile.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="../search.html" method="get">
                <input type="text" name="q" size="18" />
                <input type="submit" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="the-python-profilers">
<h1>25.4. The Python Profilers<a class="headerlink" href="#the-python-profilers" title="Permalink to this headline">¶</a></h1>
<p>Copyright © 1994, by InfoSeek Corporation, all rights reserved.</p>
<p>Written by James Roskind. [1]</p>
<p>Permission to use, copy, modify, and distribute this Python software
and its associated documentation for any purpose (subject to the
restriction in the following sentence) without fee is hereby granted,
provided that the above copyright notice appears in all copies, and
that both that copyright notice and this permission notice appear in
supporting documentation, and that the name of InfoSeek not be used in
advertising or publicity pertaining to distribution of the software
without specific, written prior permission.  This permission is
explicitly restricted to the copying and modification of the software
to remain in Python, compiled Python, or other languages (such as C)
wherein the modified or derived code is exclusively imported into a
Python module.</p>
<p>INFOSEEK CORPORATION DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS. IN NO EVENT SHALL INFOSEEK CORPORATION BE LIABLE FOR ANY
SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</p>
<div class="section" id="introduction-to-the-profilers">
<h2>25.4.1. Introduction to the profilers<a class="headerlink" href="#introduction-to-the-profilers" title="Permalink to this headline">¶</a></h2>
<p>A <em>profiler</em> is a program that describes the run time performance of a
program, providing a variety of statistics.  This documentation
describes the profiler functionality provided in the modules
<tt class="docutils literal"><span class="pre">cProfile</span></tt>, <tt class="docutils literal"><span class="pre">profile</span></tt> and <tt class="docutils literal"><span class="pre">pstats</span></tt>.  This profiler provides
<em>deterministic profiling</em> of Python programs.  It also provides a
series of report generation tools to allow users to rapidly examine
the results of a profile operation.</p>
<p>The Python standard library provides three different profilers:</p>
<ol class="arabic">
<li><p class="first"><tt class="docutils literal"><span class="pre">cProfile</span></tt> is recommended for most users; it&#8217;s a C extension with
reasonable overhead that makes it suitable for profiling long-
running programs. Based on <tt class="docutils literal"><span class="pre">lsprof</span></tt>, contributed by Brett Rosen
and Ted Czotter.</p>
<p>New in version 2.5.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">profile</span></tt>, a pure Python module whose interface is imitated by
<tt class="docutils literal"><span class="pre">cProfile</span></tt>.  Adds significant overhead to profiled programs. If
you&#8217;re trying to extend the profiler in some way, the task might be
easier with this module. Copyright © 1994, by InfoSeek Corporation.</p>
<p>Changed in version 2.4: Now also reports the time spent in calls to
built-in functions and methods.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">hotshot</span></tt> was an experimental C module that focused on minimizing
the overhead of profiling, at the expense of longer data post-
processing times.  It is no longer maintained and may be dropped in
a future version of Python.</p>
<p>Changed in version 2.5: The results should be more meaningful than
in the past: the timing core contained a critical bug.</p>
</li>
</ol>
<p>The <tt class="docutils literal"><span class="pre">profile</span></tt> and <tt class="docutils literal"><span class="pre">cProfile</span></tt> modules export the same interface, so
they are mostly interchangeable; <tt class="docutils literal"><span class="pre">cProfile</span></tt> has a much lower
overhead but is newer and might not be available on all systems.
<tt class="docutils literal"><span class="pre">cProfile</span></tt> is really a compatibility layer on top of the internal
<tt class="docutils literal"><span class="pre">_lsprof</span></tt> module.  The <tt class="docutils literal"><span class="pre">hotshot</span></tt> module is reserved for
specialized usage.</p>
</div>
<div class="section" id="instant-user-s-manual">
<h2>25.4.2. Instant User&#8217;s Manual<a class="headerlink" href="#instant-user-s-manual" title="Permalink to this headline">¶</a></h2>
<p>This section is provided for users that &#8220;don&#8217;t want to read the
manual.&#8221; It provides a very brief overview, and allows a user to
rapidly perform profiling on an existing application.</p>
<p>To profile an application with a main entry point of <tt class="docutils literal"><span class="pre">foo()</span></tt>, you
would add the following to your module:</p>
<blockquote>
import cProfile
cProfile.run(&#8216;foo()&#8217;)</blockquote>
<p>(Use <tt class="docutils literal"><span class="pre">profile</span></tt> instead of <tt class="docutils literal"><span class="pre">cProfile</span></tt> if the latter is not
available on your system.)</p>
<p>The above action would cause <tt class="docutils literal"><span class="pre">foo()</span></tt> to be run, and a series of
informative lines (the profile) to be printed.  The above approach is
most useful when working with the interpreter.  If you would like to
save the results of a profile into a file for later examination, you
can supply a file name as the second argument to the <tt class="docutils literal"><span class="pre">run()</span></tt>
function:</p>
<blockquote>
import cProfile
cProfile.run(&#8216;foo()&#8217;, &#8216;fooprof&#8217;)</blockquote>
<p>The file <tt class="docutils literal"><span class="pre">cProfile.py</span></tt> can also be invoked as a script to profile
another script.  For example:</p>
<blockquote>
python -m cProfile myscript.py</blockquote>
<p><tt class="docutils literal"><span class="pre">cProfile.py</span></tt> accepts two optional arguments on the command line:</p>
<blockquote>
cProfile.py [-o output_file] [-s sort_order]</blockquote>
<p><em>-s</em> only applies to standard output (<em>-o</em> is not supplied). Look in
the <tt class="docutils literal"><span class="pre">Stats</span></tt> documentation for valid sort values.</p>
<p>When you wish to review the profile, you should use the methods in the
<tt class="docutils literal"><span class="pre">pstats</span></tt> module.  Typically you would load the statistics data as
follows:</p>
<blockquote>
import pstats
p = pstats.Stats(&#8216;fooprof&#8217;)</blockquote>
<p>The class <tt class="docutils literal"><span class="pre">Stats</span></tt> (the above code just created an instance of this
class) has a variety of methods for manipulating and printing the data
that was just read into <tt class="docutils literal"><span class="pre">p</span></tt>.  When you ran <tt class="docutils literal"><span class="pre">cProfile.run()</span></tt> above,
what was printed was the result of three method calls:</p>
<blockquote>
p.strip_dirs().sort_stats(-1).print_stats()</blockquote>
<p>The first method removed the extraneous path from all the module
names. The second method sorted all the entries according to the
standard module/line/name string that is printed. The third method
printed out all the statistics.  You might try the following sort
calls:</p>
<blockquote>
p.sort_stats(&#8216;name&#8217;)
p.print_stats()</blockquote>
<p>The first call will actually sort the list by function name, and the
second call will print out the statistics.  The following are some
interesting calls to experiment with:</p>
<blockquote>
p.sort_stats(&#8216;cumulative&#8217;).print_stats(10)</blockquote>
<p>This sorts the profile by cumulative time in a function, and then only
prints the ten most significant lines.  If you want to understand what
algorithms are taking time, the above line is what you would use.</p>
<p>If you were looking to see what functions were looping a lot, and
taking a lot of time, you would do:</p>
<blockquote>
p.sort_stats(&#8216;time&#8217;).print_stats(10)</blockquote>
<p>to sort according to time spent within each function, and then print
the statistics for the top ten functions.</p>
<p>You might also try:</p>
<blockquote>
p.sort_stats(&#8216;file&#8217;).print_stats(&#8216;__init__&#8217;)</blockquote>
<p>This will sort all the statistics by file name, and then print out
statistics for only the class init methods (since they are spelled
with <tt class="docutils literal"><span class="pre">__init__</span></tt> in them).  As one final example, you could try:</p>
<blockquote>
p.sort_stats(&#8216;time&#8217;, &#8216;cum&#8217;).print_stats(.5, &#8216;init&#8217;)</blockquote>
<p>This line sorts statistics with a primary key of time, and a secondary
key of cumulative time, and then prints out some of the statistics. To
be specific, the list is first culled down to 50% (re: <tt class="docutils literal"><span class="pre">.5</span></tt>) of its
original size, then only lines containing <tt class="docutils literal"><span class="pre">init</span></tt> are maintained, and
that sub-sub-list is printed.</p>
<p>If you wondered what functions called the above functions, you could
now (<tt class="docutils literal"><span class="pre">p</span></tt> is still sorted according to the last criteria) do:</p>
<blockquote>
p.print_callers(.5, &#8216;init&#8217;)</blockquote>
<p>and you would get a list of callers for each of the listed functions.</p>
<p>If you want more functionality, you&#8217;re going to have to read the
manual, or guess what the following functions do:</p>
<blockquote>
p.print_callees()
p.add(&#8216;fooprof&#8217;)</blockquote>
<p>Invoked as a script, the <tt class="docutils literal"><span class="pre">pstats</span></tt> module is a statistics browser for
reading and examining profile dumps.  It has a simple line-oriented
interface (implemented using <tt class="docutils literal"><span class="pre">cmd</span></tt>) and interactive help.</p>
</div>
<div class="section" id="what-is-deterministic-profiling">
<h2>25.4.3. What Is Deterministic Profiling?<a class="headerlink" href="#what-is-deterministic-profiling" title="Permalink to this headline">¶</a></h2>
<p><em>Deterministic profiling</em> is meant to reflect the fact that all
<em>function call</em>, <em>function return</em>, and <em>exception</em> events are
monitored, and precise timings are made for the intervals between
these events (during which time the user&#8217;s code is executing).  In
contrast, <em>statistical profiling</em> (which is not done by this module)
randomly samples the effective instruction pointer, and deduces where
time is being spent.  The latter technique traditionally involves less
overhead (as the code does not need to be instrumented), but provides
only relative indications of where time is being spent.</p>
<p>In Python, since there is an interpreter active during execution, the
presence of instrumented code is not required to do deterministic
profiling.  Python automatically provides a <em>hook</em> (optional callback)
for each event.  In addition, the interpreted nature of Python tends
to add so much overhead to execution, that deterministic profiling
tends to only add small processing overhead in typical applications.
The result is that deterministic profiling is not that expensive, yet
provides extensive run time statistics about the execution of a Python
program.</p>
<p>Call count statistics can be used to identify bugs in code (surprising
counts), and to identify possible inline-expansion points (high call
counts).  Internal time statistics can be used to identify &#8220;hot loops&#8221;
that should be carefully optimized.  Cumulative time statistics should
be used to identify high level errors in the selection of algorithms.
Note that the unusual handling of cumulative times in this profiler
allows statistics for recursive implementations of algorithms to be
directly compared to iterative implementations.</p>
</div>
<div class="section" id="reference-manual-profile-and-cprofile">
<h2>25.4.4. Reference Manual &#8211; <tt class="docutils literal"><span class="pre">profile</span></tt> and <tt class="docutils literal"><span class="pre">cProfile</span></tt><a class="headerlink" href="#reference-manual-profile-and-cprofile" title="Permalink to this headline">¶</a></h2>
<p>The primary entry point for the profiler is the global function
<tt class="docutils literal"><span class="pre">profile.run()</span></tt> (resp. <tt class="docutils literal"><span class="pre">cProfile.run()</span></tt>). It is typically used to
create any profile information.  The reports are formatted and printed
using methods of the class <tt class="docutils literal"><span class="pre">pstats.Stats</span></tt>.  The following is a
description of all of these standard entry points and functions.  For
a more in-depth view of some of the code, consider reading the later
section on Profiler Extensions, which includes discussion of how to
derive &#8220;better&#8221; profilers from the classes presented, or reading the
source code for these modules.</p>
<p>cProfile.run(command[, filename])</p>
<blockquote>
<p>This function takes a single argument that can be passed to the
<tt class="docutils literal"><span class="pre">exec</span></tt> statement, and an optional file name.  In all cases this
routine attempts to <tt class="docutils literal"><span class="pre">exec</span></tt> its first argument, and gather
profiling statistics from the execution. If no file name is
present, then this function automatically prints a simple profiling
report, sorted by the standard name string (file/line/function-
name) that is presented in each line.  The following is a typical
output from such a call:</p>
<blockquote>
<blockquote>
2706 function calls (2004 primitive calls) in 4.504 CPU seconds</blockquote>
<p>Ordered by: standard name</p>
<dl class="docutils">
<dt>ncalls  tottime  percall  cumtime  percall filename:lineno(function)</dt>
<dd><blockquote class="first">
<blockquote>
2    0.006    0.003    0.953    0.477 pobject.py:75(save_objects)</blockquote>
<p>43/3    0.533    0.012    0.749    0.250 pobject.py:99(evaluate)</p>
</blockquote>
<p class="last">...</p>
</dd>
</dl>
</blockquote>
<p>The first line indicates that 2706 calls were monitored.  Of those
calls, 2004 were <em>primitive</em>.  We define <em>primitive</em> to mean that
the call was not induced via recursion. The next line: <tt class="docutils literal"><span class="pre">Ordered</span>
<span class="pre">by:</span> <span class="pre">standard</span> <span class="pre">name</span></tt>, indicates that the text string in the far
right column was used to sort the output. The column headings
include:</p>
<dl class="docutils">
<dt>ncalls</dt>
<dd>for the number of calls,</dd>
<dt>tottime</dt>
<dd>for the total time spent in the given function (and excluding
time made in calls to sub-functions),</dd>
<dt>percall</dt>
<dd>is the quotient of <tt class="docutils literal"><span class="pre">tottime</span></tt> divided by <tt class="docutils literal"><span class="pre">ncalls</span></tt></dd>
<dt>cumtime</dt>
<dd>is the total time spent in this and all subfunctions (from
invocation till exit). This figure is accurate <em>even</em> for
recursive functions.</dd>
<dt>percall</dt>
<dd>is the quotient of <tt class="docutils literal"><span class="pre">cumtime</span></tt> divided by primitive calls</dd>
<dt>filename:lineno(function)</dt>
<dd>provides the respective data of each function</dd>
</dl>
<p>When there are two numbers in the first column (for example,
<tt class="docutils literal"><span class="pre">43/3</span></tt>), then the latter is the number of primitive calls, and
the former is the actual number of calls.  Note that when the
function does not recurse, these two values are the same, and only
the single figure is printed.</p>
</blockquote>
<p>cProfile.runctx(command, globals, locals[, filename])</p>
<blockquote>
This function is similar to <tt class="docutils literal"><span class="pre">run()</span></tt>, with added arguments to
supply the globals and locals dictionaries for the <em>command</em>
string.</blockquote>
<p>Analysis of the profiler data is done using the <tt class="docutils literal"><span class="pre">Stats</span></tt> class.</p>
<p>Note: The <tt class="docutils literal"><span class="pre">Stats</span></tt> class is defined in the <tt class="docutils literal"><span class="pre">pstats</span></tt> module.</p>
<p>class class pstats.Stats(filename[, stream=sys.stdout[, ...]])</p>
<blockquote>
<p>This class constructor creates an instance of a &#8220;statistics object&#8221;
from a <em>filename</em> (or set of filenames).  <tt class="docutils literal"><span class="pre">Stats</span></tt> objects are
manipulated by methods, in order to print useful reports.  You may
specify an alternate output stream by giving the keyword argument,
<tt class="docutils literal"><span class="pre">stream</span></tt>.</p>
<p>The file selected by the above constructor must have been created
by the corresponding version of <tt class="docutils literal"><span class="pre">profile</span></tt> or <tt class="docutils literal"><span class="pre">cProfile</span></tt>.  To be
specific, there is <em>no</em> file compatibility guaranteed with future
versions of this profiler, and there is no compatibility with files
produced by other profilers. If several files are provided, all the
statistics for identical functions will be coalesced, so that an
overall view of several processes can be considered in a single
report.  If additional files need to be combined with data in an
existing <tt class="docutils literal"><span class="pre">Stats</span></tt> object, the <tt class="docutils literal"><span class="pre">add()</span></tt> method can be used.</p>
<p>Changed in version 2.5: The <em>stream</em> parameter was added.</p>
</blockquote>
<div class="section" id="the-stats-class">
<h3>25.4.4.1. The <tt class="docutils literal"><span class="pre">Stats</span></tt> Class<a class="headerlink" href="#the-stats-class" title="Permalink to this headline">¶</a></h3>
<p><tt class="docutils literal"><span class="pre">Stats</span></tt> objects have the following methods:</p>
<p>Stats.strip_dirs()</p>
<blockquote>
This method for the <tt class="docutils literal"><span class="pre">Stats</span></tt> class removes all leading path
information from file names.  It is very useful in reducing the
size of the printout to fit within (close to) 80 columns.  This
method modifies the object, and the stripped information is lost.
After performing a strip operation, the object is considered to
have its entries in a &#8220;random&#8221; order, as it was just after object
initialization and loading.  If <tt class="docutils literal"><span class="pre">strip_dirs()</span></tt> causes two
function names to be indistinguishable (they are on the same line
of the same filename, and have the same function name), then the
statistics for these two entries are accumulated into a single
entry.</blockquote>
<p>Stats.add(filename[, ...])</p>
<blockquote>
This method of the <tt class="docutils literal"><span class="pre">Stats</span></tt> class accumulates additional profiling
information into the current profiling object.  Its arguments
should refer to filenames created by the corresponding version of
<tt class="docutils literal"><span class="pre">profile.run()</span></tt> or <tt class="docutils literal"><span class="pre">cProfile.run()</span></tt>. Statistics for identically
named (re: file, line, name) functions are automatically
accumulated into single function statistics.</blockquote>
<p>Stats.dump_stats(filename)</p>
<blockquote>
<p>Save the data loaded into the <tt class="docutils literal"><span class="pre">Stats</span></tt> object to a file named
<em>filename</em>. The file is created if it does not exist, and is
overwritten if it already exists.  This is equivalent to the method
of the same name on the <tt class="docutils literal"><span class="pre">profile.Profile</span></tt> and
<tt class="docutils literal"><span class="pre">cProfile.Profile</span></tt> classes.</p>
<p>New in version 2.3.</p>
</blockquote>
<p>Stats.sort_stats(key[, ...])</p>
<blockquote>
<p>This method modifies the <tt class="docutils literal"><span class="pre">Stats</span></tt> object by sorting it according
to the supplied criteria.  The argument is typically a string
identifying the basis of a sort (example: <tt class="docutils literal"><span class="pre">'time'</span></tt> or
<tt class="docutils literal"><span class="pre">'name'</span></tt>).</p>
<p>When more than one key is provided, then additional keys are used
as secondary criteria when there is equality in all keys selected
before them.  For example, <tt class="docutils literal"><span class="pre">sort_stats('name',</span> <span class="pre">'file')</span></tt> will sort
all the entries according to their function name, and resolve all
ties (identical function names) by sorting by file name.</p>
<p>Abbreviations can be used for any key names, as long as the
abbreviation is unambiguous.  The following are the keys currently
defined:</p>
<table border="1" class="docutils">
<colgroup>
<col width="45%" />
<col width="55%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Valid Arg</th>
<th class="head">Meaning</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal"><span class="pre">'calls'</span></tt></td>
<td>call count</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">'cumulative'</span></tt></td>
<td>cumulative time</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">'file'</span></tt></td>
<td>file name</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">'module'</span></tt></td>
<td>file name</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">'pcalls'</span></tt></td>
<td>primitive call count</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">'line'</span></tt></td>
<td>line number</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">'name'</span></tt></td>
<td>function name</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">'nfl'</span></tt></td>
<td>name/file/line</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">'stdname'</span></tt></td>
<td>standard name</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">'time'</span></tt></td>
<td>internal time</td>
</tr>
</tbody>
</table>
<p>Note that all sorts on statistics are in descending order (placing
most time consuming items first), where as name, file, and line
number searches are in ascending order (alphabetical). The subtle
distinction between <tt class="docutils literal"><span class="pre">'nfl'</span></tt> and <tt class="docutils literal"><span class="pre">'stdname'</span></tt> is that the
standard name is a sort of the name as printed, which means that
the embedded line numbers get compared in an odd way.  For example,
lines 3, 20, and 40 would (if the file names were the same) appear
in the string order 20, 3 and 40.  In contrast, <tt class="docutils literal"><span class="pre">'nfl'</span></tt> does a
numeric compare of the line numbers.  In fact,
<tt class="docutils literal"><span class="pre">sort_stats('nfl')</span></tt> is the same as <tt class="docutils literal"><span class="pre">sort_stats('name',</span> <span class="pre">'file',</span>
<span class="pre">'line')</span></tt>.</p>
<p>For backward-compatibility reasons, the numeric arguments <tt class="docutils literal"><span class="pre">-1</span></tt>,
<tt class="docutils literal"><span class="pre">0</span></tt>, <tt class="docutils literal"><span class="pre">1</span></tt>, and <tt class="docutils literal"><span class="pre">2</span></tt> are permitted.  They are interpreted as
<tt class="docutils literal"><span class="pre">'stdname'</span></tt>, <tt class="docutils literal"><span class="pre">'calls'</span></tt>, <tt class="docutils literal"><span class="pre">'time'</span></tt>, and <tt class="docutils literal"><span class="pre">'cumulative'</span></tt>
respectively.  If this old style format (numeric) is used, only one
sort key (the numeric key) will be used, and additional arguments
will be silently ignored.</p>
</blockquote>
<p>Stats.reverse_order()</p>
<blockquote>
This method for the <tt class="docutils literal"><span class="pre">Stats</span></tt> class reverses the ordering of the
basic list within the object.  Note that by default ascending vs
descending order is properly selected based on the sort key of
choice.</blockquote>
<p>Stats.print_stats([restriction, ...])</p>
<blockquote>
<p>This method for the <tt class="docutils literal"><span class="pre">Stats</span></tt> class prints out a report as
described in the <tt class="docutils literal"><span class="pre">profile.run()</span></tt> definition.</p>
<p>The order of the printing is based on the last <tt class="docutils literal"><span class="pre">sort_stats()</span></tt>
operation done on the object (subject to caveats in <tt class="docutils literal"><span class="pre">add()</span></tt> and
<tt class="docutils literal"><span class="pre">strip_dirs()</span></tt>).</p>
<p>The arguments provided (if any) can be used to limit the list down
to the significant entries.  Initially, the list is taken to be the
complete set of profiled functions.  Each restriction is either an
integer (to select a count of lines), or a decimal fraction between
0.0 and 1.0 inclusive (to select a percentage of lines), or a
regular expression (to pattern match the standard name that is
printed; as of Python 1.5b1, this uses the Perl-style regular
expression syntax defined by the <tt class="docutils literal"><span class="pre">re</span></tt> module).  If several
restrictions are provided, then they are applied sequentially.  For
example:</p>
<blockquote>
print_stats(.1, &#8216;foo:&#8217;)</blockquote>
<p>would first limit the printing to first 10% of list, and then only
print functions that were part of filename <tt class="docutils literal"><span class="pre">.*foo:</span></tt>.  In
contrast, the command:</p>
<blockquote>
print_stats(&#8216;foo:&#8217;, .1)</blockquote>
<p>would limit the list to all functions having file names <tt class="docutils literal"><span class="pre">.*foo:</span></tt>,
and then proceed to only print the first 10% of them.</p>
</blockquote>
<p>Stats.print_callers([restriction, ...])</p>
<blockquote>
<p>This method for the <tt class="docutils literal"><span class="pre">Stats</span></tt> class prints a list of all functions
that called each function in the profiled database.  The ordering
is identical to that provided by <tt class="docutils literal"><span class="pre">print_stats()</span></tt>, and the
definition of the restricting argument is also identical.  Each
caller is reported on its own line.  The format differs slightly
depending on the profiler that produced the stats:</p>
<ul class="simple">
<li>With <tt class="docutils literal"><span class="pre">profile</span></tt>, a number is shown in parentheses after each
caller to show how many times this specific call was made.  For
convenience, a second non-parenthesized number repeats the
cumulative time spent in the function at the right.</li>
<li>With <tt class="docutils literal"><span class="pre">cProfile</span></tt>, each caller is preceded by three numbers: the
number of times this specific call was made, and the total and
cumulative times spent in the current function while it was
invoked by this specific caller.</li>
</ul>
</blockquote>
<p>Stats.print_callees([restriction, ...])</p>
<blockquote>
This method for the <tt class="docutils literal"><span class="pre">Stats</span></tt> class prints a list of all function
that were called by the indicated function.  Aside from this
reversal of direction of calls (re: called vs was called by), the
arguments and ordering are identical to the <tt class="docutils literal"><span class="pre">print_callers()</span></tt>
method.</blockquote>
</div>
</div>
<div class="section" id="limitations">
<h2>25.4.5. Limitations<a class="headerlink" href="#limitations" title="Permalink to this headline">¶</a></h2>
<p>One limitation has to do with accuracy of timing information. There is
a fundamental problem with deterministic profilers involving accuracy.
The most obvious restriction is that the underlying &#8220;clock&#8221; is only
ticking at a rate (typically) of about .001 seconds.  Hence no
measurements will be more accurate than the underlying clock.  If
enough measurements are taken, then the &#8220;error&#8221; will tend to average
out. Unfortunately, removing this first error induces a second source
of error.</p>
<p>The second problem is that it &#8220;takes a while&#8221; from when an event is
dispatched until the profiler&#8217;s call to get the time actually <em>gets</em>
the state of the clock.  Similarly, there is a certain lag when
exiting the profiler event handler from the time that the clock&#8217;s
value was obtained (and then squirreled away), until the user&#8217;s code
is once again executing.  As a result, functions that are called many
times, or call many functions, will typically accumulate this error.
The error that accumulates in this fashion is typically less than the
accuracy of the clock (less than one clock tick), but it <em>can</em>
accumulate and become very significant.</p>
<p>The problem is more important with <tt class="docutils literal"><span class="pre">profile</span></tt> than with the lower-
overhead <tt class="docutils literal"><span class="pre">cProfile</span></tt>.  For this reason, <tt class="docutils literal"><span class="pre">profile</span></tt> provides a means
of calibrating itself for a given platform so that this error can be
probabilistically (on the average) removed. After the profiler is
calibrated, it will be more accurate (in a least square sense), but it
will sometimes produce negative numbers (when call counts are
exceptionally low, and the gods of probability work against you :-). )
Do <em>not</em> be alarmed by negative numbers in the profile.  They should
<em>only</em> appear if you have calibrated your profiler, and the results
are actually better than without calibration.</p>
</div>
<div class="section" id="calibration">
<h2>25.4.6. Calibration<a class="headerlink" href="#calibration" title="Permalink to this headline">¶</a></h2>
<p>The profiler of the <tt class="docutils literal"><span class="pre">profile</span></tt> module subtracts a constant from each
event handling time to compensate for the overhead of calling the time
function, and socking away the results.  By default, the constant is
0. The following procedure can be used to obtain a better constant for
a given platform (see discussion in section Limitations above).</p>
<blockquote>
<p>import profile
pr = profile.Profile()
for i in range(5):</p>
<blockquote>
print pr.calibrate(10000)</blockquote>
</blockquote>
<p>The method executes the number of Python calls given by the argument,
directly and again under the profiler, measuring the time for both. It
then computes the hidden overhead per profiler event, and returns that
as a float.  For example, on an 800 MHz Pentium running Windows 2000,
and using Python&#8217;s time.clock() as the timer, the magical number is
about 12.5e-6.</p>
<p>The object of this exercise is to get a fairly consistent result. If
your computer is <em>very</em> fast, or your timer function has poor
resolution, you might have to pass 100000, or even 1000000, to get
consistent results.</p>
<p>When you have a consistent answer, there are three ways you can use
it: [2]</p>
<blockquote>
<p>import profile</p>
<p># 1. Apply computed bias to all Profile instances created hereafter.
profile.Profile.bias = your_computed_bias</p>
<p># 2. Apply computed bias to a specific Profile instance.
pr = profile.Profile()
pr.bias = your_computed_bias</p>
<p># 3. Specify computed bias in instance constructor.
pr = profile.Profile(bias=your_computed_bias)</p>
</blockquote>
<p>If you have a choice, you are better off choosing a smaller constant,
and then your results will &#8220;less often&#8221; show up as negative in profile
statistics.</p>
</div>
<div class="section" id="extensions-deriving-better-profilers">
<h2>25.4.7. Extensions &#8212; Deriving Better Profilers<a class="headerlink" href="#extensions-deriving-better-profilers" title="Permalink to this headline">¶</a></h2>
<p>The <tt class="docutils literal"><span class="pre">Profile</span></tt> class of both modules, <tt class="docutils literal"><span class="pre">profile</span></tt> and <tt class="docutils literal"><span class="pre">cProfile</span></tt>,
were written so that derived classes could be developed to extend the
profiler. The details are not described here, as doing this
successfully requires an expert understanding of how the <tt class="docutils literal"><span class="pre">Profile</span></tt>
class works internally.  Study the source code of the module carefully
if you want to pursue this.</p>
<p>If all you want to do is change how current time is determined (for
example, to force use of wall-clock time or elapsed process time),
pass the timing function you want to the <tt class="docutils literal"><span class="pre">Profile</span></tt> class
constructor:</p>
<blockquote>
pr = profile.Profile(your_time_func)</blockquote>
<p>The resulting profiler will then call <tt class="docutils literal"><span class="pre">your_time_func()</span></tt>.</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">profile.Profile</span></tt></dt>
<dd><p class="first"><tt class="docutils literal"><span class="pre">your_time_func()</span></tt> should return a single number, or a list of
numbers whose sum is the current time (like what <tt class="docutils literal"><span class="pre">os.times()</span></tt>
returns).  If the function returns a single time number, or the
list of returned numbers has length 2, then you will get an
especially fast version of the dispatch routine.</p>
<p class="last">Be warned that you should calibrate the profiler class for the
timer function that you choose.  For most machines, a timer that
returns a lone integer value will provide the best results in terms
of low overhead during profiling. (<tt class="docutils literal"><span class="pre">os.times()</span></tt> is <em>pretty</em> bad,
as it returns a tuple of floating point values).  If you want to
substitute a better timer in the cleanest fashion, derive a class
and hardwire a replacement dispatch method that best handles your
timer call, along with the appropriate calibration constant.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">cProfile.Profile</span></tt></dt>
<dd><p class="first"><tt class="docutils literal"><span class="pre">your_time_func()</span></tt> should return a single number.  If it returns
plain integers, you can also invoke the class constructor with a
second argument specifying the real duration of one unit of time.
For example, if <tt class="docutils literal"><span class="pre">your_integer_time_func()</span></tt> returns times measured
in thousands of seconds, you would constuct the <tt class="docutils literal"><span class="pre">Profile</span></tt>
instance as follows:</p>
<blockquote>
pr = profile.Profile(your_integer_time_func, 0.001)</blockquote>
<p class="last">As the <tt class="docutils literal"><span class="pre">cProfile.Profile</span></tt> class cannot be calibrated, custom
timer functions should be used with care and should be as fast as
possible.  For the best results with a custom timer, it might be
necessary to hard-code it in the C source of the internal
<tt class="docutils literal"><span class="pre">_lsprof</span></tt> module.</p>
</dd>
</dl>
<p>-[ Footnotes ]-</p>
<dl class="docutils">
<dt>[1] Updated and converted to LaTeX by Guido van Rossum. Further</dt>
<dd>updated by Armin Rigo to integrate the documentation for the new
<tt class="docutils literal"><span class="pre">cProfile</span></tt> module of Python 2.5.</dd>
<dt>[2] Prior to Python 2.2, it was necessary to edit the profiler source</dt>
<dd>code to embed the bias as a literal number.  You still can, but
that method is no longer described, because no longer needed.</dd>
</dl>
</div>
</div>


          </div>
        </div>
      </div>


      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../modindex.html" title="Global Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="timeit.html" title="25.5. timeit — Measure execution time of small code snippets"
             >next</a> |</li>
        <li class="right" >
          <a href="pdb.html" title="25.2. pdb — The Python Debugger"
             >previous</a> |</li>
        <li><a href="../index.html">Jython v2.5.2 documentation</a> &raquo;</li>
          <li><a href="indexprogress.html" >The Python Standard Library and What Comes with Jython</a> &raquo;</li>
          <li><a href="debug.html" >25. Debugging and Profiling</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
      &copy; <a href="../copyright.html">Copyright</a> 2011, Jython Project.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 0.6.4.
    </div>
  </body>
</html>